<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20160519180137.1"><vh>epytext markup</vh></v>
<v t="ekr.20160520102401.1"><vh>Reference</vh>
<v t="ekr.20160519172255.117"><vh>@@clean __init__.py</vh></v>
<v t="ekr.20160519172255.119"><vh>@@clean __main__.py</vh>
<v t="ekr.20160519172255.120"><vh>&lt;&lt;declarations&gt;&gt; (__main__)</vh></v>
</v>
<v t="ekr.20160519172255.2"><vh>@clean api.py</vh>
<v t="ekr.20160519172255.3"><vh>&lt;&lt;declarations&gt;&gt; (api)</vh></v>
<v t="ekr.20160519172255.4"><vh>api.check</vh></v>
<v t="ekr.20160519172255.5"><vh>api.checkPath</vh></v>
<v t="ekr.20160519172255.6"><vh>api.iterSourceCode</vh></v>
<v t="ekr.20160519172255.7"><vh>api.checkRecursive</vh></v>
<v t="ekr.20160519172255.8"><vh>api._exitOnSignal</vh></v>
<v t="ekr.20160519172255.9"><vh>api.main</vh></v>
</v>
<v t="ekr.20160520184945.1"><vh>@clean leo_ast.py</vh>
<v t="ekr.20160520184945.2"><vh>class AstDumper</vh>
<v t="ekr.20160520184945.3"><vh>d.ctor</vh></v>
<v t="ekr.20160520184945.4"><vh>d.dump</vh></v>
<v t="ekr.20160520184945.5"><vh>d.get_fields</vh></v>
<v t="ekr.20160520184945.6"><vh>d.extra_attributes &amp; helpers (not used)</vh>
<v t="ekr.20160520184945.7"><vh>d.do_cache_list</vh></v>
<v t="ekr.20160520184945.8"><vh>d.do_reaching_list</vh></v>
<v t="ekr.20160520184945.9"><vh>d.do_repr</vh></v>
<v t="ekr.20160520184945.10"><vh>d.do_types_list</vh></v>
</v>
</v>
<v t="ekr.20160520184945.11"><vh>class AstFormatter</vh>
<v t="ekr.20160520184945.12"><vh> f.Entries</vh>
<v t="ekr.20160520184945.13"><vh>f.__call__ (not used)</vh></v>
<v t="ekr.20160520184945.14"><vh>f.format</vh></v>
<v t="ekr.20160520184945.15"><vh>f.visit</vh></v>
</v>
<v t="ekr.20160520184945.16"><vh>f.Contexts</vh>
<v t="ekr.20160520184945.17"><vh>f.ClassDef</vh></v>
<v t="ekr.20160520184945.18"><vh>f.FunctionDef</vh></v>
<v t="ekr.20160520184945.19"><vh>f.Interactive</vh></v>
<v t="ekr.20160520184945.20"><vh>f.Module</vh></v>
<v t="ekr.20160520184945.21"><vh>f.Lambda</vh></v>
</v>
<v t="ekr.20160520184945.22"><vh>f.Expressions</vh>
<v t="ekr.20160520184945.23"><vh>f.Expr</vh></v>
<v t="ekr.20160520184945.24"><vh>f.Expression</vh></v>
<v t="ekr.20160520184945.25"><vh>f.GeneratorExp</vh></v>
<v t="ekr.20160520184945.26"><vh>f.ctx nodes</vh></v>
</v>
<v t="ekr.20160520184945.27"><vh>f.Operands</vh>
<v t="ekr.20160520184945.28"><vh>f.arguments</vh></v>
<v t="ekr.20160520184945.29"><vh>f.arg (Python3 only)</vh></v>
<v t="ekr.20160520184945.30"><vh>f.Attribute</vh></v>
<v t="ekr.20160520184945.31"><vh>f.Bytes</vh></v>
<v t="ekr.20160520184945.32"><vh>f.Call &amp; f.keyword</vh>
<v t="ekr.20160520184945.33"><vh>f.keyword</vh></v>
</v>
<v t="ekr.20160520184945.34"><vh>f.comprehension</vh></v>
<v t="ekr.20160520184945.35"><vh>f.Dict</vh></v>
<v t="ekr.20160520184945.36"><vh>f.Ellipsis</vh></v>
<v t="ekr.20160520184945.37"><vh>f.ExtSlice</vh></v>
<v t="ekr.20160520184945.38"><vh>f.Index</vh></v>
<v t="ekr.20160520184945.39"><vh>f.List</vh></v>
<v t="ekr.20160520184945.40"><vh>f.ListComp</vh></v>
<v t="ekr.20160520184945.41"><vh>f.Name</vh></v>
<v t="ekr.20160520184945.42"><vh>f.Num</vh></v>
<v t="ekr.20160520184945.43"><vh>f.Repr</vh></v>
<v t="ekr.20160520184945.44"><vh>f.Slice</vh></v>
<v t="ekr.20160520184945.45"><vh>f.Str</vh></v>
<v t="ekr.20160520184945.46"><vh>f.Subscript</vh></v>
<v t="ekr.20160520184945.47"><vh>f.Tuple</vh></v>
</v>
<v t="ekr.20160520184945.48"><vh>f.Operators</vh>
<v t="ekr.20160520184945.49"><vh>f.BinOp</vh></v>
<v t="ekr.20160520184945.50"><vh>f.BoolOp</vh></v>
<v t="ekr.20160520184945.51"><vh>f.Compare</vh></v>
<v t="ekr.20160520184945.52"><vh>f.UnaryOp</vh></v>
<v t="ekr.20160520184945.53"><vh>f.ifExp (ternary operator)</vh></v>
</v>
<v t="ekr.20160520184945.54"><vh>f.Statements</vh>
<v t="ekr.20160520184945.55"><vh>f.Assert</vh></v>
<v t="ekr.20160520184945.56"><vh>f.Assign</vh></v>
<v t="ekr.20160520184945.57"><vh>f.AugAssign</vh></v>
<v t="ekr.20160520184945.58"><vh>f.Break</vh></v>
<v t="ekr.20160520184945.59"><vh>f.Continue</vh></v>
<v t="ekr.20160520184945.60"><vh>f.Delete</vh></v>
<v t="ekr.20160520184945.61"><vh>f.ExceptHandler</vh></v>
<v t="ekr.20160520184945.62"><vh>f.Exec</vh></v>
<v t="ekr.20160520184945.63"><vh>f.For</vh></v>
<v t="ekr.20160520184945.64"><vh>f.Global</vh></v>
<v t="ekr.20160520184945.65"><vh>f.If</vh></v>
<v t="ekr.20160520184945.66"><vh>f.Import &amp; helper</vh>
<v t="ekr.20160520184945.67"><vh>f.get_import_names</vh></v>
</v>
<v t="ekr.20160520184945.68"><vh>f.ImportFrom</vh></v>
<v t="ekr.20160520184945.69"><vh>f.Nonlocal (Python 3)</vh></v>
<v t="ekr.20160520184945.70"><vh>f.Pass</vh></v>
<v t="ekr.20160520184945.71"><vh>f.Print</vh></v>
<v t="ekr.20160520184945.72"><vh>f.Raise</vh></v>
<v t="ekr.20160520184945.73"><vh>f.Return</vh></v>
<v t="ekr.20160520184945.74"><vh>f.Starred (Python 3)</vh></v>
<v t="ekr.20160520184945.75"><vh>f.Suite</vh></v>
<v t="ekr.20160520184945.76"><vh>f.Try (Python 3)</vh></v>
<v t="ekr.20160520184945.77"><vh>f.TryExcept</vh></v>
<v t="ekr.20160520184945.78"><vh>f.TryFinally</vh></v>
<v t="ekr.20160520184945.79"><vh>f.While</vh></v>
<v t="ekr.20160520184945.80"><vh>f.With</vh></v>
<v t="ekr.20160520184945.81"><vh>f.Yield</vh></v>
<v t="ekr.20160520184945.82"><vh>f.YieldFrom (Python 3)</vh></v>
</v>
<v t="ekr.20160520184945.83"><vh>f.Utils</vh>
<v t="ekr.20160520184945.84"><vh>f.kind</vh></v>
<v t="ekr.20160520184945.85"><vh>f.indent</vh></v>
<v t="ekr.20160520184945.86"><vh>f.op_name</vh></v>
</v>
</v>
<v t="ekr.20160520184945.87"><vh>class AstFullTraverser</vh>
<v t="ekr.20160520184945.88"><vh>ft.contexts</vh>
<v t="ekr.20160520184945.89"><vh>ft.ClassDef</vh></v>
<v t="ekr.20160520184945.90"><vh>ft.FunctionDef</vh></v>
<v t="ekr.20160520184945.91"><vh>ft.Interactive</vh></v>
<v t="ekr.20160520184945.92"><vh>ft.Lambda</vh></v>
<v t="ekr.20160520184945.93"><vh>ft.Module</vh></v>
</v>
<v t="ekr.20160520184945.94"><vh>ft.ctx nodes</vh></v>
<v t="ekr.20160520184945.95"><vh>ft.kind</vh></v>
<v t="ekr.20160520184945.96"><vh>ft.operators &amp; operands</vh>
<v t="ekr.20160520184945.97"><vh>ft.arguments &amp; arg</vh></v>
<v t="ekr.20160520184945.98"><vh>ft.Attribute</vh></v>
<v t="ekr.20160520184945.99"><vh>ft.BinOp</vh></v>
<v t="ekr.20160520184945.100"><vh>ft.BoolOp</vh></v>
<v t="ekr.20160520184945.101"><vh>ft.Bytes</vh></v>
<v t="ekr.20160520184945.102"><vh>ft.Call</vh></v>
<v t="ekr.20160520184945.103"><vh>ft.Compare</vh></v>
<v t="ekr.20160520184945.104"><vh>ft.Compare ops</vh></v>
<v t="ekr.20160520184945.105"><vh>ft.comprehension</vh></v>
<v t="ekr.20160520184945.106"><vh>ft.Dict</vh></v>
<v t="ekr.20160520184945.107"><vh>ft.Ellipsis</vh></v>
<v t="ekr.20160520184945.108"><vh>ft.Expr</vh></v>
<v t="ekr.20160520184945.109"><vh>ft.Expression</vh></v>
<v t="ekr.20160520184945.110"><vh>ft.ExtSlice</vh></v>
<v t="ekr.20160520184945.111"><vh>ft.GeneratorExp</vh></v>
<v t="ekr.20160520184945.112"><vh>ft.ifExp (ternary operator)</vh></v>
<v t="ekr.20160520184945.113"><vh>ft.Index</vh></v>
<v t="ekr.20160520184945.114"><vh>ft.keyword</vh></v>
<v t="ekr.20160520184945.115"><vh>ft.List &amp; ListComp</vh></v>
<v t="ekr.20160520184945.116"><vh>ft.Name (revise) &amp; NameConstant</vh></v>
<v t="ekr.20160520184945.117"><vh>ft.Num</vh></v>
<v t="ekr.20160520184945.118"><vh>ft.Repr</vh></v>
<v t="ekr.20160520184945.119"><vh>ft.Slice</vh></v>
<v t="ekr.20160520184945.120"><vh>ft.Str</vh></v>
<v t="ekr.20160520184945.121"><vh>ft.Subscript</vh></v>
<v t="ekr.20160520184945.122"><vh>ft.Tuple</vh></v>
<v t="ekr.20160520184945.123"><vh>ft.UnaryOp</vh></v>
</v>
<v t="ekr.20160520184945.124"><vh>ft.statements</vh>
<v t="ekr.20160520184945.125"><vh>ft.alias</vh></v>
<v t="ekr.20160520184945.126"><vh>ft.Assert</vh></v>
<v t="ekr.20160520184945.127"><vh>ft.Assign</vh></v>
<v t="ekr.20160520184945.128"><vh>ft.AugAssign</vh></v>
<v t="ekr.20160520184945.129"><vh>ft.Break</vh></v>
<v t="ekr.20160520184945.130"><vh>ft.Continue</vh></v>
<v t="ekr.20160520184945.131"><vh>ft.Delete</vh></v>
<v t="ekr.20160520184945.132"><vh>ft.ExceptHandler</vh></v>
<v t="ekr.20160520184945.133"><vh>ft.Exec</vh></v>
<v t="ekr.20160520184945.134"><vh>ft.For</vh></v>
<v t="ekr.20160520184945.135"><vh>ft.Global</vh></v>
<v t="ekr.20160520184945.136"><vh>ft.If</vh></v>
<v t="ekr.20160520184945.137"><vh>ft.Import &amp; ImportFrom</vh></v>
<v t="ekr.20160520184945.138"><vh>ft.Nonlocal (Python 3)</vh></v>
<v t="ekr.20160520184945.139"><vh>ft.Pass</vh></v>
<v t="ekr.20160520184945.140"><vh>ft.Print</vh></v>
<v t="ekr.20160520184945.141"><vh>ft.Raise</vh></v>
<v t="ekr.20160520184945.142"><vh>ft.Return</vh></v>
<v t="ekr.20160520184945.143"><vh>ft.Starred (Python 3)</vh></v>
<v t="ekr.20160520184945.144"><vh>ft.Try (Python 3)</vh></v>
<v t="ekr.20160520184945.145"><vh>ft.TryExcept</vh></v>
<v t="ekr.20160520184945.146"><vh>ft.TryFinally</vh></v>
<v t="ekr.20160520184945.147"><vh>ft.While</vh></v>
<v t="ekr.20160520184945.148"><vh>ft.With</vh></v>
<v t="ekr.20160520184945.149"><vh>ft.Yield</vh></v>
<v t="ekr.20160520184945.150"><vh>ft.YieldFrom (Python 3)</vh></v>
</v>
<v t="ekr.20160520184945.151"><vh>ft.visit</vh></v>
<v t="ekr.20160520184945.152"><vh>ft.visit_list</vh></v>
</v>
<v t="ekr.20160520184945.153"><vh>class AstPatternFormatter (AstFormatter)</vh>
<v t="ekr.20160520184945.154"><vh>Constants &amp; Name</vh></v>
</v>
<v t="ekr.20160520184945.252"><vh>class TokenSync</vh>
<v t="ekr.20160520184945.253"><vh> ts.ctor &amp; helpers</vh>
<v t="ekr.20160520184945.254"><vh>ts.make_blank_lines</vh></v>
<v t="ekr.20160520184945.255"><vh>ts.make_ignored_lines</vh></v>
<v t="ekr.20160520184945.256"><vh>ts.make_line_tokens (trace tokens)</vh></v>
<v t="ekr.20160520184945.257"><vh>ts.make_nl_token</vh></v>
<v t="ekr.20160520184945.258"><vh>ts.make_string_tokens</vh></v>
</v>
<v t="ekr.20160520184945.259"><vh>ts.check_strings</vh></v>
<v t="ekr.20160520184945.260"><vh>ts.dump_token</vh></v>
<v t="ekr.20160520184945.261"><vh>ts.is_line_comment</vh></v>
<v t="ekr.20160520184945.262"><vh>ts.join</vh></v>
<v t="ekr.20160520184945.263"><vh>ts.last_node</vh></v>
<v t="ekr.20160520184945.264"><vh>ts.leading_lines</vh></v>
<v t="ekr.20160520184945.265"><vh>ts.leading_string</vh></v>
<v t="ekr.20160520184945.266"><vh>ts.line_at</vh></v>
<v t="ekr.20160520184945.267"><vh>ts.sync_string</vh></v>
<v t="ekr.20160520184945.268"><vh>ts.token_kind/raw_val/val</vh></v>
<v t="ekr.20160520184945.269"><vh>ts.tokens_for_statement</vh></v>
<v t="ekr.20160520184945.270"><vh>ts.trailing_comment</vh></v>
<v t="ekr.20160520184945.271"><vh>ts.trailing_comment_at_lineno</vh></v>
<v t="ekr.20160520184945.272"><vh>ts.trailing_lines</vh></v>
</v>
</v>
<v t="ekr.20160519172255.79"><vh>@clean messages.py</vh>
<v t="ekr.20160519172255.80"><vh>class Message</vh>
<v t="ekr.20160519172255.81"><vh>__init__</vh></v>
<v t="ekr.20160519172255.82"><vh>__str__</vh></v>
</v>
<v t="ekr.20160519172255.83"><vh>class UnusedImport</vh>
<v t="ekr.20160519172255.84"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.85"><vh>class RedefinedWhileUnused</vh>
<v t="ekr.20160519172255.86"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.87"><vh>class RedefinedInListComp</vh>
<v t="ekr.20160519172255.88"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.89"><vh>class ImportShadowedByLoopVar</vh>
<v t="ekr.20160519172255.90"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.91"><vh>class ImportStarUsed</vh>
<v t="ekr.20160519172255.92"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.93"><vh>class UndefinedName</vh>
<v t="ekr.20160519172255.94"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.95"><vh>class DoctestSyntaxError</vh>
<v t="ekr.20160519172255.96"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.97"><vh>class UndefinedExport</vh>
<v t="ekr.20160519172255.98"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.99"><vh>class UndefinedLocal</vh>
<v t="ekr.20160519172255.100"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.101"><vh>class DuplicateArgument</vh>
<v t="ekr.20160519172255.102"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.103"><vh>class LateFutureImport</vh>
<v t="ekr.20160519172255.104"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.105"><vh>class UnusedVariable</vh>
<v t="ekr.20160519172255.106"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.107"><vh>class ReturnWithArgsInsideGenerator</vh></v>
<v t="ekr.20160519172255.108"><vh>class ReturnOutsideFunction</vh></v>
</v>
<v t="ekr.20160519172255.109"><vh>@clean reporter.py</vh>
<v t="ekr.20160519172255.111"><vh>class Reporter</vh>
<v t="ekr.20160519172255.112"><vh>__init__</vh></v>
<v t="ekr.20160519172255.113"><vh>unexpectedError</vh></v>
<v t="ekr.20160519172255.114"><vh>syntaxError</vh></v>
<v t="ekr.20160519172255.115"><vh>flake</vh></v>
</v>
<v t="ekr.20160519172255.116"><vh>_makeDefaultReporter</vh></v>
</v>
</v>
<v t="ekr.20160520163049.1"><vh>Study</vh>
<v t="ekr.20160519172947.1"><vh>Found:handleChildren</vh>
<v t="ekr.20160519172255.67"><vh>GENERATOREXP &amp; comprehensions</vh></v>
<v t="ekr.20160519172255.77"><vh>TRY</vh></v>
<v t="ekr.20160519172255.78"><vh>EXCEPTHANDLER</vh></v>
<v t="ekr.20160519172255.59"><vh>handleChildren</vh></v>
<v t="ekr.20160519172255.64"><vh>handleDoctests</vh></v>
<v t="ekr.20160519172255.41"><vh>Checker.__init__</vh></v>
</v>
<v t="ekr.20160519182919.1"><vh>test of getFields code</vh></v>
<v t="ekr.20160519173152.1"><vh>handle...</vh>
<v t="ekr.20160519172255.59"></v>
<v t="ekr.20160519172255.64"></v>
<v t="ekr.20160519172255.63"><vh>handleNode (sets parent/depth fields)</vh></v>
<v t="ekr.20160519172255.58"><vh>handleNodeDelete</vh></v>
<v t="ekr.20160519172255.56"><vh>handleNodeLoad</vh></v>
<v t="ekr.20160519172255.57"><vh>handleNodeStore</vh></v>
</v>
<v t="ekr.20160519185320.1"><vh>Found:getAlternatives</vh>
<v t="ekr.20160519172255.53"><vh>differentForks</vh></v>
<v t="ekr.20160519181035.1"><vh>getAlternatives</vh></v>
</v>
</v>
<v t="ekr.20160520163727.1"><vh>Changed</vh>
<v t="ekr.20160519172255.13"><vh>_FieldsOrder._get_fields</vh></v>
<v t="ekr.20160520184945.151"></v>
</v>
<v t="ekr.20160519172255.10"><vh>@clean checker.py</vh>
<v t="ekr.20160519172255.11"><vh>&lt;&lt; imports &gt;&gt; (checker)</vh></v>
<v t="ekr.20160519172255.12"><vh>class _FieldsOrder(dict)</vh>
<v t="ekr.20160519172255.13"></v>
<v t="ekr.20160519172255.14"><vh>_FieldsOrder.__missing__</vh></v>
</v>
<v t="ekr.20160519181348.1"><vh>top-level getters</vh>
<v t="ekr.20160519181035.1"></v>
<v t="ekr.20160519172255.39"><vh>getNodeName</vh></v>
<v t="ekr.20160519180953.1"><vh>getNodeType (returns uppercase class name)</vh></v>
<v t="ekr.20160519172255.15"><vh>iter_child_nodes</vh></v>
</v>
<v t="ekr.20160519172710.1"><vh>Bindings &amp; Definitions</vh>
<v t="ekr.20160519172255.16"><vh>class Binding</vh>
<v t="ekr.20160519172255.17"><vh>__init__</vh></v>
<v t="ekr.20160519172255.18"><vh>__str__</vh></v>
<v t="ekr.20160519172255.19"><vh>__repr__</vh></v>
<v t="ekr.20160519172255.20"><vh>redefines</vh></v>
</v>
<v t="ekr.20160519172255.21"><vh>class Definition (Binding)</vh></v>
<v t="ekr.20160519172255.22"><vh>class Importation (Definition)</vh>
<v t="ekr.20160519172255.23"><vh>__init__</vh></v>
<v t="ekr.20160519172255.24"><vh>redefines</vh></v>
</v>
<v t="ekr.20160519172255.25"><vh>class Argument (Binding)</vh></v>
<v t="ekr.20160519172255.26"><vh>class Assignment (Binding)</vh></v>
<v t="ekr.20160519172255.27"><vh>class FunctionDefinition (Definition)</vh></v>
<v t="ekr.20160519172255.28"><vh>class ClassDefinition (Definition)</vh></v>
<v t="ekr.20160519172255.29"><vh>class ExportBinding (Binding)</vh>
<v t="ekr.20160519172255.30"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20160519172730.1"><vh>Scopes</vh>
<v t="ekr.20160519172255.31"><vh>class Scope(dict)</vh>
<v t="ekr.20160519172255.32"><vh>Scope.__repr__</vh></v>
</v>
<v t="ekr.20160519172255.33"><vh>class ClassScope (Scope)</vh></v>
<v t="ekr.20160519172255.34"><vh>class FunctionScope (Scope)</vh>
<v t="ekr.20160519172255.35"><vh>__init__</vh></v>
<v t="ekr.20160519172255.36"><vh>unusedAssignments</vh></v>
</v>
<v t="ekr.20160519172255.37"><vh>class GeneratorScope (Scope)</vh></v>
<v t="ekr.20160519172255.38"><vh>class ModuleScope (Scope)</vh></v>
</v>
<v t="ekr.20160519172255.40"><vh>class Checker</vh>
<v t="ekr.20160519172255.41"></v>
<v t="ekr.20160519172255.42"><vh>deferFunction</vh></v>
<v t="ekr.20160519172255.43"><vh>deferAssignment</vh></v>
<v t="ekr.20160519172255.44"><vh>runDeferred</vh></v>
<v t="ekr.20160519173318.1"><vh>scopes...</vh>
<v t="ekr.20160519172255.45"><vh>scope (property)</vh></v>
<v t="ekr.20160519172255.46"><vh>popScope</vh></v>
<v t="ekr.20160519172255.47"><vh>checkDeadScopes</vh></v>
<v t="ekr.20160519172255.48"><vh>pushScope</vh></v>
</v>
<v t="ekr.20160519172255.49"><vh>report</vh></v>
<v t="ekr.20160519173339.1"><vh>tree structure</vh>
<v t="ekr.20160519172255.50"><vh>getParent</vh></v>
<v t="ekr.20160519172255.51"><vh>getCommonAncestor</vh></v>
<v t="ekr.20160519172255.52"><vh>descendantOf</vh></v>
<v t="ekr.20160519172255.53"></v>
</v>
<v t="ekr.20160519172255.54"><vh>addBinding</vh></v>
<v t="ekr.20160519172255.55"><vh>getNodeHandler</vh></v>
<v t="ekr.20160519173152.1"></v>
<v t="ekr.20160519172255.60"><vh>isLiteralTupleUnpacking</vh></v>
<v t="ekr.20160519172255.61"><vh>isDocstring</vh></v>
<v t="ekr.20160519172255.62"><vh>getDocstring</vh></v>
<v t="ekr.20160519172255.65"><vh>ignore</vh></v>
<v t="ekr.20160519172836.1"><vh>Node handlers</vh>
<v t="ekr.20160519172255.66"><vh>GLOBAL &amp; NONLOCAL</vh></v>
<v t="ekr.20160519172255.67"></v>
<v t="ekr.20160519172255.68"><vh>NAME</vh></v>
<v t="ekr.20160519172255.69"><vh>RETURN</vh></v>
<v t="ekr.20160519172255.70"><vh>YIELD</vh></v>
<v t="ekr.20160519172255.71"><vh>FUNCTIONDEF</vh></v>
<v t="ekr.20160519172255.72"><vh>LAMBDA</vh></v>
<v t="ekr.20160519172255.73"><vh>CLASSDEF</vh></v>
<v t="ekr.20160519172255.74"><vh>AUGASSIGN</vh></v>
<v t="ekr.20160519172255.75"><vh>IMPORT</vh></v>
<v t="ekr.20160519172255.76"><vh>IMPORTFROM</vh></v>
<v t="ekr.20160519172255.77"></v>
<v t="ekr.20160519172255.78"></v>
</v>
</v>
</v>
<v t="ekr.20160520195402.1"><vh>Found:Binding</vh>
<v t="ekr.20160519172255.57"></v>
<v t="ekr.20160519172255.16"></v>
<v t="ekr.20160519172255.21"></v>
<v t="ekr.20160519172255.26"></v>
<v t="ekr.20160519172255.22"></v>
<v t="ekr.20160519172255.25"></v>
<v t="ekr.20160519172255.29"></v>
<v t="ekr.20160519172255.36"></v>
<v t="ekr.20160519172255.54"></v>
<v t="ekr.20160519172255.72"></v>
</v>
<v t="ekr.20160519172255.54"></v>
<v t="ekr.20160519172255.31"></v>
<v t="ekr.20160520081237.1"><vh>@button test</vh>
<v t="ekr.20160520162722.1"><vh>&lt;&lt; define s &gt;&gt;</vh></v>
<v t="ekr.20160520160409.1"><vh>&lt;&lt; test imports &gt;&gt;</vh></v>
<v t="ekr.20160520082209.1"><vh>check_all</vh></v>
<v t="ekr.20160520162336.1"><vh>check_string</vh></v>
<v t="ekr.20160520210414.1"><vh>compile_string</vh></v>
<v t="ekr.20160520210256.1"><vh>read_string</vh></v>
<v t="ekr.20160520081827.1"><vh>run_test</vh></v>
<v t="ekr.20160520210931.1"><vh>traverse_tree</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20160519172255.10">"""
Main module.

Implement the central Checker class.
Also, it models the Bindings and Scopes.
"""

@language python
@tabwidth -4

&lt;&lt;imports&gt;&gt;

# Globally defined names which are not attributes of the builtins module, or
# are only present on some platforms.
_MAGIC_GLOBALS = ['__file__', '__builtins__', 'WindowsError']

@others
</t>
<t tx="ekr.20160519172255.100">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.101">class DuplicateArgument(Message):
    message = 'duplicate argument %r in function definition'

    @others
</t>
<t tx="ekr.20160519172255.102">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.103">class LateFutureImport(Message):
    message = 'future import(s) %r after other statements'

    @others
</t>
<t tx="ekr.20160519172255.104">def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)
</t>
<t tx="ekr.20160519172255.105">class UnusedVariable(Message):
    """
    Indicates that a variable has been explicity assigned to but not actually
    used.
    """
    message = 'local variable %r is assigned to but never used'

    @others
</t>
<t tx="ekr.20160519172255.106">def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)
</t>
<t tx="ekr.20160519172255.107">class ReturnWithArgsInsideGenerator(Message):
    """
    Indicates a return statement with arguments inside a generator.
    """
    message = '\'return\' with argument inside generator'
</t>
<t tx="ekr.20160519172255.108">class ReturnOutsideFunction(Message):
    """
    Indicates a return statement outside of a function/method.
    """
    message = '\'return\' outside function'
</t>
<t tx="ekr.20160519172255.109">"""
Provide the Reporter class.
"""
import re
import sys
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20160519172255.11"># checker.py imports...

import leo.core.leoGlobals as g # EKR

import doctest
import os
import sys

PY2 = sys.version_info &lt; (3, 0)
PY32 = sys.version_info &lt; (3, 3)    # Python 2.5 to 3.2
PY33 = sys.version_info &lt; (3, 4)    # Python 2.5 to 3.3
builtin_vars = dir(__import__('__builtin__' if PY2 else 'builtins'))

try:
    import ast
except ImportError:     # Python 2.5
    import _ast as ast

    if 'decorator_list' not in ast.ClassDef._fields:
        # Patch the missing attribute 'decorator_list'
        ast.ClassDef.decorator_list = ()
        ast.FunctionDef.decorator_list = property(lambda s: s.decorators)

import messages # EKR
# from pyflakes import messages
</t>
<t tx="ekr.20160519172255.111">class Reporter(object):
    """
    Formats the results of pyflakes checks to users.
    """
    @others
</t>
<t tx="ekr.20160519172255.112">def __init__(self, warningStream, errorStream):
    """
    Construct a L{Reporter}.

    @param warningStream: A file-like object where warnings will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stdout} is a good value.
    @param errorStream: A file-like object where error output will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stderr} is a good value.
    """
    self._stdout = warningStream
    self._stderr = errorStream
</t>
<t tx="ekr.20160519172255.113">def unexpectedError(self, filename, msg):
    """
    An unexpected error occurred trying to process C{filename}.

    @param filename: The path to a file that we could not process.
    @ptype filename: C{unicode}
    @param msg: A message explaining the problem.
    @ptype msg: C{unicode}
    """
    self._stderr.write("%s: %s\n" % (filename, msg))
</t>
<t tx="ekr.20160519172255.114">def syntaxError(self, filename, msg, lineno, offset, text):
    """
    There was a syntax errror in C{filename}.

    @param filename: The path to the file with the syntax error.
    @ptype filename: C{unicode}
    @param msg: An explanation of the syntax error.
    @ptype msg: C{unicode}
    @param lineno: The line number where the syntax error occurred.
    @ptype lineno: C{int}
    @param offset: The column on which the syntax error occurred, or None.
    @ptype offset: C{int}
    @param text: The source code containing the syntax error.
    @ptype text: C{unicode}
    """
    line = text.splitlines()[-1]
    if offset is not None:
        offset = offset - (len(text) - len(line))
        self._stderr.write('%s:%d:%d: %s\n' %
                           (filename, lineno, offset + 1, msg))
    else:
        self._stderr.write('%s:%d: %s\n' % (filename, lineno, msg))
    self._stderr.write(line)
    self._stderr.write('\n')
    if offset is not None:
        self._stderr.write(re.sub(r'\S', ' ', line[:offset]) +
                           "^\n")
</t>
<t tx="ekr.20160519172255.115">def flake(self, message):
    """
    pyflakes found something wrong with the code.

    @param: A L{pyflakes.messages.Message}.
    """
    self._stdout.write(str(message))
    self._stdout.write('\n')
</t>
<t tx="ekr.20160519172255.116">def _makeDefaultReporter():
    """
    Make a reporter that can be used when no reporter is specified.
    """
    return Reporter(sys.stdout, sys.stderr)
</t>
<t tx="ekr.20160519172255.117">@language python
@tabwidth -4
__version__ = '1.0.0'

</t>
<t tx="ekr.20160519172255.119">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="ekr.20160519172255.12">class _FieldsOrder(dict):
    """Fix order of AST node fields."""
    @others
</t>
<t tx="ekr.20160519172255.120">from pyflakes.api import main

# python -m pyflakes (with Python &gt;= 2.7)
if __name__ == '__main__':
    main(prog='pyflakes')
</t>
<t tx="ekr.20160519172255.13">def _get_fields(self, node_class):
    # handle iter before target, and generators before element
    # EKR: the effect of the key is to assign 0 to 'iter' or 'generators' or 'value'
    # and -1 to everything else. So the target is *last*, so reverse=True is needed.
    if 1: # EKR new code
        fields = list(node_class._fields)
        for field in ('iter', 'generators', 'value'):
            if field in fields:
                fields.remove(field)
                fields.insert(0, field)
                break
        return tuple(fields)
    else:
        fields = node_class._fields
        if 'iter' in fields:
            key_first = 'iter'.find
        elif 'generators' in fields:
            key_first = 'generators'.find
        else:
            key_first = 'value'.find
        return tuple(sorted(fields, key=key_first, reverse=True))
    </t>
<t tx="ekr.20160519172255.14">def __missing__(self, node_class):
    # EKR: called if self[node_class] does not exist.
    self[node_class] = fields = self._get_fields(node_class)
    # g.trace(node_class.__name__, fields)
    return fields
</t>
<t tx="ekr.20160519172255.15">def iter_child_nodes(node, omit=None, _fields_order=_FieldsOrder()):
    """
    Yield all direct child nodes of *node*, that is, all fields that
    are nodes and all items of fields that are lists of nodes.
    """
    for name in _fields_order[node.__class__]:
        if name == omit:
            continue
        field = getattr(node, name, None)
        if isinstance(field, ast.AST):
            yield field
        elif isinstance(field, list):
            for item in field:
                yield item
</t>
<t tx="ekr.20160519172255.16">class Binding(object):
    """
    Represents the binding of a value to a name.

    The checker uses this to keep track of which names have been bound and
    which names have not. See L{Assignment} for a special type of binding that
    is checked with stricter rules.

    @ivar used: pair of (L{Scope}, line-number) indicating the scope and
                line number that this binding was last used
    """
    @others
</t>
<t tx="ekr.20160519172255.17">def __init__(self, name, source):
    self.name = name
    self.source = source
    self.used = False
</t>
<t tx="ekr.20160519172255.18">def __str__(self):
    return self.name
</t>
<t tx="ekr.20160519172255.19">def __repr__(self):
    return '&lt;%s object %r from line %r at 0x%x&gt;' % (self.__class__.__name__,
                                                    self.name,
                                                    self.source.lineno,
                                                    id(self))
</t>
<t tx="ekr.20160519172255.2">"""
API for the command-line I{pyflakes} tool.
"""

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="ekr.20160519172255.20">def redefines(self, other):
    return isinstance(other, Definition) and self.name == other.name
</t>
<t tx="ekr.20160519172255.21">class Definition(Binding):
    """
    A binding that defines a function or a class.
    """
</t>
<t tx="ekr.20160519172255.22">class Importation(Definition):
    """
    A binding created by an import statement.

    @ivar fullName: The complete name given to the import statement,
        possibly including multiple dotted components.
    @type fullName: C{str}
    """
    @others
</t>
<t tx="ekr.20160519172255.23">def __init__(self, name, source):
    self.fullName = name
    self.redefined = []
    name = name.split('.')[0]
    super(Importation, self).__init__(name, source)
</t>
<t tx="ekr.20160519172255.24">def redefines(self, other):
    if isinstance(other, Importation):
        return self.fullName == other.fullName
    return isinstance(other, Definition) and self.name == other.name
</t>
<t tx="ekr.20160519172255.25">class Argument(Binding):
    """
    Represents binding a name as an argument.
    """
</t>
<t tx="ekr.20160519172255.26">class Assignment(Binding):
    """
    Represents binding a name with an explicit assignment.

    The checker will raise warnings for any Assignment that isn't used. Also,
    the checker does not consider assignments in tuple/list unpacking to be
    Assignments, rather it treats them as simple Bindings.
    """
</t>
<t tx="ekr.20160519172255.27">class FunctionDefinition(Definition):
    pass
</t>
<t tx="ekr.20160519172255.28">class ClassDefinition(Definition):
    pass
</t>
<t tx="ekr.20160519172255.29">class ExportBinding(Binding):
    """
    A binding created by an C{__all__} assignment.  If the names in the list
    can be determined statically, they will be treated as names for export and
    additional checking applied to them.

    The only C{__all__} assignment that can be recognized is one which takes
    the value of a literal list containing literal strings.  For example::

        __all__ = ["foo", "bar"]

    Names which are imported and not otherwise used but appear in the value of
    C{__all__} will not have an unused import warning reported for them.
    """
    @others
</t>
<t tx="ekr.20160519172255.3">from __future__ import with_statement

import sys
import os
import _ast

### from pyflakes import checker, __version__
import checker # EKR
__version__ = 'EKR: __version__'
### from pyflakes import reporter as modReporter
import reporter as modReporter # EKR

__all__ = ['check', 'checkPath', 'checkRecursive', 'iterSourceCode', 'main']
</t>
<t tx="ekr.20160519172255.30">def __init__(self, name, source, scope):
    if '__all__' in scope and isinstance(source, ast.AugAssign):
        self.names = list(scope['__all__'].names)
    else:
        self.names = []
    if isinstance(source.value, (ast.List, ast.Tuple)):
        for node in source.value.elts:
            if isinstance(node, ast.Str):
                self.names.append(node.s)
    super(ExportBinding, self).__init__(name, source)
</t>
<t tx="ekr.20160519172255.31">class Scope(dict):
    importStarred = False       # set to True when import * is found

    @others
</t>
<t tx="ekr.20160519172255.32">def __repr__(self):
    scope_cls = self.__class__.__name__
    return '&lt;%s at 0x%x %s&gt;' % (scope_cls, id(self), dict.__repr__(self))
</t>
<t tx="ekr.20160519172255.33">class ClassScope(Scope):
    pass
</t>
<t tx="ekr.20160519172255.34">class FunctionScope(Scope):
    """
    I represent a name scope for a function.

    @ivar globals: Names declared 'global' in this function.
    """
    usesLocals = False
    alwaysUsed = set(['__tracebackhide__',
                      '__traceback_info__', '__traceback_supplement__'])

    @others
</t>
<t tx="ekr.20160519172255.35">def __init__(self):
    super(FunctionScope, self).__init__()
    # Simplify: manage the special locals as globals
    self.globals = self.alwaysUsed.copy()
    self.returnValue = None     # First non-empty return
    self.isGenerator = False    # Detect a generator
</t>
<t tx="ekr.20160519172255.36">def unusedAssignments(self):
    """
    Return a generator for the assignments which have not been used.
    """
    for name, binding in self.items():
        if (not binding.used and name not in self.globals
                and not self.usesLocals
                and isinstance(binding, Assignment)):
            yield name, binding
</t>
<t tx="ekr.20160519172255.37">class GeneratorScope(Scope):
    pass
</t>
<t tx="ekr.20160519172255.38">class ModuleScope(Scope):
    pass
</t>
<t tx="ekr.20160519172255.39">def getNodeName(node):
    # Returns node.id, or node.name, or None
    if hasattr(node, 'id'):     # One of the many nodes with an id
        return node.id
    if hasattr(node, 'name'):   # a ExceptHandler node
        return node.name
</t>
<t tx="ekr.20160519172255.4">def check(codeString, filename, reporter=None, tree=None): # EKR: added tree.
    """
    Check the Python source given by C{codeString} for flakes.

    @param codeString: The Python source to check.
    @type codeString: C{str}

    @param filename: The name of the file the source came from, used to report
        errors.
    @type filename: C{str}

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: The number of warnings emitted.
    @rtype: C{int}
    """
    # print('EKR: api.check: %s' % filename)
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    # First, compile into an AST and handle syntax errors.
    if not tree:
        try:
            tree = compile(codeString, filename, "exec", _ast.PyCF_ONLY_AST)
        except SyntaxError:
            value = sys.exc_info()[1]
            msg = value.args[0]
    
            (lineno, offset, text) = value.lineno, value.offset, value.text
            g.es_print_exception() # EKR
    
            # If there's an encoding problem with the file, the text is None.
            if text is None:
                # Avoid using msg, since for the only known case, it contains a
                # bogus message that claims the encoding the file declared was
                # unknown.
                # EKR:
                reporter.unexpectedError(filename, 'no text: syntax error?')
            else:
                reporter.syntaxError(filename, msg, lineno, offset, text)
            return 1
        except Exception:
            g.es_print_exception() # EKR
            reporter.unexpectedError(filename, 'unexpected exception')
            return 1
    # Okay, it's syntactically valid.  Now check it.
    w = checker.Checker(tree, filename)
    w.messages.sort(key=lambda m: m.lineno)
    for warning in w.messages:
        reporter.flake(warning)
    return len(w.messages)
</t>
<t tx="ekr.20160519172255.40">class Checker(object):
    """
    I check the cleanliness and sanity of Python code.

    @ivar _deferredFunctions: Tracking list used by L{deferFunction}.  Elements
        of the list are two-tuples.  The first element is the callable passed
        to L{deferFunction}.  The second element is a copy of the scope stack
        at the time L{deferFunction} was called.

    @ivar _deferredAssignments: Similar to C{_deferredFunctions}, but for
        callables which are deferred assignment checks.
    """

    nodeDepth = 0
    offset = None
    traceTree = False

    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)
    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')
    if _customBuiltIns:
        builtIns.update(_customBuiltIns.split(','))
    del _customBuiltIns

    @others
</t>
<t tx="ekr.20160519172255.41">def __init__(self, tree, filename='(none)', builtins=None,
             withDoctest='PYFLAKES_DOCTEST' in os.environ):
    self._nodeHandlers = {}
    self._deferredFunctions = []
    self._deferredAssignments = []
    self.deadScopes = []
    self.messages = []
    self.filename = filename
    if builtins:
        self.builtIns = self.builtIns.union(builtins)
    self.withDoctest = withDoctest
    self.scopeStack = [ModuleScope()]
    self.exceptHandlers = [()]
    self.futuresAllowed = True
    self.root = tree
    self.handleChildren(tree)
        # EKR: visit the children of the module node.
    self.runDeferred(self._deferredFunctions)
    # Set _deferredFunctions to None so that deferFunction will fail
    # noisily if called after we've run through the deferred functions.
    self._deferredFunctions = None
    self.runDeferred(self._deferredAssignments)
    # Set _deferredAssignments to None so that deferAssignment will fail
    # noisily if called after we've run through the deferred assignments.
    self._deferredAssignments = None
    del self.scopeStack[1:]
    self.popScope()
    self.checkDeadScopes()
</t>
<t tx="ekr.20160519172255.42">def deferFunction(self, callable):
    """
    Schedule a function handler to be called just before completion.

    This is used for handling function bodies, which must be deferred
    because code later in the file might modify the global scope. When
    `callable` is called, the scope at the time this is called will be
    restored, however it will contain any new bindings added to it.
    """
    self._deferredFunctions.append((callable, self.scopeStack[:], self.offset))
</t>
<t tx="ekr.20160519172255.43">def deferAssignment(self, callable):
    """
    Schedule an assignment handler to be called just after deferred
    function handlers.
    """
    self._deferredAssignments.append((callable, self.scopeStack[:], self.offset))
</t>
<t tx="ekr.20160519172255.44">def runDeferred(self, deferred):
    """
    Run the callables in C{deferred} using their associated scope stack.
    """
    for handler, scope, offset in deferred:
        self.scopeStack = scope
        self.offset = offset
        handler()
</t>
<t tx="ekr.20160519172255.45">@property
def scope(self):
    return self.scopeStack[-1]
</t>
<t tx="ekr.20160519172255.46">def popScope(self):
    self.deadScopes.append(self.scopeStack.pop())
</t>
<t tx="ekr.20160519172255.47">def checkDeadScopes(self):
    """
    Look at scopes which have been fully examined and report names in them
    which were imported but unused.
    """
    for scope in self.deadScopes:
        if isinstance(scope.get('__all__'), ExportBinding):
            all_names = set(scope['__all__'].names)
            if not scope.importStarred and \
               os.path.basename(self.filename) != '__init__.py':
                # Look for possible mistakes in the export list
                undefined = all_names.difference(scope)
                for name in undefined:
                    self.report(messages.UndefinedExport,
                                scope['__all__'].source, name)
        else:
            all_names = []

        # Look for imported names that aren't used.
        for value in scope.values():
            if isinstance(value, Importation):
                used = value.used or value.name in all_names
                if not used:
                    messg = messages.UnusedImport
                    self.report(messg, value.source, value.name)
                for node in value.redefined:
                    if isinstance(self.getParent(node), ast.For):
                        messg = messages.ImportShadowedByLoopVar
                    elif used:
                        continue
                    else:
                        messg = messages.RedefinedWhileUnused
                    self.report(messg, node, value.name, value.source)
</t>
<t tx="ekr.20160519172255.48">def pushScope(self, scopeClass=FunctionScope):
    self.scopeStack.append(scopeClass())
</t>
<t tx="ekr.20160519172255.49">def report(self, messageClass, *args, **kwargs):
    self.messages.append(messageClass(self.filename, *args, **kwargs))
</t>
<t tx="ekr.20160519172255.5">def checkPath(filename, reporter=None):
    """
    Check the given path, printing out any warnings detected.

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: the number of warnings printed
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    try:
        # in Python 2.6, compile() will choke on \r\n line endings. In later
        # versions of python it's smarter, and we want binary mode to give
        # compile() the best opportunity to do the right thing WRT text
        # encodings.
        if sys.version_info &lt; (2, 7):
            mode = 'rU'
        else:
            mode = 'rb'

        with open(filename, mode) as f:
            codestr = f.read()
        if sys.version_info &lt; (2, 7):
            codestr += '\n'     # Work around for Python &lt;= 2.6
    except UnicodeError:
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    except IOError:
        msg = sys.exc_info()[1]
        reporter.unexpectedError(filename, msg.args[1])
        return 1
    return check(codestr, filename, reporter)
</t>
<t tx="ekr.20160519172255.50">def getParent(self, node):
    # Lookup the first parent which is not Tuple, List or Starred
    # EKR: handleNode sets node.parent.
    while True:
        node = node.parent
        if not hasattr(node, 'elts') and not hasattr(node, 'ctx'):
            return node
</t>
<t tx="ekr.20160519172255.51">def getCommonAncestor(self, lnode, rnode, stop):
    if stop in (lnode, rnode) or not (hasattr(lnode, 'parent') and
                                      hasattr(rnode, 'parent')):
        return None
    if lnode is rnode:
        return lnode

    if (lnode.depth &gt; rnode.depth):
        return self.getCommonAncestor(lnode.parent, rnode, stop)
    if (lnode.depth &lt; rnode.depth):
        return self.getCommonAncestor(lnode, rnode.parent, stop)
    return self.getCommonAncestor(lnode.parent, rnode.parent, stop)
</t>
<t tx="ekr.20160519172255.52">def descendantOf(self, node, ancestors, stop):
    for a in ancestors:
        if self.getCommonAncestor(node, a, stop):
            return True
    return False
</t>
<t tx="ekr.20160519172255.53">def differentForks(self, lnode, rnode):
    """True, if lnode and rnode are located on different forks of IF/TRY"""
    ancestor = self.getCommonAncestor(lnode, rnode, self.root)
    parts = getAlternatives(ancestor)
    if parts:
        for items in parts:
            if self.descendantOf(lnode, items, ancestor) ^ \
               self.descendantOf(rnode, items, ancestor):
                return True
    return False
</t>
<t tx="ekr.20160519172255.54">def addBinding(self, node, value):
    """
    Called when a binding is altered.

    - `node` is the statement responsible for the change
    - `value` is the new value, a Binding instance
    """
    # assert value.source in (node, node.parent):
    for scope in self.scopeStack[::-1]:
        if value.name in scope:
            break
    existing = scope.get(value.name)

    if existing and not self.differentForks(node, existing.source):

        parent_stmt = self.getParent(value.source)
        if isinstance(existing, Importation) and isinstance(parent_stmt, ast.For):
            self.report(messages.ImportShadowedByLoopVar,
                        node, value.name, existing.source)

        elif scope is self.scope:
            if (isinstance(parent_stmt, ast.comprehension) and
                    not isinstance(self.getParent(existing.source),
                                   (ast.For, ast.comprehension))):
                self.report(messages.RedefinedInListComp,
                            node, value.name, existing.source)
            elif not existing.used and value.redefines(existing):
                self.report(messages.RedefinedWhileUnused,
                            node, value.name, existing.source)

        elif isinstance(existing, Importation) and value.redefines(existing):
            existing.redefined.append(node)

    if value.name in self.scope:
        # then assume the rebound name is used as a global or within a loop
        value.used = self.scope[value.name].used

    # g.trace(self.scope, value) # EKR
    self.scope[value.name] = value
</t>
<t tx="ekr.20160519172255.55">def getNodeHandler(self, node_class):
    try:
        return self._nodeHandlers[node_class]
    except KeyError:
        nodeType = getNodeType(node_class)
    self._nodeHandlers[node_class] = handler = getattr(self, nodeType)
    return handler
</t>
<t tx="ekr.20160519172255.56">def handleNodeLoad(self, node):
    name = getNodeName(node)
    if not name:
        return
    # try local scope
    try:
        self.scope[name].used = (self.scope, node)
    except KeyError:
        pass
    else:
        return

    scopes = [scope for scope in self.scopeStack[:-1]
              if isinstance(scope, (FunctionScope, ModuleScope, GeneratorScope))]
    if isinstance(self.scope, GeneratorScope) and scopes[-1] != self.scopeStack[-2]:
        scopes.append(self.scopeStack[-2])

    # try enclosing function scopes and global scope
    importStarred = self.scope.importStarred
    for scope in reversed(scopes):
        importStarred = importStarred or scope.importStarred
        try:
            scope[name].used = (self.scope, node)
        except KeyError:
            pass
        else:
            return

    # look in the built-ins
    if importStarred or name in self.builtIns:
        return
    if name == '__path__' and os.path.basename(self.filename) == '__init__.py':
        # the special name __path__ is valid only in packages
        return

    # protected with a NameError handler?
    if 'NameError' not in self.exceptHandlers[-1]:
        self.report(messages.UndefinedName, node, name)
</t>
<t tx="ekr.20160519172255.57">def handleNodeStore(self, node):
    name = getNodeName(node)
    if not name:
        return
    # if the name hasn't already been defined in the current scope
    if isinstance(self.scope, FunctionScope) and name not in self.scope:
        # for each function or module scope above us
        for scope in self.scopeStack[:-1]:
            if not isinstance(scope, (FunctionScope, ModuleScope)):
                continue
            # if the name was defined in that scope, and the name has
            # been accessed already in the current scope, and hasn't
            # been declared global
            used = name in scope and scope[name].used
            if used and used[0] is self.scope and name not in self.scope.globals:
                # then it's probably a mistake
                self.report(messages.UndefinedLocal,
                            scope[name].used[1], name, scope[name].source)
                break

    parent_stmt = self.getParent(node)
    if isinstance(parent_stmt, (ast.For, ast.comprehension)) or (
            parent_stmt != node.parent and
            not self.isLiteralTupleUnpacking(parent_stmt)):
        binding = Binding(name, node)
    elif name == '__all__' and isinstance(self.scope, ModuleScope):
        binding = ExportBinding(name, node.parent, self.scope)
    else:
        binding = Assignment(name, node)
    self.addBinding(node, binding)
</t>
<t tx="ekr.20160519172255.58">def handleNodeDelete(self, node):

    def on_conditional_branch():
        """
        Return `True` if node is part of a conditional body.
        """
        current = getattr(node, 'parent', None)
        while current:
            if isinstance(current, (ast.If, ast.While, ast.IfExp)):
                return True
            current = getattr(current, 'parent', None)
        return False

    name = getNodeName(node)
    if not name:
        return

    if on_conditional_branch():
        # We can not predict if this conditional branch is going to
        # be executed.
        return

    if isinstance(self.scope, FunctionScope) and name in self.scope.globals:
        self.scope.globals.remove(name)
    else:
        try:
            del self.scope[name]
        except KeyError:
            self.report(messages.UndefinedName, node, name)
</t>
<t tx="ekr.20160519172255.59">def handleChildren(self, tree, omit=None):
    for node in iter_child_nodes(tree, omit=omit):
        self.handleNode(node, tree)
</t>
<t tx="ekr.20160519172255.6">def iterSourceCode(paths):
    """
    Iterate over all Python source files in C{paths}.

    @param paths: A list of paths.  Directories will be recursed into and
        any .py files found will be yielded.  Any non-directories will be
        yielded as-is.
    """
    for path in paths:
        if os.path.isdir(path):
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    if filename.endswith('.py'):
                        yield os.path.join(dirpath, filename)
        else:
            yield path
</t>
<t tx="ekr.20160519172255.60">def isLiteralTupleUnpacking(self, node):
    if isinstance(node, ast.Assign):
        for child in node.targets + [node.value]:
            if not hasattr(child, 'elts'):
                return False
        return True
</t>
<t tx="ekr.20160519172255.61">def isDocstring(self, node):
    """
    Determine if the given node is a docstring, as long as it is at the
    correct place in the node tree.
    """
    return isinstance(node, ast.Str) or (isinstance(node, ast.Expr) and
                                         isinstance(node.value, ast.Str))
</t>
<t tx="ekr.20160519172255.62">def getDocstring(self, node):
    if isinstance(node, ast.Expr):
        node = node.value
    if not isinstance(node, ast.Str):
        return (None, None)
    # Computed incorrectly if the docstring has backslash
    doctest_lineno = node.lineno - node.s.count('\n') - 1
    return (node.s, doctest_lineno)
</t>
<t tx="ekr.20160519172255.63">def handleNode(self, node, parent):
    # EKR: this the general node visiter.
    if node is None:
        return
    if self.offset and getattr(node, 'lineno', None) is not None:
        node.lineno += self.offset[0]
        node.col_offset += self.offset[1]
    if self.traceTree:
        print('  ' * self.nodeDepth + node.__class__.__name__)
    if self.futuresAllowed and not (isinstance(node, ast.ImportFrom) or
                                    self.isDocstring(node)):
        self.futuresAllowed = False
    self.nodeDepth += 1
    node.depth = self.nodeDepth
    node.parent = parent
    try:
        # EKR: this is the only call to getNodeHandler.
        handler = self.getNodeHandler(node.__class__)
        handler(node)
    finally:
        self.nodeDepth -= 1
    if self.traceTree:
        print('  ' * self.nodeDepth + 'end ' + node.__class__.__name__)

_getDoctestExamples = doctest.DocTestParser().get_examples
</t>
<t tx="ekr.20160519172255.64">def handleDoctests(self, node):
    try:
        (docstring, node_lineno) = self.getDocstring(node.body[0])
        examples = docstring and self._getDoctestExamples(docstring)
    except (ValueError, IndexError):
        # e.g. line 6 of the docstring for &lt;string&gt; has inconsistent
        # leading whitespace: ...
        return
    if not examples:
        return
    node_offset = self.offset or (0, 0)
    self.pushScope()
    underscore_in_builtins = '_' in self.builtIns
    if not underscore_in_builtins:
        self.builtIns.add('_')
    for example in examples:
        try:
            tree = compile(example.source, "&lt;doctest&gt;", "exec", ast.PyCF_ONLY_AST)
        except SyntaxError:
            e = sys.exc_info()[1]
            position = (node_lineno + example.lineno + e.lineno,
                        example.indent + 4 + (e.offset or 0))
            self.report(messages.DoctestSyntaxError, node, position)
        else:
            self.offset = (node_offset[0] + node_lineno + example.lineno,
                           node_offset[1] + example.indent + 4)
            self.handleChildren(tree)
            self.offset = node_offset
    if not underscore_in_builtins:
        self.builtIns.remove('_')
    self.popScope()
</t>
<t tx="ekr.20160519172255.65">def ignore(self, node):
    pass
</t>
<t tx="ekr.20160519172255.66">def GLOBAL(self, node):
    """
    Keep track of globals declarations.
    """
    # In doctests, the global scope is an anonymous function at index 1.
    global_scope_index = 1 if self.withDoctest else 0
    global_scope = self.scopeStack[global_scope_index]

    # Ignore 'global' statement in global scope.
    if self.scope is not global_scope:

        # One 'global' statement can bind multiple (comma-delimited) names.
        for node_name in node.names:
            node_value = Assignment(node_name, node)

            # Remove UndefinedName messages already reported for this name.
            self.messages = [
                m for m in self.messages if not
                isinstance(m, messages.UndefinedName) and not
                m.message_args[0] == node_name]

            # Bind name to global scope if it doesn't exist already.
            global_scope.setdefault(node_name, node_value)

            # Bind name to non-global scopes, but as already "used".
            node_value.used = (global_scope, node)
            for scope in self.scopeStack[global_scope_index + 1:]:
                scope[node_name] = node_value

NONLOCAL = GLOBAL
</t>
<t tx="ekr.20160519172255.67">def GENERATOREXP(self, node):
    self.pushScope(GeneratorScope)
    self.handleChildren(node)
    self.popScope()

LISTCOMP = handleChildren if PY2 else GENERATOREXP

DICTCOMP = SETCOMP = GENERATOREXP
</t>
<t tx="ekr.20160519172255.68">def NAME(self, node):
    """
    Handle occurrence of Name (which can be a load/store/delete access.)
    """
    # Locate the name in locals / function / globals scopes.
    if isinstance(node.ctx, (ast.Load, ast.AugLoad)):
        self.handleNodeLoad(node)
        if (node.id == 'locals' and isinstance(self.scope, FunctionScope)
                and isinstance(node.parent, ast.Call)):
            # we are doing locals() call in current scope
            self.scope.usesLocals = True
    elif isinstance(node.ctx, (ast.Store, ast.AugStore)):
        self.handleNodeStore(node)
    elif isinstance(node.ctx, ast.Del):
        self.handleNodeDelete(node)
    else:
        # must be a Param context -- this only happens for names in function
        # arguments, but these aren't dispatched through here
        raise RuntimeError("Got impossible expression context: %r" % (node.ctx,))
</t>
<t tx="ekr.20160519172255.69">def RETURN(self, node):
    
    if isinstance(self.scope, ClassScope):
        self.report(messages.ReturnOutsideFunction, node)
        return
    if (
        node.value and
        hasattr(self.scope, 'returnValue') and
        not self.scope.returnValue
    ):
        self.scope.returnValue = node.value
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160519172255.7">def checkRecursive(paths, reporter):
    """
    Recursively check all source files in C{paths}.

    @param paths: A list of paths to Python source files and directories
        containing Python source files.
    @param reporter: A L{Reporter} where all of the warnings and errors
        will be reported to.
    @return: The number of warnings found.
    """
    warnings = 0
    for sourcePath in iterSourceCode(paths):
        warnings += checkPath(sourcePath, reporter)
    return warnings
</t>
<t tx="ekr.20160519172255.70">def YIELD(self, node):
    self.scope.isGenerator = True
    self.handleNode(node.value, node)

AWAIT = YIELDFROM = YIELD
</t>
<t tx="ekr.20160519172255.71">def FUNCTIONDEF(self, node):
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    self.LAMBDA(node)
    self.addBinding(node, FunctionDefinition(node.name, node))
    if self.withDoctest:
        self.deferFunction(lambda: self.handleDoctests(node))

ASYNCFUNCTIONDEF = FUNCTIONDEF
</t>
<t tx="ekr.20160519172255.72">def LAMBDA(self, node):
    args = []
    annotations = []

    if PY2:
        def addArgs(arglist):
            for arg in arglist:
                if isinstance(arg, ast.Tuple):
                    addArgs(arg.elts)
                else:
                    args.append(arg.id)
        addArgs(node.args.args)
        defaults = node.args.defaults
    else:
        for arg in node.args.args + node.args.kwonlyargs:
            args.append(arg.arg)
            annotations.append(arg.annotation)
        defaults = node.args.defaults + node.args.kw_defaults

    # Only for Python3 FunctionDefs
    is_py3_func = hasattr(node, 'returns')

    for arg_name in ('vararg', 'kwarg'):
        wildcard = getattr(node.args, arg_name)
        if not wildcard:
            continue
        args.append(wildcard if PY33 else wildcard.arg)
        if is_py3_func:
            if PY33:  # Python 2.5 to 3.3
                argannotation = arg_name + 'annotation'
                annotations.append(getattr(node.args, argannotation))
            else:     # Python &gt;= 3.4
                annotations.append(wildcard.annotation)

    if is_py3_func:
        annotations.append(node.returns)

    if len(set(args)) &lt; len(args):
        for (idx, arg) in enumerate(args):
            if arg in args[:idx]:
                self.report(messages.DuplicateArgument, node, arg)

    for child in annotations + defaults:
        if child:
            self.handleNode(child, node)

    def runFunction():

        self.pushScope()
        for name in args:
            self.addBinding(node, Argument(name, node))
        if isinstance(node.body, list):
            # case for FunctionDefs
            for stmt in node.body:
                self.handleNode(stmt, node)
        else:
            # case for Lambdas
            self.handleNode(node.body, node)

        def checkUnusedAssignments():
            """
            Check to see if any assignments have not been used.
            """
            for name, binding in self.scope.unusedAssignments():
                self.report(messages.UnusedVariable, binding.source, name)
        self.deferAssignment(checkUnusedAssignments)

        if PY32:
            def checkReturnWithArgumentInsideGenerator():
                """
                Check to see if there is any return statement with
                arguments but the function is a generator.
                """
                if self.scope.isGenerator and self.scope.returnValue:
                    self.report(messages.ReturnWithArgsInsideGenerator,
                                self.scope.returnValue)
            self.deferAssignment(checkReturnWithArgumentInsideGenerator)
        self.popScope()

    self.deferFunction(runFunction)
</t>
<t tx="ekr.20160519172255.73">def CLASSDEF(self, node):
    """
    Check names used in a class definition, including its decorators, base
    classes, and the body of its definition.  Additionally, add its name to
    the current scope.
    """
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    for baseNode in node.bases:
        self.handleNode(baseNode, node)
    if not PY2:
        for keywordNode in node.keywords:
            self.handleNode(keywordNode, node)
    self.pushScope(ClassScope)
    if self.withDoctest:
        self.deferFunction(lambda: self.handleDoctests(node))
    for stmt in node.body:
        self.handleNode(stmt, node)
    self.popScope()
    self.addBinding(node, ClassDefinition(node.name, node))
</t>
<t tx="ekr.20160519172255.74">def AUGASSIGN(self, node):
    self.handleNodeLoad(node.target)
    self.handleNode(node.value, node)
    self.handleNode(node.target, node)
</t>
<t tx="ekr.20160519172255.75">def IMPORT(self, node):
    for alias in node.names:
        name = alias.asname or alias.name
        importation = Importation(name, node)
        self.addBinding(node, importation)
</t>
<t tx="ekr.20160519172255.76">def IMPORTFROM(self, node):
    if node.module == '__future__':
        if not self.futuresAllowed:
            self.report(messages.LateFutureImport,
                        node, [n.name for n in node.names])
    else:
        self.futuresAllowed = False

    for alias in node.names:
        if alias.name == '*':
            self.scope.importStarred = True
            self.report(messages.ImportStarUsed, node, node.module)
            continue
        name = alias.asname or alias.name
        importation = Importation(name, node)
        if node.module == '__future__':
            importation.used = (self.scope, node)
        self.addBinding(node, importation)
</t>
<t tx="ekr.20160519172255.77">def TRY(self, node):
    handler_names = []
    # List the exception handlers
    for handler in node.handlers:
        if isinstance(handler.type, ast.Tuple):
            for exc_type in handler.type.elts:
                handler_names.append(getNodeName(exc_type))
        elif handler.type:
            handler_names.append(getNodeName(handler.type))
    # Memorize the except handlers and process the body
    self.exceptHandlers.append(handler_names)
    for child in node.body:
        self.handleNode(child, node)
    self.exceptHandlers.pop()
    # Process the other nodes: "except:", "else:", "finally:"
    self.handleChildren(node, omit='body')

TRYEXCEPT = TRY
</t>
<t tx="ekr.20160519172255.78">def EXCEPTHANDLER(self, node):
    # 3.x: in addition to handling children, we must handle the name of
    # the exception, which is not a Name node, but a simple string.
    if isinstance(node.name, str):
        self.handleNodeStore(node)
    self.handleChildren(node)
</t>
<t tx="ekr.20160519172255.79">"""
Provide the class Message and its subclasses.
"""

@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20160519172255.8">def _exitOnSignal(sigName, message):
    """Handles a signal with sys.exit.

    Some of these signals (SIGPIPE, for example) don't exist or are invalid on
    Windows. So, ignore errors that might arise.
    """
    import signal

    try:
        sigNumber = getattr(signal, sigName)
    except AttributeError:
        # the signal constants defined in the signal module are defined by
        # whether the C library supports them or not. So, SIGPIPE might not
        # even be defined.
        return

    def handler(sig, f):
        sys.exit(message)

    try:
        signal.signal(sigNumber, handler)
    except ValueError:
        # It's also possible the signal is defined, but then it's invalid. In
        # this case, signal.signal raises ValueError.
        pass
</t>
<t tx="ekr.20160519172255.80">class Message(object):
    message = ''
    message_args = ()

    @others
</t>
<t tx="ekr.20160519172255.81">def __init__(self, filename, loc):
    self.filename = filename
    self.lineno = loc.lineno
    self.col = getattr(loc, 'col_offset', 0)
</t>
<t tx="ekr.20160519172255.82">def __str__(self):
    return '%s:%s: %s' % (self.filename, self.lineno,
                          self.message % self.message_args)
</t>
<t tx="ekr.20160519172255.83">class UnusedImport(Message):
    message = '%r imported but unused'

    @others
</t>
<t tx="ekr.20160519172255.84">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.85">class RedefinedWhileUnused(Message):
    message = 'redefinition of unused %r from line %r'

    @others
</t>
<t tx="ekr.20160519172255.86">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.87">class RedefinedInListComp(Message):
    message = 'list comprehension redefines %r from line %r'

    @others
</t>
<t tx="ekr.20160519172255.88">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.89">class ImportShadowedByLoopVar(Message):
    message = 'import %r from line %r shadowed by loop variable'

    @others
</t>
<t tx="ekr.20160519172255.9">def main(prog=None):
    """Entry point for the script "pyflakes"."""
    import optparse

    # Handle "Keyboard Interrupt" and "Broken pipe" gracefully
    _exitOnSignal('SIGINT', '... stopped')
    _exitOnSignal('SIGPIPE', 1)

    parser = optparse.OptionParser(prog=prog, version=__version__)
    (__, args) = parser.parse_args()
    reporter = modReporter._makeDefaultReporter()
    if args:
        warnings = checkRecursive(args, reporter)
    else:
        warnings = check(sys.stdin.read(), '&lt;stdin&gt;', reporter)
    raise SystemExit(warnings &gt; 0)
</t>
<t tx="ekr.20160519172255.90">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.91">class ImportStarUsed(Message):
    message = "'from %s import *' used; unable to detect undefined names"

    @others
</t>
<t tx="ekr.20160519172255.92">def __init__(self, filename, loc, modname):
    Message.__init__(self, filename, loc)
    self.message_args = (modname,)
</t>
<t tx="ekr.20160519172255.93">class UndefinedName(Message):
    message = 'undefined name %r'

    @others
</t>
<t tx="ekr.20160519172255.94">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.95">class DoctestSyntaxError(Message):
    message = 'syntax error in doctest'

    @others
</t>
<t tx="ekr.20160519172255.96">def __init__(self, filename, loc, position=None):
    Message.__init__(self, filename, loc)
    if position:
        (self.lineno, self.col) = position
    self.message_args = ()
</t>
<t tx="ekr.20160519172255.97">class UndefinedExport(Message):
    message = 'undefined name %r in __all__'

    @others
</t>
<t tx="ekr.20160519172255.98">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.99">class UndefinedLocal(Message):
    message = ('local variable %r (defined in enclosing scope on line %r) '
               'referenced before assignment')

    @others
</t>
<t tx="ekr.20160519172710.1"></t>
<t tx="ekr.20160519172730.1"></t>
<t tx="ekr.20160519172836.1"># "stmt" type nodes
DELETE = PRINT = FOR = ASYNCFOR = WHILE = IF = WITH = WITHITEM = \
    ASYNCWITH = ASYNCWITHITEM = RAISE = TRYFINALLY = ASSERT = EXEC = \
    EXPR = ASSIGN = handleChildren

CONTINUE = BREAK = PASS = ignore

# "expr" type nodes
BOOLOP = BINOP = UNARYOP = IFEXP = DICT = SET = \
    COMPARE = CALL = REPR = ATTRIBUTE = SUBSCRIPT = LIST = TUPLE = \
    STARRED = NAMECONSTANT = handleChildren

NUM = STR = BYTES = ELLIPSIS = ignore

# "slice" type nodes
SLICE = EXTSLICE = INDEX = handleChildren

# expression contexts are node instances too, though being constants
LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore

# same for operators
AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \
    BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \
    EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = ignore

# additional node types
COMPREHENSION = KEYWORD = handleChildren</t>
<t tx="ekr.20160519172947.1"># flattened, word, ignore-case, head, body</t>
<t tx="ekr.20160519173152.1"># EKR: like visitors</t>
<t tx="ekr.20160519173318.1"></t>
<t tx="ekr.20160519173339.1"></t>
<t tx="ekr.20160519180137.1">http://epydoc.sourceforge.net/manual-epytext.html

Epytext defines four types of inline markup that specify how text should be displayed:
    
I{...}: Italicized text.
B{...}: Bold-faced text.
C{...}: Source code or a Python identifier.
M{...}: A mathematical expression.

Also seen:
    
L{...}: </t>
<t tx="ekr.20160519180953.1">if PY2:
    def getNodeType(node_class):
        # workaround str.upper() which is locale-dependent
        return str(unicode(node_class.__name__).upper())
else:
    def getNodeType(node_class):
        return node_class.__name__.upper()</t>
<t tx="ekr.20160519181035.1"># Python &gt;= 3.3 uses ast.Try instead of (ast.TryExcept + ast.TryFinally)
# EKR: used only by differentForks
if PY32:
    def getAlternatives(n):
        if isinstance(n, (ast.If, ast.TryFinally)):
            return [n.body]
        if isinstance(n, ast.TryExcept):
            return [n.body + n.orelse] + [[hdl] for hdl in n.handlers]
else:
    def getAlternatives(n):
        if isinstance(n, ast.If):
            return [n.body]
        if isinstance(n, ast.Try):
            return [n.body + n.orelse] + [[hdl] for hdl in n.handlers]</t>
<t tx="ekr.20160519181348.1"></t>
<t tx="ekr.20160519182919.1">


# handle iter before target, and generators before element
# fields = node_class._fields
fields = ['value', 'w', 'iter', 'z', 'x']

if 'iter' in fields:
    key_first = 'iter'.find
elif 'generators' in fields:
    key_first = 'generators'.find
else:
    key_first = 'value'.find

aList = tuple(sorted(fields, key=key_first, reverse=True))
print(aList)

print(['iter'.find(z) for z in fields])
</t>
<t tx="ekr.20160519185320.1"># flattened, word, ignore-case, head, body</t>
<t tx="ekr.20160520081237.1"># g.cls()
if c.isChanged():
    c.save()
&lt;&lt; test imports &gt;&gt;
&lt;&lt; define s &gt;&gt;
@others
gc.collect() # Stabalizes timing statistics a bit.
stats = {}
    # 4.8 to 5.0 sec for pyflakes 'all'
    # 2.2 sec for FullTraverser 'all'
run_test(scope='all', s=s)
</t>
<t tx="ekr.20160520081827.1">def run_test(scope, s):
    
    global stats
    g.trace('scope:', scope)
    g_option_fn = None
    if scope == 'test':
        files = []
    else:
        files = leoTest.LinterTable().get_files_for_scope(scope, fn=g_option_fn)
        s = None
    t1 = time.clock()
    check_all(files, s)
    t2 = time.clock()
    n = len(files)
    stats['total'] = t2 - t1
    print('%s file%s' % (n, g.plural(n)))
    if 1:
        for key in ('read', 'parse', 'visit', 'check', 'total'):
            print('%6s %5.2f sec' % (key, stats.get(key)))
</t>
<t tx="ekr.20160520082209.1">def check_all(files, s=None):
    '''Run pyflakes on all files.'''
    # from pyflakes import api, reporter
    if s:
        fn = '&lt;test string&gt;'
        check_string(fn, s)
    else:
        for fn in files:
            s = read_string(fn)
            if s and s.strip():
                tree = compile_string(fn, s)
                traverse_tree(tree)
                check_string(fn, s, tree=tree) # EKR: added tree
            else:
                print('can not read:', fn)
</t>
<t tx="ekr.20160520102401.1"></t>
<t tx="ekr.20160520160409.1">import ast
import gc
import imp
import sys
import time
import leo.core.leoGlobals as g
import leo.core.leoTest as leoTest
import api
import leo_ast
import checker
import messages
import reporter
imp.reload(api)
imp.reload(leo_ast)
imp.reload(checker)
imp.reload(messages)
imp.reload(reporter)
# g.trace(ast)
</t>
<t tx="ekr.20160520162336.1">def check_string(fn, s, tree):
    
    global stats
    t1 = time.clock()
    sfn = g.shortFileName(fn)
    r = reporter.Reporter(
        errorStream=sys.stderr,
        warningStream=sys.stderr,
        )
    errors = api.check(s, sfn, r, tree=tree)
    t2 = time.clock()
    stats['check'] = stats.get('check', 0.0) + t2 - t1
    if errors:
        print('pyflakes: %s error%s in %s' % (
            errors, g.plural(errors), fn))
</t>
<t tx="ekr.20160520162722.1">s = '''\

class TestClass:
    
    def spam():
        
        return n + 1
        
'''</t>
<t tx="ekr.20160520163049.1"></t>
<t tx="ekr.20160520163727.1"></t>
<t tx="ekr.20160520184945.1">'''AST (Abstract Syntax Tree) related classes.'''
import ast
import xml.sax.saxutils as saxutils
import textwrap
import token as token_module
import leo.core.leoGlobals as g
@others
@language python
@tabwidth -4
@pagewidth 70
</t>
<t tx="ekr.20160520184945.10">def do_types_list(self, attr, node, val):
    assert attr == 'typ'
    return '[%s]' % ','.join(
        [repr(z) for z in getattr(node, attr)])
</t>
<t tx="ekr.20160520184945.100"># BoolOp(boolop op, expr* values)

def do_BoolOp(self, node):
    for z in node.values:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.101">def do_Bytes(self, node):
    pass # Python 3.x only.
</t>
<t tx="ekr.20160520184945.102"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    # Call the nodes in token order.
    self.visit(node.func)
    for z in node.args:
        self.visit(z)
    for z in node.keywords:
        self.visit(z)
    if getattr(node, 'starargs', None):
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None):
        self.visit(node.kwargs)
</t>
<t tx="ekr.20160520184945.103"># Compare(expr left, cmpop* ops, expr* comparators)

def do_Compare(self, node):
    # Visit all nodes in token order.
    self.visit(node.left)
    assert len(node.ops) == len(node.comparators)
    for i in range(len(node.ops)):
        self.visit(node.ops[i])
        self.visit(node.comparators[i])
    # self.visit(node.left)
    # for z in node.comparators:
        # self.visit(z)
</t>
<t tx="ekr.20160520184945.104"># Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

def do_Eq(self, node): pass

def do_Gt(self, node): pass

def do_GtE(self, node): pass

def do_In(self, node): pass

def do_Is(self, node): pass

def do_IsNot(self, node): pass

def do_Lt(self, node): pass

def do_LtE(self, node): pass

def do_NotEq(self, node): pass

def do_NotIn(self, node): pass
</t>
<t tx="ekr.20160520184945.105"># comprehension (expr target, expr iter, expr* ifs)

def do_comprehension(self, node):
    self.visit(node.target) # A name.
    self.visit(node.iter) # An attribute.
    for z in node.ifs:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.106"># Dict(expr* keys, expr* values)

def do_Dict(self, node):
    # Visit all nodes in token order.
    assert len(node.keys) == len(node.values)
    for i in range(len(node.keys)):
        self.visit(node.keys[i])
        self.visit(node.values[i])
</t>
<t tx="ekr.20160520184945.107">def do_Ellipsis(self, node):
    pass
</t>
<t tx="ekr.20160520184945.108"># Expr(expr value)

def do_Expr(self, node):
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.109">def do_Expression(self, node):
    '''An inner expression'''
    self.visit(node.body)
</t>
<t tx="ekr.20160520184945.11">class AstFormatter(object):
    '''
    A class to recreate source code from an AST.

    This does not have to be perfect, but it should be close.

    Also supports optional annotations such as line numbers, file names, etc.
    '''
    # No ctor.
    # pylint: disable=consider-using-enumerate
    @others
</t>
<t tx="ekr.20160520184945.110">def do_ExtSlice(self, node):
    for z in node.dims:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.111"># GeneratorExp(expr elt, comprehension* generators)

def do_GeneratorExp(self, node):
    self.visit(node.elt)
    for z in node.generators:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.112"># IfExp(expr test, expr body, expr orelse)

def do_IfExp(self, node):
    self.visit(node.body)
    self.visit(node.test)
    self.visit(node.orelse)
</t>
<t tx="ekr.20160520184945.113">def do_Index(self, node):
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.114"># keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.115"># List(expr* elts, expr_context ctx)

def do_List(self, node):
    for z in node.elts:
        self.visit(z)
    # self.visit(node.ctx)
# ListComp(expr elt, comprehension* generators)

def do_ListComp(self, node):
    self.visit(node.elt)
    for z in node.generators:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.116"># Name(identifier id, expr_context ctx)

def do_Name(self, node):
    # self.visit(node.ctx)
    pass

def do_NameConstant(self, node): # Python 3 only.
    pass
    # s = repr(node.value)
    # return 'bool' if s in ('True', 'False') else s
</t>
<t tx="ekr.20160520184945.117">def do_Num(self, node):
    pass # Num(object n) # a number as a PyObject.
</t>
<t tx="ekr.20160520184945.118"># Python 2.x only
# Repr(expr value)

def do_Repr(self, node):
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.119">def do_Slice(self, node):
    if getattr(node, 'lower', None):
        self.visit(node.lower)
    if getattr(node, 'upper', None):
        self.visit(node.upper)
    if getattr(node, 'step', None):
        self.visit(node.step)
</t>
<t tx="ekr.20160520184945.12"></t>
<t tx="ekr.20160520184945.120">def do_Str(self, node):
    pass # represents a string constant.
</t>
<t tx="ekr.20160520184945.121"># Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    self.visit(node.value)
    self.visit(node.slice)
    # self.visit(node.ctx)
</t>
<t tx="ekr.20160520184945.122"># Tuple(expr* elts, expr_context ctx)

def do_Tuple(self, node):
    for z in node.elts:
        self.visit(z)
    # self.visit(node.ctx)
</t>
<t tx="ekr.20160520184945.123"># UnaryOp(unaryop op, expr operand)

def do_UnaryOp(self, node):
    # self.op_name(node.op)
    self.visit(node.operand)
</t>
<t tx="ekr.20160520184945.124"></t>
<t tx="ekr.20160520184945.125"># identifier name, identifier? asname)

def do_alias(self, node):
    # self.visit(node.name)
    # if getattr(node,'asname')
        # self.visit(node.asname)
    pass
</t>
<t tx="ekr.20160520184945.126"># Assert(expr test, expr? msg)

def do_Assert(self, node):
    self.visit(node.test)
    if node.msg:
        self.visit(node.msg)
</t>
<t tx="ekr.20160520184945.127"># Assign(expr* targets, expr value)

def do_Assign(self, node):
    for z in node.targets:
        self.visit(z)
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.128"># AugAssign(expr target, operator op, expr value)

def do_AugAssign(self, node):
    # g.trace('FT',Utils().format(node),g.callers())
    self.visit(node.target)
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.129">def do_Break(self, tree):
    pass
</t>
<t tx="ekr.20160520184945.13"># def __call__(self,node):
    # '''__call__ method for AstFormatter class.'''
    # return self.format(node)
</t>
<t tx="ekr.20160520184945.130">def do_Continue(self, tree):
    pass
</t>
<t tx="ekr.20160520184945.131"># Delete(expr* targets)

def do_Delete(self, node):
    for z in node.targets:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.132"># Python 2: ExceptHandler(expr? type, expr? name, stmt* body)
# Python 3: ExceptHandler(expr? type, identifier? name, stmt* body)

def do_ExceptHandler(self, node):
    if node.type:
        self.visit(node.type)
    if node.name and isinstance(node.name, ast.Name):
        self.visit(node.name)
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.133"># Python 2.x only
# Exec(expr body, expr? globals, expr? locals)

def do_Exec(self, node):
    self.visit(node.body)
    if getattr(node, 'globals', None):
        self.visit(node.globals)
    if getattr(node, 'locals', None):
        self.visit(node.locals)
</t>
<t tx="ekr.20160520184945.134"># For(expr target, expr iter, stmt* body, stmt* orelse)

def do_For(self, node):
    self.visit(node.target)
    self.visit(node.iter)
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.135"># Global(identifier* names)

def do_Global(self, node):
    pass
</t>
<t tx="ekr.20160520184945.136"># If(expr test, stmt* body, stmt* orelse)

def do_If(self, node):
    self.visit(node.test)
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.137"># Import(alias* names)

def do_Import(self, node):
    pass
# ImportFrom(identifier? module, alias* names, int? level)

def do_ImportFrom(self, node):
    # for z in node.names:
        # self.visit(z)
    pass
</t>
<t tx="ekr.20160520184945.138"># Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    pass
</t>
<t tx="ekr.20160520184945.139">def do_Pass(self, node):
    pass
</t>
<t tx="ekr.20160520184945.14">def format(self, node):
    '''Format the node (or list of nodes) and its descendants.'''
    self.level = 0
    val = self.visit(node)
    return val and val.strip() or ''
</t>
<t tx="ekr.20160520184945.140"># Python 2.x only
# Print(expr? dest, expr* values, bool nl)

def do_Print(self, node):
    if getattr(node, 'dest', None):
        self.visit(node.dest)
    for expr in node.values:
        self.visit(expr)
</t>
<t tx="ekr.20160520184945.141"># Raise(expr? type, expr? inst, expr? tback)

def do_Raise(self, node):
    if getattr(node, 'type', None):
        self.visit(node.type)
    if getattr(node, 'inst', None):
        self.visit(node.inst)
    if getattr(node, 'tback', None):
        self.visit(node.tback)
</t>
<t tx="ekr.20160520184945.142"># Return(expr? value)

def do_Return(self, node):
    if node.value:
        self.visit(node.value)
</t>
<t tx="ekr.20160520184945.143"># Starred(expr value, expr_context ctx)

def do_Starred(self, node):

    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.144"># Python 3 only: Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.handlers:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
    for z in node.finalbody:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.145"># TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)

def do_TryExcept(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.handlers:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.146"># TryFinally(stmt* body, stmt* finalbody)

def do_TryFinally(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.finalbody:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.147"># While(expr test, stmt* body, stmt* orelse)

def do_While(self, node):
    self.visit(node.test) # Bug fix: 2013/03/23.
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.148"># 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node):
    if getattr(node, 'context_expr', None):
        self.visit(node.context_expr)
    if getattr(node, 'optional_vars', None):
        self.visit(node.optional_vars)
    if getattr(node, 'items', None): # Python 3.
        for item in node.items:
            self.visit(item.context_expr)
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars:
                        self.visit(z)
                except TypeError: # Not iterable.
                    self.visit(item.optional_vars)
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.149">#  Yield(expr? value)

def do_Yield(self, node):
    if node.value:
        self.visit(node.value)
</t>
<t tx="ekr.20160520184945.15">def visit(self, node):
    '''Return the formatted version of an Ast node, or list of Ast nodes.'''
    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])
    elif node is None:
        return 'None'
    else:
        assert isinstance(node, ast.AST), node.__class__.__name__
        method_name = 'do_' + node.__class__.__name__
        method = getattr(self, method_name)
        s = method(node)
        assert g.isString(s), type(s)
        return s
</t>
<t tx="ekr.20160520184945.150"># YieldFrom(expr value)

def do_YieldFrom(self, node):

    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.151">def visit(self, node):
    '''Visit a *single* ast node.  Visitors are responsible for visiting children!'''
    assert isinstance(node, ast.AST), node.__class__.__name__
    trace = False
    # Visit the children with the new parent.
    old_parent = self.parent
    self.parent = node # Bug fix: 2016/05/18.
    class_name = node.__class__.__name__
    # A tiny bit faster
    method = self.d.get(class_name) or self.get_visitor(class_name)
    # method_name = 'do_' + node.__class__.__name__
    # method = getattr(self, method_name)
    # if trace: g.trace(class_name)
    val = method(node)
    self.parent = old_parent
    return val
    
def do_nothing(self, node):
    pass
    
def get_visitor(self, class_name):
    '''Compute the method and put it in self.d.'''
    method_name = 'do_' + class_name
    if hasattr(self, method_name):
        # g.trace(method_name)
        method = getattr(self, method_name)
    else:
        g.trace('no visitor for', class_name)
        method = self.do_nothing
    self.d[class_name] = method
    assert method
    return method

def visit_children(self, node):
    assert False, 'must visit children explicitly'
</t>
<t tx="ekr.20160520184945.152">def visit_list(self, aList):
    '''Visit all ast nodes in aList.'''
    assert isinstance(aList, (list, tuple)), repr(aList)
    for z in aList:
        self.visit(z)
    return None
</t>
<t tx="ekr.20160520184945.153">class AstPatternFormatter(AstFormatter):
    '''
    A subclass of AstFormatter that replaces values of constants by Bool,
    Bytes, Int, Name, Num or Str.
    '''
    # No ctor.
    @others
</t>
<t tx="ekr.20160520184945.154"># Return generic markers allow better pattern matches.

def do_BoolOp(self, node): # Python 2.x only.
    return 'Bool'

def do_Bytes(self, node): # Python 3.x only.
    return 'Bytes' # return str(node.s)

def do_Name(self, node):
    return 'Bool' if node.id in ('True', 'False') else node.id
    
def do_NameConstant(self, node): # Python 3 only.
    s = repr(node.value)
    return 'bool' if s in ('True', 'False') else s

def do_Num(self, node):
    return 'Num' # return repr(node.n)

def do_Str(self, node):
    '''This represents a string constant.'''
    return 'Str' # return repr(node.s)
</t>
<t tx="ekr.20160520184945.16"></t>
<t tx="ekr.20160520184945.17"># 2: ClassDef(identifier name, expr* bases,
#             stmt* body, expr* decorator_list)
# 3: ClassDef(identifier name, expr* bases,
#             keyword* keywords, expr? starargs, expr? kwargs
#             stmt* body, expr* decorator_list)
#
# keyword arguments supplied to call (NULL identifier for **kwargs)
# keyword = (identifier? arg, expr value)

def do_ClassDef(self, node):

    result = []
    name = node.name # Only a plain string is valid.
    bases = [self.visit(z) for z in node.bases] if node.bases else []
    if getattr(node, 'keywords', None): # Python 3
        for keyword in node.keywords:
            bases.append('%s=%s' % (keyword.arg, self.visit(keyword.value)))
    if getattr(node, 'starargs', None): # Python 3
        bases.append('*%s', self.visit(node.starargs))
    if getattr(node, 'kwargs', None): # Python 3
        bases.append('*%s', self.visit(node.kwargs))
    if bases:
        result.append(self.indent('class %s(%s):\n' % (name, ','.join(bases))))
    else:
        result.append(self.indent('class %s:\n' % name))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.18"># 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node):
    '''Format a FunctionDef node.'''
    result = []
    if node.decorator_list:
        for z in node.decorator_list:
            result.append('@%s\n' % self.visit(z))
    name = node.name # Only a plain string is valid.
    args = self.visit(node.args) if node.args else ''
    if getattr(node, 'returns', None): # Python 3.
        returns = self.visit(node.returns)
        result.append(self.indent('def %s(%s): -&gt; %s\n' % (name, args, returns)))
    else:
        result.append(self.indent('def %s(%s):\n' % (name, args)))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.19">def do_Interactive(self, node):
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.2">class AstDumper(object):
    '''
    Return a formatted dump (a string) of the AST node.

    Adapted from Python's ast.dump.

    annotate_fields:    True: show names of fields (can't eval the dump).
    disabled_field:     List of names of fields not to show: e.g. ['ctx',]
    include_attributes: True: show line numbers and column offsets.
    indent:             Number of spaces for each indent.
    '''
    @others
</t>
<t tx="ekr.20160520184945.20">def do_Module(self, node):
    assert 'body' in node._fields
    result = ''.join([self.visit(z) for z in node.body])
    return result # 'module:\n%s' % (result)
</t>
<t tx="ekr.20160520184945.21">def do_Lambda(self, node):
    return self.indent('lambda %s: %s' % (
        self.visit(node.args),
        self.visit(node.body)))
</t>
<t tx="ekr.20160520184945.22"></t>
<t tx="ekr.20160520184945.23">def do_Expr(self, node):
    '''An outer expression: must be indented.'''
    return self.indent('%s\n' % self.visit(node.value))
</t>
<t tx="ekr.20160520184945.24">def do_Expression(self, node):
    '''An inner expression: do not indent.'''
    return '%s\n' % self.visit(node.body)
</t>
<t tx="ekr.20160520184945.25">def do_GeneratorExp(self, node):
    elt = self.visit(node.elt) or ''
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] # Kludge: probable bug.
    return '&lt;gen %s for %s&gt;' % (elt, ','.join(gens))
</t>
<t tx="ekr.20160520184945.252">class TokenSync(object):
    '''A class to sync and remember tokens.'''
    # To do: handle comments, line breaks...
    @others
</t>
<t tx="ekr.20160520184945.253">def __init__(self, s, tokens):
    '''Ctor for TokenSync class.'''
    assert isinstance(tokens, list) # Not a generator.
    self.s = s
    self.first_leading_line = None
    self.lines = [z.rstrip() for z in g.splitLines(s)]
    # Order is important from here on...
    self.nl_token = self.make_nl_token()
    self.line_tokens = self.make_line_tokens(tokens)
    self.blank_lines = self.make_blank_lines()
    self.string_tokens = self.make_string_tokens()
    self.ignored_lines = self.make_ignored_lines()
</t>
<t tx="ekr.20160520184945.254">def make_blank_lines(self):
    '''Return of list of line numbers of blank lines.'''
    result = []
    for i, aList in enumerate(self.line_tokens):
        # if any([self.token_kind(z) == 'nl' for z in aList]):
        if len(aList) == 1 and self.token_kind(aList[0]) == 'nl':
            result.append(i)
    return result
</t>
<t tx="ekr.20160520184945.255">def make_ignored_lines(self):
    '''
    Return a copy of line_tokens containing ignored lines,
    that is, full-line comments or blank lines.
    These are the lines returned by leading_lines().
    '''
    result = []
    for i, aList in enumerate(self.line_tokens):
        for z in aList:
            if self.is_line_comment(z):
                result.append(z)
                break
        else:
            if i in self.blank_lines:
                result.append(self.nl_token)
            else:
                result.append(None)
    assert len(result) == len(self.line_tokens)
    for i, aList in enumerate(result):
        if aList:
            self.first_leading_line = i
            break
    else:
        self.first_leading_line = len(result)
    return result
</t>
<t tx="ekr.20160520184945.256">def make_line_tokens(self, tokens):
    '''
    Return a list of lists of tokens for each list in self.lines.
    The strings in self.lines may end in a backslash, so care is needed.
    '''
    trace = False
    n, result = len(self.lines), []
    for i in range(0, n + 1):
        result.append([])
    for token in tokens:
        t1, t2, t3, t4, t5 = token
        kind = token_module.tok_name[t1].lower()
        srow, scol = t3
        erow, ecol = t4
        line = erow - 1 if kind == 'string' else srow - 1
        result[line].append(token)
        if trace: g.trace('%3s %s' % (line, self.dump_token(token)))
    assert len(self.lines) + 1 == len(result), len(result)
    return result
</t>
<t tx="ekr.20160520184945.257">def make_nl_token(self):
    '''Return a newline token with '\n' as both val and raw_val.'''
    t1 = token_module.NEWLINE
    t2 = '\n'
    t3 = (0, 0) # Not used.
    t4 = (0, 0) # Not used.
    t5 = '\n'
    return t1, t2, t3, t4, t5
</t>
<t tx="ekr.20160520184945.258">def make_string_tokens(self):
    '''Return a copy of line_tokens containing only string tokens.'''
    result = []
    for aList in self.line_tokens:
        result.append([z for z in aList if self.token_kind(z) == 'string'])
    assert len(result) == len(self.line_tokens)
    return result
</t>
<t tx="ekr.20160520184945.259">def check_strings(self):
    '''Check that all strings have been consumed.'''
    # g.trace(len(self.string_tokens))
    for i, aList in enumerate(self.string_tokens):
        if aList:
            g.trace('warning: line %s. unused strings: %s' % (i, aList))
</t>
<t tx="ekr.20160520184945.26">def do_AugLoad(self, node):
    return 'AugLoad'

def do_Del(self, node):
    return 'Del'

def do_Load(self, node):
    return 'Load'

def do_Param(self, node):
    return 'Param'

def do_Store(self, node):
    return 'Store'
</t>
<t tx="ekr.20160520184945.260">def dump_token(self, token, verbose=False):
    '''Dump the token. It is either a string or a 5-tuple.'''
    if g.isString(token):
        return token
    else:
        t1, t2, t3, t4, t5 = token
        kind = g.toUnicode(token_module.tok_name[t1].lower())
        # raw_val = g.toUnicode(t5)
        val = g.toUnicode(t2)
        if verbose:
            return 'token: %10s %r' % (kind, val)
        else:
            return val
</t>
<t tx="ekr.20160520184945.261">def is_line_comment(self, token):
    '''Return True if the token represents a full-line comment.'''
    t1, t2, t3, t4, t5 = token
    kind = token_module.tok_name[t1].lower()
    raw_val = t5
    return kind == 'comment' and raw_val.lstrip().startswith('#')
</t>
<t tx="ekr.20160520184945.262">def join(self, aList, sep=','):
    '''return the items of the list joined by sep string.'''
    tokens = []
    for i, token in enumerate(aList or []):
        tokens.append(token)
        if i &lt; len(aList) - 1:
            tokens.append(sep)
    return tokens
</t>
<t tx="ekr.20160520184945.263">def last_node(self, node):
    '''Return the node of node's tree with the largest lineno field.'''

    class LineWalker(ast.NodeVisitor):

        def __init__(self):
            '''Ctor for LineWalker class.'''
            self.node = None
            self.lineno = -1

        def visit(self, node):
            '''LineWalker.visit.'''
            if hasattr(node, 'lineno'):
                if node.lineno &gt; self.lineno:
                    self.lineno = node.lineno
                    self.node = node
            if isinstance(node, list):
                for z in node:
                    self.visit(z)
            else:
                self.generic_visit(node)

    w = LineWalker()
    w.visit(node)
    return w.node
</t>
<t tx="ekr.20160520184945.264">def leading_lines(self, node):
    '''Return a list of the preceding comment and blank lines'''
    # This can be called on arbitrary nodes.
    trace = False
    leading = []
    if hasattr(node, 'lineno'):
        i, n = self.first_leading_line, node.lineno
        while i &lt; n:
            token = self.ignored_lines[i]
            if token:
                s = self.token_raw_val(token).rstrip() + '\n'
                leading.append(s)
                if trace: g.trace('%11s: %s' % (i, s.rstrip()))
            i += 1
        self.first_leading_line = i
    return leading
</t>
<t tx="ekr.20160520184945.265">def leading_string(self, node):
    '''Return a string containing all lines preceding node.'''
    return ''.join(self.leading_lines(node))
</t>
<t tx="ekr.20160520184945.266">def line_at(self, node, continued_lines=True):
    '''Return the lines at the node, possibly including continuation lines.'''
    n = getattr(node, 'lineno', None)
    if n is None:
        return '&lt;no line&gt; for %s' % node.__class__.__name__
    elif continued_lines:
        aList, n = [], n - 1
        while n &lt; len(self.lines):
            s = self.lines[n]
            if s.endswith('\\'):
                aList.append(s[: -1])
                n += 1
            else:
                aList.append(s)
                break
        return ''.join(aList)
    else:
        return self.lines[n - 1]
</t>
<t tx="ekr.20160520184945.267">def sync_string(self, node):
    '''Return the spelling of the string at the given node.'''
    # g.trace('%-10s %2s: %s' % (' ', node.lineno, self.line_at(node)))
    n = node.lineno
    tokens = self.string_tokens[n - 1]
    if tokens:
        token = tokens.pop(0)
        self.string_tokens[n - 1] = tokens
        return self.token_val(token)
    else:
        g.trace('===== underflow', n, node.s)
        return node.s
</t>
<t tx="ekr.20160520184945.268">def token_kind(self, token):
    '''Return the token's type.'''
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(token_module.tok_name[t1].lower())

def token_raw_val(self, token):
    '''Return the value of the token.'''
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(t5)

def token_val(self, token):
    '''Return the raw value of the token.'''
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(t2)
</t>
<t tx="ekr.20160520184945.269">def tokens_for_statement(self, node):
    assert isinstance(node, ast.AST), node
    name = node.__class__.__name__
    if hasattr(node, 'lineno'):
        tokens = self.line_tokens[node.lineno - 1]
        g.trace(' '.join([self.dump_token(z) for z in tokens]))
    else:
        g.trace('no lineno', name)
</t>
<t tx="ekr.20160520184945.27"></t>
<t tx="ekr.20160520184945.270">def trailing_comment(self, node):
    '''
    Return a string containing the trailing comment for the node, if any.
    The string always ends with a newline.
    '''
    if hasattr(node, 'lineno'):
        return self.trailing_comment_at_lineno(node.lineno)
    else:
        g.trace('no lineno', node.__class__.__name__, g.callers())
        return '\n'
</t>
<t tx="ekr.20160520184945.271">def trailing_comment_at_lineno(self, lineno):
    '''Return any trailing comment at the given node.lineno.'''
    trace = False
    tokens = self.line_tokens[lineno - 1]
    for token in tokens:
        if self.token_kind(token) == 'comment':
            raw_val = self.token_raw_val(token).rstrip()
            if not raw_val.strip().startswith('#'):
                val = self.token_val(token).rstrip()
                s = ' %s\n' % val
                if trace: g.trace(lineno, s.rstrip(), g.callers())
                return s
    return '\n'
</t>
<t tx="ekr.20160520184945.272">def trailing_lines(self):
    '''return any remaining ignored lines.'''
    trace = False
    trailing = []
    i = self.first_leading_line
    while i &lt; len(self.ignored_lines):
        token = self.ignored_lines[i]
        if token:
            s = self.token_raw_val(token).rstrip() + '\n'
            trailing.append(s)
            if trace: g.trace('%11s: %s' % (i, s.rstrip()))
        i += 1
    self.first_leading_line = i
    return trailing
</t>
<t tx="ekr.20160520184945.28"># 2: arguments = (expr* args, identifier? vararg, identifier?
#                arg? kwarg, expr* defaults)
# 3: arguments = (arg*  args, arg? vararg,
#                arg* kwonlyargs, expr* kw_defaults,
#                arg? kwarg, expr* defaults)

def do_arguments(self, node):
    '''Format the arguments node.'''
    kind = self.kind(node)
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    args2 = []
    n_plain = len(args) - len(defaults)
    for i in range(len(args)):
        if i &lt; n_plain:
            args2.append(args[i])
        else:
            args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
    if g.isPython3:
        args  = [self.visit(z) for z in node.kwonlyargs]
        defaults = [self.visit(z) for z in node.kw_defaults]
        n_plain = len(args) - len(defaults)
        for i in range(len(args)):
            if i &lt; n_plain:
                args2.append(args[i])
            else:
                args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
        # Add the vararg and kwarg expressions.
        vararg = getattr(node, 'vararg', None)
        if vararg: args2.append('*' + self.visit(vararg))
        kwarg = getattr(node, 'kwarg', None)
        if kwarg: args2.append('**' + self.visit(kwarg))
    else:
        # Add the vararg and kwarg names.
        name = getattr(node, 'vararg', None)
        if name: args2.append('*' + name)
        name = getattr(node, 'kwarg', None)
        if name: args2.append('**' + name)
    return ','.join(args2)
</t>
<t tx="ekr.20160520184945.29"># 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if getattr(node, 'annotation', None):
        return self.visit(node.annotation)
    else:
        return ''
</t>
<t tx="ekr.20160520184945.3">def __init__(self, u, annotate_fields, disabled_fields, format, include_attributes, indent_ws):
    '''Ctor for AstDumper class.'''
    self.u = u
    self.annotate_fields = annotate_fields
    self.disabled_fields = disabled_fields
    self.format = format
    self.include_attributes = include_attributes
    self.indent_ws = indent_ws
</t>
<t tx="ekr.20160520184945.30"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    return '%s.%s' % (
        self.visit(node.value),
        node.attr) # Don't visit node.attr: it is always a string.
</t>
<t tx="ekr.20160520184945.31">def do_Bytes(self, node): # Python 3.x only.
    assert g.isPython3
    return str(node.s)
</t>
<t tx="ekr.20160520184945.32"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    # g.trace(node,Utils().dump_ast(node))
    func = self.visit(node.func)
    args = [self.visit(z) for z in node.args]
    for z in node.keywords:
        # Calls f.do_keyword.
        args.append(self.visit(z))
    if getattr(node, 'starargs', None):
        args.append('*%s' % (self.visit(node.starargs)))
    if getattr(node, 'kwargs', None):
        args.append('**%s' % (self.visit(node.kwargs)))
    args = [z for z in args if z] # Kludge: Defensive coding.
    return '%s(%s)' % (func, ','.join(args))
</t>
<t tx="ekr.20160520184945.33"># keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    value = self.visit(node.value)
    # This is a keyword *arg*, not a Python keyword!
    return '%s=%s' % (node.arg, value)
</t>
<t tx="ekr.20160520184945.34">def do_comprehension(self, node):
    result = []
    name = self.visit(node.target) # A name.
    it = self.visit(node.iter) # An attribute.
    result.append('%s in %s' % (name, it))
    ifs = [self.visit(z) for z in node.ifs]
    if ifs:
        result.append(' if %s' % (''.join(ifs)))
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.35">def do_Dict(self, node):
    result = []
    keys = [self.visit(z) for z in node.keys]
    values = [self.visit(z) for z in node.values]
    if len(keys) == len(values):
        result.append('{\n' if keys else '{')
        items = []
        for i in range(len(keys)):
            items.append('  %s:%s' % (keys[i], values[i]))
        result.append(',\n'.join(items))
        result.append('\n}' if keys else '}')
    else:
        print('Error: f.Dict: len(keys) != len(values)\nkeys: %s\nvals: %s' % (
            repr(keys), repr(values)))
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.36">def do_Ellipsis(self, node):
    return '...'
</t>
<t tx="ekr.20160520184945.37">def do_ExtSlice(self, node):
    return ':'.join([self.visit(z) for z in node.dims])
</t>
<t tx="ekr.20160520184945.38">def do_Index(self, node):
    return self.visit(node.value)
</t>
<t tx="ekr.20160520184945.39">def do_List(self, node):
    # Not used: list context.
    # self.visit(node.ctx)
    elts = [self.visit(z) for z in node.elts]
    elts = [z for z in elts if z] # Defensive.
    return '[%s]' % ','.join(elts)
</t>
<t tx="ekr.20160520184945.4">def dump(self, node, level=0):
    sep1 = '\n%s' % (self.indent_ws * (level + 1))
    if isinstance(node, ast.AST):
        fields = [(a, self.dump(b, level + 1)) for a, b in self.get_fields(node)]
            # ast.iter_fields(node)]
        if self.include_attributes and node._attributes:
            fields.extend([(a, self.dump(getattr(node, a), level + 1))
                for a in node._attributes])
        # Not used at present.
        # aList = self.extra_attributes(node)
        # if aList: fields.extend(aList)
        if self.annotate_fields:
            aList = ['%s=%s' % (a, b) for a, b in fields]
        else:
            aList = [b for a, b in fields]
        compressed = not any([isinstance(b, list) and len(b) &gt; 1 for a, b in fields])
        name = node.__class__.__name__
        if compressed and len(','.join(aList)) &lt; 100:
            return '%s(%s)' % (name, ','.join(aList))
        else:
            sep = '' if len(aList) &lt;= 1 else sep1
            return '%s(%s%s)' % (name, sep, sep1.join(aList))
    elif isinstance(node, list):
        compressed = not any([isinstance(z, list) and len(z) &gt; 1 for z in node])
        sep = '' if compressed and len(node) &lt;= 1 else sep1
        return '[%s]' % ''.join(
            ['%s%s' % (sep, self.dump(z, level + 1)) for z in node])
    else:
        return repr(node)
</t>
<t tx="ekr.20160520184945.40">def do_ListComp(self, node):
    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] # Kludge: probable bug.
    return '%s for %s' % (elt, ''.join(gens))
</t>
<t tx="ekr.20160520184945.41">def do_Name(self, node):
    return node.id

def do_NameConstant(self, node): # Python 3 only.
    s = repr(node.value)
    return 'bool' if s in ('True', 'False') else s
</t>
<t tx="ekr.20160520184945.42">def do_Num(self, node):
    return repr(node.n)
</t>
<t tx="ekr.20160520184945.43"># Python 2.x only

def do_Repr(self, node):
    return 'repr(%s)' % self.visit(node.value)
</t>
<t tx="ekr.20160520184945.44">def do_Slice(self, node):
    lower, upper, step = '', '', ''
    if getattr(node, 'lower', None) is not None:
        lower = self.visit(node.lower)
    if getattr(node, 'upper', None) is not None:
        upper = self.visit(node.upper)
    if getattr(node, 'step', None) is not None:
        step = self.visit(node.step)
    if step:
        return '%s:%s:%s' % (lower, upper, step)
    else:
        return '%s:%s' % (lower, upper)
</t>
<t tx="ekr.20160520184945.45">def do_Str(self, node):
    '''This represents a string constant.'''
    return repr(node.s)
</t>
<t tx="ekr.20160520184945.46"># Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    value = self.visit(node.value)
    the_slice = self.visit(node.slice)
    return '%s[%s]' % (value, the_slice)
</t>
<t tx="ekr.20160520184945.47">def do_Tuple(self, node):
    elts = [self.visit(z) for z in node.elts]
    return '(%s)' % ','.join(elts)
</t>
<t tx="ekr.20160520184945.48"></t>
<t tx="ekr.20160520184945.49">def do_BinOp(self, node):
    return '%s%s%s' % (
        self.visit(node.left),
        self.op_name(node.op),
        self.visit(node.right))
</t>
<t tx="ekr.20160520184945.5">def get_fields(self, node):
    fields = [z for z in ast.iter_fields(node)]
    result = []
    for a, b in fields:
        if a not in self.disabled_fields:
            if b not in (None, []):
                result.append((a, b),)
    return result
</t>
<t tx="ekr.20160520184945.50">def do_BoolOp(self, node):
    op_name = self.op_name(node.op)
    values = [self.visit(z) for z in node.values]
    return op_name.join(values)
</t>
<t tx="ekr.20160520184945.51">def do_Compare(self, node):
    result = []
    lt = self.visit(node.left)
    # ops   = [self.visit(z) for z in node.ops]
    ops = [self.op_name(z) for z in node.ops]
    comps = [self.visit(z) for z in node.comparators]
    result.append(lt)
    if len(ops) == len(comps):
        for i in range(len(ops)):
            result.append('%s%s' % (ops[i], comps[i]))
    else:
        g.trace('ops', repr(ops), 'comparators', repr(comps))
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.52">def do_UnaryOp(self, node):
    return '%s%s' % (
        self.op_name(node.op),
        self.visit(node.operand))
</t>
<t tx="ekr.20160520184945.53">def do_IfExp(self, node):
    return '%s if %s else %s ' % (
        self.visit(node.body),
        self.visit(node.test),
        self.visit(node.orelse))
</t>
<t tx="ekr.20160520184945.54"></t>
<t tx="ekr.20160520184945.55">def do_Assert(self, node):
    test = self.visit(node.test)
    if getattr(node, 'msg', None):
        message = self.visit(node.msg)
        return self.indent('assert %s, %s' % (test, message))
    else:
        return self.indent('assert %s' % test)
</t>
<t tx="ekr.20160520184945.56">def do_Assign(self, node):
    return self.indent('%s=%s\n' % (
        '='.join([self.visit(z) for z in node.targets]),
        self.visit(node.value)))
</t>
<t tx="ekr.20160520184945.57">def do_AugAssign(self, node):
    return self.indent('%s%s=%s\n' % (
        self.visit(node.target),
        self.op_name(node.op), # Bug fix: 2013/03/08.
        self.visit(node.value)))
</t>
<t tx="ekr.20160520184945.58">def do_Break(self, node):
    return self.indent('break\n')
</t>
<t tx="ekr.20160520184945.59">def do_Continue(self, node):
    return self.indent('continue\n')
</t>
<t tx="ekr.20160520184945.6">def extra_attributes(self, node):
    '''Return the tuple (field,repr(field)) for all extra fields.'''
    d = {
        # 'e': self.do_repr,
        # 'cache':self.do_cache_list,
        # 'reach':self.do_reaching_list,
        # 'typ':  self.do_types_list,
    }
    aList = []
    for attr in sorted(d.keys()):
        if hasattr(node, attr):
            val = getattr(node, attr)
            f = d.get(attr)
            s = f(attr, node, val)
            if s:
                aList.append((attr, s),)
    return aList
</t>
<t tx="ekr.20160520184945.60">def do_Delete(self, node):
    targets = [self.visit(z) for z in node.targets]
    return self.indent('del %s\n' % ','.join(targets))
</t>
<t tx="ekr.20160520184945.61">def do_ExceptHandler(self, node):
    result = []
    result.append(self.indent('except'))
    if getattr(node, 'type', None):
        result.append(' %s' % self.visit(node.type))
    if getattr(node, 'name', None):
        if isinstance(node.name, ast.AST):
            result.append(' as %s' % self.visit(node.name))
        else:
            result.append(' as %s' % node.name) # Python 3.x.
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.62"># Python 2.x only

def do_Exec(self, node):
    body = self.visit(node.body)
    args = [] # Globals before locals.
    if getattr(node, 'globals', None):
        args.append(self.visit(node.globals))
    if getattr(node, 'locals', None):
        args.append(self.visit(node.locals))
    if args:
        return self.indent('exec %s in %s\n' % (
            body, ','.join(args)))
    else:
        return self.indent('exec %s\n' % (body))
</t>
<t tx="ekr.20160520184945.63">def do_For(self, node):
    result = []
    result.append(self.indent('for %s in %s:\n' % (
        self.visit(node.target),
        self.visit(node.iter))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.64">def do_Global(self, node):
    return self.indent('global %s\n' % (
        ','.join(node.names)))
</t>
<t tx="ekr.20160520184945.65">def do_If(self, node):
    result = []
    result.append(self.indent('if %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.66">def do_Import(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('import %s\n' % (
        ','.join(names)))
</t>
<t tx="ekr.20160520184945.67">def get_import_names(self, node):
    '''Return a list of the the full file names in the import statement.'''
    result = []
    for ast2 in node.names:
        if self.kind(ast2) == 'alias':
            data = ast2.name, ast2.asname
            result.append(data)
        else:
            g.trace('unsupported kind in Import.names list', self.kind(ast2))
    return result
</t>
<t tx="ekr.20160520184945.68">def do_ImportFrom(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('from %s import %s\n' % (
        node.module,
        ','.join(names)))
</t>
<t tx="ekr.20160520184945.69"># Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    return self.indent('nonlocal %s\n' % ', '.join(node.names))
</t>
<t tx="ekr.20160520184945.7">def do_cache_list(self, attr, node, val):
    return self.u.dump_cache(node)
</t>
<t tx="ekr.20160520184945.70">def do_Pass(self, node):
    return self.indent('pass\n')
</t>
<t tx="ekr.20160520184945.71"># Python 2.x only

def do_Print(self, node):
    vals = []
    for z in node.values:
        vals.append(self.visit(z))
    if getattr(node, 'dest', None):
        vals.append('dest=%s' % self.visit(node.dest))
    if getattr(node, 'nl', None):
        # vals.append('nl=%s' % self.visit(node.nl))
        vals.append('nl=%s' % node.nl)
    return self.indent('print(%s)\n' % (
        ','.join(vals)))
</t>
<t tx="ekr.20160520184945.72">def do_Raise(self, node):
    args = []
    for attr in ('type', 'inst', 'tback'):
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    if args:
        return self.indent('raise %s\n' % (
            ','.join(args)))
    else:
        return self.indent('raise\n')
</t>
<t tx="ekr.20160520184945.73">def do_Return(self, node):
    if node.value:
        return self.indent('return %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('return\n')
</t>
<t tx="ekr.20160520184945.74"># Starred(expr value, expr_context ctx)

def do_Starred(self, node):

    return '*' + self.visit(node.value)
</t>
<t tx="ekr.20160520184945.75"># def do_Suite(self,node):
    # for z in node.body:
        # s = self.visit(z)
</t>
<t tx="ekr.20160520184945.76"># Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node): # Python 3

    result = []
    self.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    if node.finalbody:
        result.append(self.indent('finally:\n'))
        for z in node.finalbody:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.77">def do_TryExcept(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.78">def do_TryFinally(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append(self.indent('finally:\n'))
    for z in node.finalbody:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.79">def do_While(self, node):
    result = []
    result.append(self.indent('while %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.8">def do_reaching_list(self, attr, node, val):
    assert attr == 'reach'
    return '[%s]' % ','.join(
        [self.format(z).strip() or repr(z)
            for z in getattr(node, attr)])
</t>
<t tx="ekr.20160520184945.80"># 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node):
    result = []
    result.append(self.indent('with '))
    if getattr(node, 'context_expression', None):
        result.append(self.visit(node.context_expresssion))
    vars_list = []
    if getattr(node, 'optional_vars', None):
        try:
            for z in node.optional_vars:
                vars_list.append(self.visit(z))
        except TypeError: # Not iterable.
            vars_list.append(self.visit(node.optional_vars))
    if getattr(node, 'items', None): # Python 3.
        for item in node.items:
            result.append(self.visit(item.context_expr))
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars:
                        vars_list.append(self.visit(z))
                except TypeError: # Not iterable.
                    vars_list.append(self.visit(item.optional_vars))
    result.append(','.join(vars_list))
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append('\n')
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.81">def do_Yield(self, node):
    if getattr(node, 'value', None):
        return self.indent('yield %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('yield\n')
</t>
<t tx="ekr.20160520184945.82"># YieldFrom(expr value)

def do_YieldFrom(self, node):

    return self.indent('yield from %s\n' % (
        self.visit(node.value)))
</t>
<t tx="ekr.20160520184945.83"></t>
<t tx="ekr.20160520184945.84">def kind(self, node):
    '''Return the name of node's class.'''
    return node.__class__.__name__
</t>
<t tx="ekr.20160520184945.85">def indent(self, s):
    return '%s%s' % (' ' * 4 * self.level, s)
</t>
<t tx="ekr.20160520184945.86">@nobeautify

def op_name (self,node,strict=True):
    '''Return the print name of an operator node.'''
    d = {
        # Binary operators.
        'Add':       '+',
        'BitAnd':    '&amp;',
        'BitOr':     '|',
        'BitXor':    '^',
        'Div':       '/',
        'FloorDiv':  '//',
        'LShift':    '&lt;&lt;',
        'Mod':       '%',
        'Mult':      '*',
        'Pow':       '**',
        'RShift':    '&gt;&gt;',
        'Sub':       '-',
        # Boolean operators.
        'And':   ' and ',
        'Or':    ' or ',
        # Comparison operators
        'Eq':    '==',
        'Gt':    '&gt;',
        'GtE':   '&gt;=',
        'In':    ' in ',
        'Is':    ' is ',
        'IsNot': ' is not ',
        'Lt':    '&lt;',
        'LtE':   '&lt;=',
        'NotEq': '!=',
        'NotIn': ' not in ',
        # Context operators.
        'AugLoad':  '&lt;AugLoad&gt;',
        'AugStore': '&lt;AugStore&gt;',
        'Del':      '&lt;Del&gt;',
        'Load':     '&lt;Load&gt;',
        'Param':    '&lt;Param&gt;',
        'Store':    '&lt;Store&gt;',
        # Unary operators.
        'Invert':   '~',
        'Not':      ' not ',
        'UAdd':     '+',
        'USub':     '-',
    }
    name = d.get(self.kind(node),'&lt;%s&gt;' % node.__class__.__name__)
    if strict: assert name,self.kind(node)
    return name
</t>
<t tx="ekr.20160520184945.87">class AstFullTraverser(object):
    '''
    A fast traverser for AST trees: it visits every node (except node.ctx fields).

    Sets .context and .parent ivars before visiting each node.
    '''

    def __init__(self):
        '''Ctor for AstFullTraverser class.'''
        self.context = None
        self.d = {} # Keys are node.__class__ strings. Values are methods.
        self.parent = None
        self.trace = False
    @others
</t>
<t tx="ekr.20160520184945.88"></t>
<t tx="ekr.20160520184945.89"># 2: ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
# 3: ClassDef(identifier name, expr* bases,
#             keyword* keywords, expr? starargs, expr? kwargs
#             stmt* body, expr* decorator_list)
#
# keyword arguments supplied to call (NULL identifier for **kwargs)
# keyword = (identifier? arg, expr value)

def do_ClassDef(self, node):
    old_context = self.context
    self.context = node
    for z in node.bases:
        self.visit(z)
    if getattr(node, 'keywords', None): # Python 3
        for keyword in node.keywords:
            self.visit(keyword.value)
    if getattr(node, 'starargs', None): # Python 3
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None): # Python 3
        self.visit(node.kwargs)
    for z in node.body:
        self.visit(z)
    for z in node.decorator_list:
        self.visit(z)
    self.context = old_context
</t>
<t tx="ekr.20160520184945.9">def do_repr(self, attr, node, val):
    return repr(val)
</t>
<t tx="ekr.20160520184945.90"># 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node):

    old_context = self.context
    self.context = node
    # Visit the tree in token order.
    for z in node.decorator_list:
        self.visit(z)
    assert g.isString(node.name)
    self.visit(node.args)
    if getattr(node, 'returns', None): # Python 3.
        self.visit(node.returns)
    for z in node.body:
        self.visit(z)
    self.context = old_context
</t>
<t tx="ekr.20160520184945.91">def do_Interactive(self, node):
    assert False, 'Interactive context not supported'
</t>
<t tx="ekr.20160520184945.92"># Lambda(arguments args, expr body)

def do_Lambda(self, node):
    old_context = self.context
    self.context = node
    self.visit(node.args)
    self.visit(node.body)
    self.context = old_context
</t>
<t tx="ekr.20160520184945.93">def do_Module(self, node):
    self.context = node
    for z in node.body:
        self.visit(z)
    self.context = None
</t>
<t tx="ekr.20160520184945.94"># Not used in this class, but may be called by subclasses.

def do_AugLoad(self, node):
    pass

def do_Del(self, node):
    pass

def do_Load(self, node):
    pass

def do_Param(self, node):
    pass

def do_Store(self, node):
    pass
</t>
<t tx="ekr.20160520184945.95">def kind(self, node):
    return node.__class__.__name__
</t>
<t tx="ekr.20160520184945.96"></t>
<t tx="ekr.20160520184945.97"># 2: arguments = (expr* args, identifier? vararg,
#                 identifier? kwarg, expr* defaults)
# 3: arguments = (arg*  args, arg? vararg,
#                 arg* kwonlyargs, expr* kw_defaults,
#                 arg? kwarg, expr* defaults)

def do_arguments(self, node):

    for z in node.args:
        self.visit(z)
    if g.isPython3 and getattr(node, 'vararg', None):
        # An identifier in Python 2.
        self.visit(node.vararg)
    if getattr(node, 'kwonlyargs', None): # Python 3.
        self.visit_list(node.kwonlyargs)
    if getattr(node, 'kw_defaults', None): # Python 3.
        self.visit_list(node.kw_defaults)
    if g.isPython3 and getattr(node, 'kwarg', None):
        # An identifier in Python 2.
        self.visit(node.kwarg)
    for z in node.defaults:
        self.visit(z)

# 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if getattr(node, 'annotation', None):
        self.visit(node.annotation)
</t>
<t tx="ekr.20160520184945.98"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    self.visit(node.value)
    # self.visit(node.ctx)
</t>
<t tx="ekr.20160520184945.99"># BinOp(expr left, operator op, expr right)

def do_BinOp(self, node):
    self.visit(node.left)
    # self.op_name(node.op)
    self.visit(node.right)
</t>
<t tx="ekr.20160520195402.1"># flattened, word, ignore-case, head, body</t>
<t tx="ekr.20160520210256.1">def read_string(fn):
    
    global stats
    t1 = time.clock()
    s = g.readFileIntoEncodedString(fn, silent=False)
    t2 = time.clock()
    stats['read'] = stats.get('read', 0.0) + t2 - t1
    return s
</t>
<t tx="ekr.20160520210414.1">def compile_string(fn, s):
    
    global stats
    t1 = time.clock()
    tree = None
    try:
        tree = compile(s, fn, "exec", ast.PyCF_ONLY_AST)
    except SyntaxError:
        g.es_print('syntax error')
        g.es_print_exception()
    except Exception:
        g.es_print('unexpected exception')
        g.es_print_exception() # EKR
    t2 = time.clock()
    stats['parse'] = stats.get('parse', 0.0) + t2 - t1
    return tree
</t>
<t tx="ekr.20160520210931.1">def traverse_tree(tree):

    global stats
    t1 = time.clock()
    leo_ast.AstFullTraverser().visit(tree)
    t2 = time.clock()
    stats['visit'] = stats.get('visit', 0.0) + t2 - t1</t>
</tnodes>
</leo_file>
