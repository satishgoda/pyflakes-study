<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20160523175246.1"><vh>Startup</vh>
<v t="ekr.20160523175246.2"><vh>@settings</vh>
<v t="ekr.20160523175246.3"><vh>@data history-list</vh></v>
<v t="ekr.20160523175246.5"><vh>@bool preload-find-pattern = False</vh></v>
</v>
<v t="ekr.20160523175246.6"><vh>Scripts</vh>
<v t="ekr.20160523175246.7"><vh>@@button write-unit-tests</vh>
<v t="ekr.20160523175246.8"><vh>&lt;&lt; docstring &gt;&gt; (write-unit-tests)</vh></v>
<v t="ekr.20160523175246.9"><vh>class TestWriter</vh>
<v t="ekr.20160523175246.10"><vh>&lt;&lt; define file_template &gt;&gt;</vh></v>
<v t="ekr.20160523175246.11"><vh>&lt;&lt; define test_template &gt;&gt;</vh></v>
<v t="ekr.20160523175246.12"><vh> ctor</vh></v>
<v t="ekr.20160523175246.13"><vh>clean</vh></v>
<v t="ekr.20160523175246.14"><vh>get_body</vh></v>
<v t="ekr.20160523175246.15"><vh>run</vh></v>
<v t="ekr.20160523175246.16"><vh>plural</vh></v>
<v t="ekr.20160523175246.17"><vh>test</vh></v>
<v t="ekr.20160523175246.18"><vh>write_file</vh></v>
</v>
</v>
<v t="ekr.20160523175246.19"><vh>@button check-leading-lines</vh></v>
</v>
<v t="ekr.20160523175246.20"><vh>Unused</vh>
<v t="ekr.20160523175246.21"><vh>@@test run all msf unit tests</vh></v>
<v t="ekr.20160523175246.22"><vh>from st.Call (failed experiment)</vh></v>
<v t="ekr.20160523175246.23"><vh>sf.match</vh></v>
<v t="ekr.20160523175246.24"><vh>sf.visit (attempts all matches on all nodes)</vh></v>
<v t="ekr.20160523175246.25"><vh>recent type-reduction stuff</vh>
<v t="ekr.20160523175246.26"><vh>unused code from is_known_type</vh></v>
<v t="ekr.20160523175246.27"><vh>unused code from rt.reduce_unknowns</vh></v>
<v t="ekr.20160523175246.28"><vh>recent, obsolete reduce_types code</vh></v>
</v>
<v t="ekr.20160523175246.29"><vh>rt.make_optional</vh></v>
</v>
</v>
<v t="ekr.20160523065519.1"><vh>Attic</vh>
<v t="ekr.20160523070015.1"><vh>Old jit code</vh></v>
<v t="ekr.20160523065801.1"><vh>OLD (jit) Checker.getNodeHandler</vh></v>
<v t="ekr.20160522070940.1"><vh>Checker.nodeDepth (EKR)</vh></v>
<v t="ekr.20160525071459.1"><vh>Binding.dump (EKR)</vh></v>
<v t="ekr.20160525070614.1"><vh>Scope.dump (EKR)</vh></v>
<v t="ekr.20160521023529.1"><vh>class NullChecker</vh>
<v t="ekr.20160521024555.1"><vh>NullChecker.getNodeHandler</vh></v>
<v t="ekr.20160521023730.2"><vh>NullChecker.handleChildren</vh></v>
<v t="ekr.20160521023730.4"><vh>NullChecker.handleNode</vh></v>
<v t="ekr.20160521024930.1"><vh>NullChcker.handlers</vh></v>
<v t="ekr.20160521154847.1"><vh>NullChecker.unused handlers</vh>
<v t="ekr.20160521024930.2"><vh>NullChecker.GLOBAL &amp; NONLOCAL</vh></v>
<v t="ekr.20160521024930.3"><vh>NullChecker.GENERATOREXP &amp; comprehensions</vh></v>
<v t="ekr.20160521024930.4"><vh>NullChecker.NAME</vh></v>
<v t="ekr.20160521024930.5"><vh>NullChecker.RETURN</vh></v>
<v t="ekr.20160521024930.6"><vh>NullChecker.YIELD</vh></v>
<v t="ekr.20160521024930.7"><vh>NullChecker.FUNCTIONDEF</vh></v>
<v t="ekr.20160521024930.8"><vh>NullChecker.LAMBDA</vh></v>
<v t="ekr.20160521024930.9"><vh>NullChecker.CLASSDEF</vh></v>
<v t="ekr.20160521024930.10"><vh>NullChecker.AUGASSIGN</vh></v>
<v t="ekr.20160521024930.11"><vh>NullChecker.IMPORT</vh></v>
<v t="ekr.20160521024930.12"><vh>NullChecker.IMPORTFROM</vh></v>
<v t="ekr.20160521024930.13"><vh>NullChecker.TRY</vh></v>
<v t="ekr.20160521024930.14"><vh>NullChecker.EXCEPTHANDLER</vh></v>
</v>
</v>
</v>
<v t="ekr.20160520102401.1"><vh>Reference</vh>
<v t="ekr.20160519172255.117"><vh>@@clean __init__.py</vh></v>
<v t="ekr.20160519172255.119"><vh>@@clean __main__.py</vh>
<v t="ekr.20160519172255.120"><vh>&lt;&lt;declarations&gt;&gt; (__main__)</vh></v>
</v>
<v t="ekr.20160519172255.2"><vh>@clean api.py</vh>
<v t="ekr.20160519172255.3"><vh>&lt;&lt;declarations&gt;&gt; (api)</vh></v>
<v t="ekr.20160519172255.4"><vh>api.check</vh></v>
<v t="ekr.20160519172255.5"><vh>api.checkPath</vh></v>
<v t="ekr.20160519172255.6"><vh>api.iterSourceCode</vh></v>
<v t="ekr.20160519172255.7"><vh>api.checkRecursive</vh></v>
<v t="ekr.20160519172255.8"><vh>api._exitOnSignal</vh></v>
<v t="ekr.20160519172255.9"><vh>api.main</vh></v>
</v>
<v t="ekr.20160520184945.1"><vh>@clean leo_ast.py</vh>
<v t="ekr.20160520184945.2"><vh>class AstDumper</vh>
<v t="ekr.20160520184945.3"><vh>d.ctor</vh></v>
<v t="ekr.20160520184945.4"><vh>d.dump</vh></v>
<v t="ekr.20160520184945.5"><vh>d.get_fields</vh></v>
<v t="ekr.20160520184945.6"><vh>d.extra_attributes &amp; helpers (not used)</vh>
<v t="ekr.20160520184945.7"><vh>d.do_cache_list</vh></v>
<v t="ekr.20160520184945.8"><vh>d.do_reaching_list</vh></v>
<v t="ekr.20160520184945.9"><vh>d.do_repr</vh></v>
<v t="ekr.20160520184945.10"><vh>d.do_types_list</vh></v>
</v>
</v>
<v t="ekr.20160520184945.11"><vh>class AstFormatter</vh>
<v t="ekr.20160520184945.12"><vh> f.Entries</vh>
<v t="ekr.20160520184945.13"><vh>f.__call__ (not used)</vh></v>
<v t="ekr.20160520184945.14"><vh>f.format</vh></v>
<v t="ekr.20160520184945.15"><vh>f.visit</vh></v>
</v>
<v t="ekr.20160520184945.16"><vh>f.Contexts</vh>
<v t="ekr.20160520184945.17"><vh>f.ClassDef</vh></v>
<v t="ekr.20160520184945.18"><vh>f.FunctionDef</vh></v>
<v t="ekr.20160520184945.19"><vh>f.Interactive</vh></v>
<v t="ekr.20160520184945.20"><vh>f.Module</vh></v>
<v t="ekr.20160520184945.21"><vh>f.Lambda</vh></v>
</v>
<v t="ekr.20160520184945.22"><vh>f.Expressions</vh>
<v t="ekr.20160520184945.23"><vh>f.Expr</vh></v>
<v t="ekr.20160520184945.24"><vh>f.Expression</vh></v>
<v t="ekr.20160520184945.25"><vh>f.GeneratorExp</vh></v>
<v t="ekr.20160520184945.26"><vh>f.ctx nodes</vh></v>
</v>
<v t="ekr.20160520184945.27"><vh>f.Operands</vh>
<v t="ekr.20160520184945.28"><vh>f.arguments</vh></v>
<v t="ekr.20160520184945.29"><vh>f.arg (Python3 only)</vh></v>
<v t="ekr.20160520184945.30"><vh>f.Attribute</vh></v>
<v t="ekr.20160520184945.31"><vh>f.Bytes</vh></v>
<v t="ekr.20160520184945.32"><vh>f.Call &amp; f.keyword</vh>
<v t="ekr.20160520184945.33"><vh>f.keyword</vh></v>
</v>
<v t="ekr.20160520184945.34"><vh>f.comprehension</vh></v>
<v t="ekr.20160520184945.35"><vh>f.Dict</vh></v>
<v t="ekr.20160520184945.36"><vh>f.Ellipsis</vh></v>
<v t="ekr.20160520184945.37"><vh>f.ExtSlice</vh></v>
<v t="ekr.20160520184945.38"><vh>f.Index</vh></v>
<v t="ekr.20160520184945.39"><vh>f.List</vh></v>
<v t="ekr.20160520184945.40"><vh>f.ListComp</vh></v>
<v t="ekr.20160520184945.41"><vh>f.Name</vh></v>
<v t="ekr.20160520184945.42"><vh>f.Num</vh></v>
<v t="ekr.20160520184945.43"><vh>f.Repr</vh></v>
<v t="ekr.20160520184945.44"><vh>f.Slice</vh></v>
<v t="ekr.20160520184945.45"><vh>f.Str</vh></v>
<v t="ekr.20160520184945.46"><vh>f.Subscript</vh></v>
<v t="ekr.20160520184945.47"><vh>f.Tuple</vh></v>
</v>
<v t="ekr.20160520184945.48"><vh>f.Operators</vh>
<v t="ekr.20160520184945.49"><vh>f.BinOp</vh></v>
<v t="ekr.20160520184945.50"><vh>f.BoolOp</vh></v>
<v t="ekr.20160520184945.51"><vh>f.Compare</vh></v>
<v t="ekr.20160520184945.52"><vh>f.UnaryOp</vh></v>
<v t="ekr.20160520184945.53"><vh>f.ifExp (ternary operator)</vh></v>
</v>
<v t="ekr.20160520184945.54"><vh>f.Statements</vh>
<v t="ekr.20160520184945.55"><vh>f.Assert</vh></v>
<v t="ekr.20160520184945.56"><vh>f.Assign</vh></v>
<v t="ekr.20160520184945.57"><vh>f.AugAssign</vh></v>
<v t="ekr.20160520184945.58"><vh>f.Break</vh></v>
<v t="ekr.20160520184945.59"><vh>f.Continue</vh></v>
<v t="ekr.20160520184945.60"><vh>f.Delete</vh></v>
<v t="ekr.20160520184945.61"><vh>f.ExceptHandler</vh></v>
<v t="ekr.20160520184945.62"><vh>f.Exec</vh></v>
<v t="ekr.20160520184945.63"><vh>f.For</vh></v>
<v t="ekr.20160520184945.64"><vh>f.Global</vh></v>
<v t="ekr.20160520184945.65"><vh>f.If</vh></v>
<v t="ekr.20160520184945.66"><vh>f.Import &amp; helper</vh>
<v t="ekr.20160520184945.67"><vh>f.get_import_names</vh></v>
</v>
<v t="ekr.20160520184945.68"><vh>f.ImportFrom</vh></v>
<v t="ekr.20160520184945.69"><vh>f.Nonlocal (Python 3)</vh></v>
<v t="ekr.20160520184945.70"><vh>f.Pass</vh></v>
<v t="ekr.20160520184945.71"><vh>f.Print</vh></v>
<v t="ekr.20160520184945.72"><vh>f.Raise</vh></v>
<v t="ekr.20160520184945.73"><vh>f.Return</vh></v>
<v t="ekr.20160520184945.74"><vh>f.Starred (Python 3)</vh></v>
<v t="ekr.20160520184945.75"><vh>f.Suite</vh></v>
<v t="ekr.20160520184945.76"><vh>f.Try (Python 3)</vh></v>
<v t="ekr.20160520184945.77"><vh>f.TryExcept</vh></v>
<v t="ekr.20160520184945.78"><vh>f.TryFinally</vh></v>
<v t="ekr.20160520184945.79"><vh>f.While</vh></v>
<v t="ekr.20160520184945.80"><vh>f.With</vh></v>
<v t="ekr.20160520184945.81"><vh>f.Yield</vh></v>
<v t="ekr.20160520184945.82"><vh>f.YieldFrom (Python 3)</vh></v>
</v>
<v t="ekr.20160520184945.83"><vh>f.Utils</vh>
<v t="ekr.20160520184945.84"><vh>f.kind</vh></v>
<v t="ekr.20160520184945.85"><vh>f.indent</vh></v>
<v t="ekr.20160520184945.86"><vh>f.op_name</vh></v>
</v>
</v>
<v t="ekr.20160520184945.87"><vh>class AstFullTraverser</vh>
<v t="ekr.20160520184945.88"><vh>ft.contexts</vh>
<v t="ekr.20160520184945.89"><vh>ft.ClassDef</vh></v>
<v t="ekr.20160520184945.90"><vh>ft.FunctionDef</vh></v>
<v t="ekr.20160520184945.91"><vh>ft.Interactive</vh></v>
<v t="ekr.20160520184945.92"><vh>ft.Lambda</vh></v>
<v t="ekr.20160520184945.93"><vh>ft.Module</vh></v>
</v>
<v t="ekr.20160520184945.94"><vh>ft.ctx nodes</vh></v>
<v t="ekr.20160520184945.95"><vh>ft.kind</vh></v>
<v t="ekr.20160520184945.96"><vh>ft.operators &amp; operands</vh>
<v t="ekr.20160520184945.97"><vh>ft.arguments &amp; arg</vh></v>
<v t="ekr.20160520184945.98"><vh>ft.Attribute</vh></v>
<v t="ekr.20160520184945.99"><vh>ft.BinOp</vh></v>
<v t="ekr.20160520184945.100"><vh>ft.BoolOp</vh></v>
<v t="ekr.20160520184945.101"><vh>ft.Bytes</vh></v>
<v t="ekr.20160520184945.102"><vh>ft.Call</vh></v>
<v t="ekr.20160520184945.103"><vh>ft.Compare</vh></v>
<v t="ekr.20160520184945.104"><vh>ft.Compare ops</vh></v>
<v t="ekr.20160520184945.105"><vh>ft.comprehension</vh></v>
<v t="ekr.20160520184945.106"><vh>ft.Dict</vh></v>
<v t="ekr.20160520184945.107"><vh>ft.Ellipsis</vh></v>
<v t="ekr.20160520184945.108"><vh>ft.Expr</vh></v>
<v t="ekr.20160520184945.109"><vh>ft.Expression</vh></v>
<v t="ekr.20160520184945.110"><vh>ft.ExtSlice</vh></v>
<v t="ekr.20160520184945.111"><vh>ft.GeneratorExp</vh></v>
<v t="ekr.20160520184945.112"><vh>ft.ifExp (ternary operator)</vh></v>
<v t="ekr.20160520184945.113"><vh>ft.Index</vh></v>
<v t="ekr.20160520184945.114"><vh>ft.keyword</vh></v>
<v t="ekr.20160520184945.115"><vh>ft.List &amp; ListComp</vh></v>
<v t="ekr.20160520184945.116"><vh>ft.Name (revise) &amp; NameConstant</vh></v>
<v t="ekr.20160520184945.117"><vh>ft.Num</vh></v>
<v t="ekr.20160520184945.118"><vh>ft.Repr</vh></v>
<v t="ekr.20160520184945.119"><vh>ft.Slice</vh></v>
<v t="ekr.20160520184945.120"><vh>ft.Str</vh></v>
<v t="ekr.20160520184945.121"><vh>ft.Subscript</vh></v>
<v t="ekr.20160520184945.122"><vh>ft.Tuple</vh></v>
<v t="ekr.20160520184945.123"><vh>ft.UnaryOp</vh></v>
</v>
<v t="ekr.20160520184945.124"><vh>ft.statements</vh>
<v t="ekr.20160520184945.125"><vh>ft.alias</vh></v>
<v t="ekr.20160520184945.126"><vh>ft.Assert</vh></v>
<v t="ekr.20160520184945.127"><vh>ft.Assign</vh></v>
<v t="ekr.20160520184945.128"><vh>ft.AugAssign</vh></v>
<v t="ekr.20160520184945.129"><vh>ft.Break</vh></v>
<v t="ekr.20160520184945.130"><vh>ft.Continue</vh></v>
<v t="ekr.20160520184945.131"><vh>ft.Delete</vh></v>
<v t="ekr.20160520184945.132"><vh>ft.ExceptHandler</vh></v>
<v t="ekr.20160520184945.133"><vh>ft.Exec</vh></v>
<v t="ekr.20160520184945.134"><vh>ft.For</vh></v>
<v t="ekr.20160520184945.135"><vh>ft.Global</vh></v>
<v t="ekr.20160520184945.136"><vh>ft.If</vh></v>
<v t="ekr.20160520184945.137"><vh>ft.Import &amp; ImportFrom</vh></v>
<v t="ekr.20160520184945.138"><vh>ft.Nonlocal (Python 3)</vh></v>
<v t="ekr.20160520184945.139"><vh>ft.Pass</vh></v>
<v t="ekr.20160520184945.140"><vh>ft.Print</vh></v>
<v t="ekr.20160520184945.141"><vh>ft.Raise</vh></v>
<v t="ekr.20160520184945.142"><vh>ft.Return</vh></v>
<v t="ekr.20160520184945.143"><vh>ft.Starred (Python 3)</vh></v>
<v t="ekr.20160520184945.144"><vh>ft.Try (Python 3)</vh></v>
<v t="ekr.20160520184945.145"><vh>ft.TryExcept</vh></v>
<v t="ekr.20160520184945.146"><vh>ft.TryFinally</vh></v>
<v t="ekr.20160520184945.147"><vh>ft.While</vh></v>
<v t="ekr.20160520184945.148"><vh>ft.With</vh></v>
<v t="ekr.20160520184945.149"><vh>ft.Yield</vh></v>
<v t="ekr.20160520184945.150"><vh>ft.YieldFrom (Python 3)</vh></v>
</v>
<v t="ekr.20160520184945.151"><vh>ft.visit</vh></v>
<v t="ekr.20160520184945.152"><vh>ft.visit_list</vh></v>
</v>
<v t="ekr.20160520184945.153"><vh>class AstPatternFormatter (AstFormatter)</vh>
<v t="ekr.20160520184945.154"><vh>Constants &amp; Name</vh></v>
</v>
<v t="ekr.20160520184945.252"><vh>class TokenSync</vh>
<v t="ekr.20160520184945.253"><vh> ts.ctor &amp; helpers</vh>
<v t="ekr.20160520184945.254"><vh>ts.make_blank_lines</vh></v>
<v t="ekr.20160520184945.255"><vh>ts.make_ignored_lines</vh></v>
<v t="ekr.20160520184945.256"><vh>ts.make_line_tokens (trace tokens)</vh></v>
<v t="ekr.20160520184945.257"><vh>ts.make_nl_token</vh></v>
<v t="ekr.20160520184945.258"><vh>ts.make_string_tokens</vh></v>
</v>
<v t="ekr.20160520184945.259"><vh>ts.check_strings</vh></v>
<v t="ekr.20160520184945.260"><vh>ts.dump_token</vh></v>
<v t="ekr.20160520184945.261"><vh>ts.is_line_comment</vh></v>
<v t="ekr.20160520184945.262"><vh>ts.join</vh></v>
<v t="ekr.20160520184945.263"><vh>ts.last_node</vh></v>
<v t="ekr.20160520184945.264"><vh>ts.leading_lines</vh></v>
<v t="ekr.20160520184945.265"><vh>ts.leading_string</vh></v>
<v t="ekr.20160520184945.266"><vh>ts.line_at</vh></v>
<v t="ekr.20160520184945.267"><vh>ts.sync_string</vh></v>
<v t="ekr.20160520184945.268"><vh>ts.token_kind/raw_val/val</vh></v>
<v t="ekr.20160520184945.269"><vh>ts.tokens_for_statement</vh></v>
<v t="ekr.20160520184945.270"><vh>ts.trailing_comment</vh></v>
<v t="ekr.20160520184945.271"><vh>ts.trailing_comment_at_lineno</vh></v>
<v t="ekr.20160520184945.272"><vh>ts.trailing_lines</vh></v>
</v>
</v>
<v t="ekr.20160519172255.79"><vh>@clean messages.py</vh>
<v t="ekr.20160519172255.80"><vh>class Message</vh>
<v t="ekr.20160519172255.81"><vh>__init__</vh></v>
<v t="ekr.20160519172255.82"><vh>__str__</vh></v>
</v>
<v t="ekr.20160519172255.83"><vh>class UnusedImport</vh>
<v t="ekr.20160519172255.84"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.85"><vh>class RedefinedWhileUnused</vh>
<v t="ekr.20160519172255.86"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.87"><vh>class RedefinedInListComp</vh>
<v t="ekr.20160519172255.88"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.89"><vh>class ImportShadowedByLoopVar</vh>
<v t="ekr.20160519172255.90"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.91"><vh>class ImportStarUsed</vh>
<v t="ekr.20160519172255.92"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.93"><vh>class UndefinedName</vh>
<v t="ekr.20160519172255.94"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.95"><vh>class DoctestSyntaxError</vh>
<v t="ekr.20160519172255.96"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.97"><vh>class UndefinedExport</vh>
<v t="ekr.20160519172255.98"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.99"><vh>class UndefinedLocal</vh>
<v t="ekr.20160519172255.100"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.101"><vh>class DuplicateArgument</vh>
<v t="ekr.20160519172255.102"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.103"><vh>class LateFutureImport</vh>
<v t="ekr.20160519172255.104"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.105"><vh>class UnusedVariable</vh>
<v t="ekr.20160519172255.106"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.107"><vh>class ReturnWithArgsInsideGenerator</vh></v>
<v t="ekr.20160519172255.108"><vh>class ReturnOutsideFunction</vh></v>
</v>
<v t="ekr.20160519172255.109"><vh>@clean reporter.py</vh>
<v t="ekr.20160519172255.111"><vh>class Reporter</vh>
<v t="ekr.20160519172255.112"><vh>__init__</vh></v>
<v t="ekr.20160519172255.113"><vh>unexpectedError</vh></v>
<v t="ekr.20160519172255.114"><vh>syntaxError</vh></v>
<v t="ekr.20160519172255.115"><vh>flake</vh></v>
</v>
<v t="ekr.20160519172255.116"><vh>_makeDefaultReporter</vh></v>
</v>
<v t="ekr.20160519180137.1"><vh>epytext markup</vh></v>
<v t="ekr.20160519182919.1"><vh>test of getFields code</vh></v>
</v>
<v t="ekr.20160523172144.1"><vh>----------------</vh></v>
<v t="ekr.20160531100422.1"><vh>@button unit-tests</vh></v>
<v t="ekr.20160520081237.1"><vh>@button test</vh>
<v t="ekr.20160520160409.1"><vh>&lt;&lt; test imports &gt;&gt;</vh></v>
<v t="ekr.20160526064907.1"><vh>&lt;&lt; test switches &gt;&gt;</vh></v>
<v t="ekr.20160520162722.1"><vh>&lt;&lt; define s_list &gt;&gt;</vh>
<v t="ekr.20160526165301.1"><vh>all messages</vh></v>
</v>
<v t="ekr.20160523085953.1"><vh>class TestController</vh>
<v t="ekr.20160520082209.1"><vh>check_all</vh></v>
<v t="ekr.20160520162336.1"><vh>check_string</vh></v>
<v t="ekr.20160520210414.1"><vh>compile_string</vh></v>
<v t="ekr.20160521023438.1"><vh>handle_tree (TestController)</vh></v>
<v t="ekr.20160523172328.1"><vh>print_stats (TestController)</vh></v>
<v t="ekr.20160520210256.1"><vh>read_string</vh></v>
<v t="ekr.20160520081827.1"><vh>run_test</vh></v>
<v t="ekr.20160520210931.1"><vh>traverse_tree</vh></v>
</v>
</v>
<v t="ekr.20160526064907.1"></v>
<v t="ekr.20160526060219.1"><vh>&lt;&lt; checker switches &gt;&gt;</vh></v>
<v t="ekr.20160523172328.1"></v>
<v t="ekr.20160523172121.1"><vh>----------------</vh></v>
<v t="ekr.20160519172255.10"><vh>@clean checker.py</vh>
<v t="ekr.20160519172255.11"><vh>&lt;&lt; imports &gt;&gt; (checker)</vh></v>
<v t="ekr.20160526060219.1"></v>
<v t="ekr.20160519172255.12"><vh>class _FieldsOrder(dict)</vh>
<v t="ekr.20160519172255.13"><vh>_FieldsOrder._get_fields (changed)</vh></v>
<v t="ekr.20160519172255.14"><vh>_FieldsOrder.__missing__</vh></v>
</v>
<v t="ekr.20160519181348.1"><vh>top-level</vh>
<v t="ekr.20160519181035.1"><vh>getAlternatives</vh></v>
<v t="ekr.20160519172255.39"><vh>getNodeName</vh></v>
<v t="ekr.20160519180953.1"><vh>getNodeType (returns uppercase class name)</vh></v>
<v t="ekr.20160519172255.15"><vh>iter_child_nodes</vh></v>
<v t="ekr.20160523090911.3"><vh>unit_test</vh></v>
</v>
<v t="ekr.20160519172710.1"><vh>Binding &amp; Definition classes</vh>
<v t="ekr.20160519172255.16"><vh>class Binding</vh>
<v t="ekr.20160519172255.18"><vh>Binding.__str__</vh></v>
<v t="ekr.20160519172255.19"><vh>Binding.__repr__</vh></v>
<v t="ekr.20160519172255.20"><vh>Binding.redefines</vh></v>
</v>
<v t="ekr.20160519172255.21"><vh>class Definition (Binding)</vh></v>
<v t="ekr.20160519172255.22"><vh>class Importation (Definition)</vh>
<v t="ekr.20160519172255.23"><vh>__init__</vh></v>
<v t="ekr.20160519172255.24"><vh>redefines</vh></v>
</v>
<v t="ekr.20160519172255.25"><vh>class Argument (Binding)</vh></v>
<v t="ekr.20160519172255.26"><vh>class Assignment (Binding)</vh></v>
<v t="ekr.20160519172255.27"><vh>class FunctionDefinition (Definition)</vh></v>
<v t="ekr.20160519172255.28"><vh>class ClassDefinition (Definition)</vh></v>
<v t="ekr.20160519172255.29"><vh>class ExportBinding (Binding)</vh>
<v t="ekr.20160519172255.30"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20160519172730.1"><vh>Scope classes</vh>
<v t="ekr.20160519172255.31"><vh>class Scope(dict)</vh>
<v t="ekr.20160525151651.1"><vh>Scope.__repr__</vh></v>
</v>
<v t="ekr.20160519172255.33"><vh>class ClassScope (Scope)</vh></v>
<v t="ekr.20160519172255.34"><vh>class FunctionScope (Scope)</vh>
<v t="ekr.20160519172255.35"><vh>FunctionScope.__init__</vh></v>
<v t="ekr.20160519172255.36"><vh>FunctionScope.unusedAssignments</vh></v>
</v>
<v t="ekr.20160519172255.37"><vh>class GeneratorScope (Scope)</vh></v>
<v t="ekr.20160519172255.38"><vh>class ModuleScope (Scope)</vh></v>
</v>
<v t="ekr.20160519172255.40"><vh>class Checker</vh>
<v t="ekr.20160519172255.41"><vh>Checker.__init__</vh></v>
<v t="ekr.20160521155725.1"><vh>Checker.defer...</vh>
<v t="ekr.20160519172255.43"><vh>Checker.deferAssignment</vh></v>
<v t="ekr.20160519172255.42"><vh>Checker.deferFunction</vh></v>
<v t="ekr.20160519172255.44"><vh>Checker.runDeferred</vh></v>
</v>
<v t="ekr.20160519173318.1"><vh>Checker.scopes...</vh>
<v t="ekr.20160519172255.45"><vh>Checker.scope (property)</vh></v>
<v t="ekr.20160519172255.46"><vh>Checker.popScope</vh></v>
<v t="ekr.20160519172255.48"><vh>Checker.pushScope</vh></v>
</v>
<v t="ekr.20160519172255.49"><vh>Checker.report</vh></v>
<v t="ekr.20160519173339.1"><vh>Checker.tree structure</vh>
<v t="ekr.20160519172255.50"><vh>Checker.getParent</vh></v>
<v t="ekr.20160519172255.51"><vh>Checker.getCommonAncestor</vh></v>
<v t="ekr.20160519172255.52"><vh>Checker.descendantOf</vh></v>
<v t="ekr.20160519172255.53"><vh>Checker.differentForks</vh></v>
</v>
<v t="ekr.20160519172255.54"><vh>Checker.addBinding</vh></v>
<v t="ekr.20160521155817.1"><vh>Checker.docstrings...</vh>
<v t="ekr.20160519172255.61"><vh>Checker.isDocstring</vh></v>
<v t="ekr.20160519172255.62"><vh>Checker.getDocstring</vh></v>
</v>
<v t="ekr.20160519172836.1"><vh>Checker.Node handlers</vh>
<v t="ekr.20160519173152.1"><vh> Checker.traversers...</vh>
<v t="ekr.20160519172255.64"><vh>Checker.handleDoctests</vh></v>
<v t="ekr.20160519172255.63"><vh>Checker.handleNode (injects parent/depth fields)</vh></v>
</v>
<v t="ekr.20160524091908.1"><vh>&lt;&lt; non-aft handlers &gt;&gt;</vh>
<v t="ekr.20160519172255.55"><vh>Checker.getNodeHandler</vh></v>
<v t="ekr.20160519172255.59"><vh>Checker.handleChildren</vh></v>
</v>
<v t="ekr.20160522081903.1"><vh>&lt;&lt; default node handlers &gt;&gt;</vh>
<v t="ekr.20160522081949.10"><vh>ft.operators &amp; operands</vh>
<v t="ekr.20160524091403.1"><vh>ft.alias</vh></v>
<v t="ekr.20160522081949.11"><vh>ft.arguments &amp; arg</vh></v>
<v t="ekr.20160522081949.12"><vh>ft.Attribute</vh></v>
<v t="ekr.20160522081949.13"><vh>ft.BinOp</vh></v>
<v t="ekr.20160522081949.14"><vh>ft.BoolOp</vh></v>
<v t="ekr.20160524091135.1"><vh>ft.Bytes</vh></v>
<v t="ekr.20160522081949.16"><vh>ft.Call</vh></v>
<v t="ekr.20160522081949.17"><vh>ft.Compare</vh></v>
<v t="ekr.20160522081949.19"><vh>ft.comprehension</vh></v>
<v t="ekr.20160522081949.20"><vh>ft.Dict</vh></v>
<v t="ekr.20160524091305.1"><vh>ft.Ellipsis</vh></v>
<v t="ekr.20160522081949.22"><vh>ft.Expr</vh></v>
<v t="ekr.20160522081949.23"><vh>ft.Expression</vh></v>
<v t="ekr.20160522081949.24"><vh>ft.ExtSlice</vh></v>
<v t="ekr.20160522081949.26"><vh>ft.ifExp (ternary operator)</vh></v>
<v t="ekr.20160522081949.27"><vh>ft.Index</vh></v>
<v t="ekr.20160522081949.28"><vh>ft.keyword</vh></v>
<v t="ekr.20160522081949.29"><vh>ft.List &amp; list</vh></v>
<v t="ekr.20160522082410.1"><vh>ft.NameConstant</vh></v>
<v t="ekr.20160524091057.1"><vh>ft.Num</vh></v>
<v t="ekr.20160522081949.32"><vh>ft.Repr</vh></v>
<v t="ekr.20160523093026.1"><vh>ft.Set (new)</vh></v>
<v t="ekr.20160522081949.33"><vh>ft.Slice</vh></v>
<v t="ekr.20160524091119.1"><vh>ft.Str</vh></v>
<v t="ekr.20160522081949.35"><vh>ft.Subscript</vh></v>
<v t="ekr.20160522081949.36"><vh>ft.Tuple</vh></v>
<v t="ekr.20160522081949.37"><vh>ft.UnaryOp</vh></v>
</v>
<v t="ekr.20160522081949.38"><vh>ft.statements</vh>
<v t="ekr.20160522081949.40"><vh>ft.Assert</vh></v>
<v t="ekr.20160522081949.41"><vh>ft.Assign</vh></v>
<v t="ekr.20160524084528.1"><vh>ft.Break</vh></v>
<v t="ekr.20160524084549.1"><vh>ft.Continue</vh></v>
<v t="ekr.20160522081949.45"><vh>ft.Delete</vh></v>
<v t="ekr.20160522081949.47"><vh>ft.Exec</vh></v>
<v t="ekr.20160522081949.48"><vh>ft.For</vh></v>
<v t="ekr.20160522081949.50"><vh>ft.If</vh></v>
<v t="ekr.20160524084621.1"><vh>ft.Pass</vh></v>
<v t="ekr.20160522081949.54"><vh>ft.Print</vh></v>
<v t="ekr.20160522081949.55"><vh>ft.Raise</vh></v>
<v t="ekr.20160522081949.57"><vh>ft.Starred (Python 3)</vh></v>
<v t="ekr.20160522081949.60"><vh>ft.TryFinally</vh></v>
<v t="ekr.20160522081949.61"><vh>ft.While</vh></v>
<v t="ekr.20160522081949.62"><vh>ft.With</vh></v>
</v>
</v>
<v t="ekr.20160519172255.74"><vh>Checker.AUGASSIGN</vh></v>
<v t="ekr.20160519172255.73"><vh>Checker.CLASSDEF</vh></v>
<v t="ekr.20160519172255.78"><vh>Checker.EXCEPTHANDLER</vh></v>
<v t="ekr.20160519172255.71"><vh>Checker.FUNCTIONDEF</vh></v>
<v t="ekr.20160519172255.67"><vh>Checker.GENERATOREXP &amp; comprehensions</vh></v>
<v t="ekr.20160519172255.66"><vh>Checker.GLOBAL &amp; NONLOCAL (Real bug fix)</vh></v>
<v t="ekr.20160519172255.75"><vh>Checker.IMPORT</vh></v>
<v t="ekr.20160519172255.76"><vh>Checker.IMPORTFROM</vh></v>
<v t="ekr.20160519172255.72"><vh>Checker.LAMBDA</vh>
<v t="ekr.20160523173531.1"><vh>Checker.get_function_args</vh></v>
<v t="ekr.20160523173355.1"><vh>&lt;&lt; define runFunction &gt;&gt; (LAMBDA)</vh></v>
</v>
<v t="ekr.20160522063947.1"><vh>Checker.MODULE (4 passes)</vh>
<v t="ekr.20160523181737.1"><vh>Checker.pass1</vh></v>
<v t="ekr.20160523181742.1"><vh>Checker.pass2 (uses scopeStack)</vh>
<v t="ekr.20160526063937.1"><vh>Checker.scanFunction</vh></v>
</v>
<v t="ekr.20160523181745.1"><vh>Checker.pass3</vh>
<v t="ekr.20160526074410.1"><vh>Checker.checkAssignments (NEW)</vh></v>
</v>
<v t="ekr.20160519172255.47"><vh>Checker.checkDeadScopes (pass4)</vh></v>
</v>
<v t="ekr.20160519172255.68"><vh>Checker.NAME &amp; helpers</vh>
<v t="ekr.20160519172255.58"><vh>Checker.handleNodeDelete</vh></v>
<v t="ekr.20160519172255.56"><vh>Checker.handleNodeLoad</vh></v>
<v t="ekr.20160519172255.57"><vh>Checker.handleNodeStore &amp; helper</vh>
<v t="ekr.20160519172255.60"><vh>Checker.isLiteralTupleUnpacking</vh></v>
</v>
</v>
<v t="ekr.20160519172255.69"><vh>Checker.RETURN</vh></v>
<v t="ekr.20160519172255.77"><vh>Checker.TRY &amp; TRYEXCEPT</vh></v>
<v t="ekr.20160519172255.70"><vh>Checker.YIELD</vh></v>
</v>
</v>
</v>
<v t="ekr.20160531210435.1"><vh>posting: re unit tests.</vh></v>
<v t="ekr.20160603042535.1"><vh>posting: project complete</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20160519172255.10">"""
Main module.

Implement the central Checker class.
Also, it models the Bindings and Scopes.
"""

@language python
@tabwidth -4

&lt;&lt;imports&gt;&gt;
&lt;&lt; checker switches &gt;&gt;
stats = {}
    # Timing stats.
n_pass_nodes = [None, 0, 0]
    # Only Passes 1 &amp; 2 traverse nodes.
    # The sum is the number of calls to handleNodes
n_ignore = n_handleChildren = n_FunctionDef = n_null_nodes = 0
n_load = n_store = n_scopes = 0
n_deferred_assignments = n_scope_names = 0
test_scope = None

# Globally defined names which are not attributes of the builtins module, or
# are only present on some platforms.
_MAGIC_GLOBALS = ['__file__', '__builtins__', 'WindowsError']
@others
</t>
<t tx="ekr.20160519172255.100">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.101">class DuplicateArgument(Message):
    message = 'duplicate argument %r in function definition'

    @others
</t>
<t tx="ekr.20160519172255.102">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.103">class LateFutureImport(Message):
    message = 'future import(s) %r after other statements'

    @others
</t>
<t tx="ekr.20160519172255.104">def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)
</t>
<t tx="ekr.20160519172255.105">class UnusedVariable(Message):
    """
    Indicates that a variable has been explicity assigned to but not actually
    used.
    """
    message = 'local variable %r is assigned to but never used'

    @others
</t>
<t tx="ekr.20160519172255.106">def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)
</t>
<t tx="ekr.20160519172255.107">class ReturnWithArgsInsideGenerator(Message):
    """
    Indicates a return statement with arguments inside a generator.
    """
    message = '\'return\' with argument inside generator'
</t>
<t tx="ekr.20160519172255.108">class ReturnOutsideFunction(Message):
    """
    Indicates a return statement outside of a function/method.
    """
    message = '\'return\' outside function'
</t>
<t tx="ekr.20160519172255.109">"""
Provide the Reporter class.
"""
import re
import sys
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20160519172255.11"># checker.py imports...
import leo.core.leoGlobals as g # EKR
assert g

import doctest
import os
import sys
import time # ekr

PY2 = sys.version_info &lt; (3, 0)
PY32 = sys.version_info &lt; (3, 3)    # Python 2.5 to 3.2
PY33 = sys.version_info &lt; (3, 4)    # Python 2.5 to 3.3
builtin_vars = dir(__import__('__builtin__' if PY2 else 'builtins'))

try:
    import ast
except ImportError:     # Python 2.5
    import _ast as ast

    if 'decorator_list' not in ast.ClassDef._fields:
        # Patch the missing attribute 'decorator_list'
        ast.ClassDef.decorator_list = ()
        ast.FunctionDef.decorator_list = property(lambda s: s.decorators)

from pyflakes import messages
# g.trace(messages)
</t>
<t tx="ekr.20160519172255.111">class Reporter(object):
    """
    Formats the results of pyflakes checks to users.
    """
    @others
</t>
<t tx="ekr.20160519172255.112">def __init__(self, warningStream, errorStream):
    """
    Construct a L{Reporter}.

    @param warningStream: A file-like object where warnings will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stdout} is a good value.
    @param errorStream: A file-like object where error output will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stderr} is a good value.
    """
    self._stdout = warningStream
    self._stderr = errorStream
</t>
<t tx="ekr.20160519172255.113">def unexpectedError(self, filename, msg):
    """
    An unexpected error occurred trying to process C{filename}.

    @param filename: The path to a file that we could not process.
    @ptype filename: C{unicode}
    @param msg: A message explaining the problem.
    @ptype msg: C{unicode}
    """
    self._stderr.write("%s: %s\n" % (filename, msg))
</t>
<t tx="ekr.20160519172255.114">def syntaxError(self, filename, msg, lineno, offset, text):
    """
    There was a syntax errror in C{filename}.

    @param filename: The path to the file with the syntax error.
    @ptype filename: C{unicode}
    @param msg: An explanation of the syntax error.
    @ptype msg: C{unicode}
    @param lineno: The line number where the syntax error occurred.
    @ptype lineno: C{int}
    @param offset: The column on which the syntax error occurred, or None.
    @ptype offset: C{int}
    @param text: The source code containing the syntax error.
    @ptype text: C{unicode}
    """
    line = text.splitlines()[-1]
    if offset is not None:
        offset = offset - (len(text) - len(line))
        self._stderr.write('%s:%d:%d: %s\n' %
                           (filename, lineno, offset + 1, msg))
    else:
        self._stderr.write('%s:%d: %s\n' % (filename, lineno, msg))
    self._stderr.write(line)
    self._stderr.write('\n')
    if offset is not None:
        self._stderr.write(re.sub(r'\S', ' ', line[:offset]) +
                           "^\n")
</t>
<t tx="ekr.20160519172255.115">def flake(self, message):
    """
    pyflakes found something wrong with the code.

    @param: A L{pyflakes.messages.Message}.
    """
    self._stdout.write(str(message))
    self._stdout.write('\n')
</t>
<t tx="ekr.20160519172255.116">def _makeDefaultReporter():
    """
    Make a reporter that can be used when no reporter is specified.
    """
    return Reporter(sys.stdout, sys.stderr)
</t>
<t tx="ekr.20160519172255.117">@language python
@tabwidth -4
__version__ = '1.0.0'

</t>
<t tx="ekr.20160519172255.119">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="ekr.20160519172255.12">
if aft:
    pass
else:
    

    class _FieldsOrder(dict):
        """Fix order of AST node fields."""
        @others
</t>
<t tx="ekr.20160519172255.120">from pyflakes.api import main

# python -m pyflakes (with Python &gt;= 2.7)
if __name__ == '__main__':
    main(prog='pyflakes')
</t>
<t tx="ekr.20160519172255.13">
def _get_fields(self, node_class):
    # handle iter before target, and generators before element
    # EKR: the effect of the key is to assign 0 to 'iter' or 'generators' or 'value'
    # and -1 to everything else. So the target is *last*, so reverse=True is needed.
    if 1: # EKR new code
        fields = list(node_class._fields)
        for field in ('iter', 'generators', 'value'):
            if field in fields:
                fields.remove(field)
                fields.insert(0, field)
                break
        return tuple(fields)
    else:
        fields = node_class._fields
        if 'iter' in fields:
            key_first = 'iter'.find
        elif 'generators' in fields:
            key_first = 'generators'.find
        else:
            key_first = 'value'.find
        return tuple(sorted(fields, key=key_first, reverse=True))
    </t>
<t tx="ekr.20160519172255.14">
def __missing__(self, node_class):
    # EKR: called if self[node_class] does not exist.
    self[node_class] = fields = self._get_fields(node_class)
    # g.trace(node_class.__name__, fields)
    return fields
</t>
<t tx="ekr.20160519172255.15">
if aft:
    pass
    
else:

    def iter_child_nodes(node, omit=None, _fields_order=_FieldsOrder()):
        """
        Yield all direct child nodes of *node*, that is, all fields that
        are nodes and all items of fields that are lists of nodes.
        """
        for name in _fields_order[node.__class__]:
            if name == omit:
                continue
            field = getattr(node, name, None)
            if isinstance(field, ast.AST):
                yield field
            elif isinstance(field, list):
                for item in field:
                    yield item
</t>
<t tx="ekr.20160519172255.16">

class Binding(object):
    """
    Represents the binding of a value to a name.

    The checker uses this to keep track of which names have been bound and
    which names have not. See L{Assignment} for a special type of binding that
    is checked with stricter rules.

    @ivar used: pair of (L{Scope}, line-number) indicating the scope and
                line number that this binding was last used
    """
    kind = 'binding'
    def __init__(self, name, source):
        self.name = name
        self.source = source # EKR: a node.
        self.used = False # EKR: Set in helpers of Name.

    @others
</t>
<t tx="ekr.20160519172255.18">
def __str__(self):
    return self.name
</t>
<t tx="ekr.20160519172255.19">
def __repr__(self):
    return '&lt;Binding line %-2s %-6s %15s&gt;' % (
        self.source.lineno,
        self.kind, 
        self.name,
    )
    # return '&lt;%s object %r from line %r at 0x%x&gt;' % (
        # self.__class__.__name__,
        # self.name,
        # self.source.lineno,
        # id(self))
</t>
<t tx="ekr.20160519172255.2">"""
API for the command-line I{pyflakes} tool.
"""

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="ekr.20160519172255.20">
def redefines(self, other):
    return isinstance(other, Definition) and self.name == other.name
</t>
<t tx="ekr.20160519172255.21">

class Definition(Binding):
    """
    A binding that defines a function or a class.
    """
</t>
<t tx="ekr.20160519172255.22">

class Importation(Definition):
    """
    A binding created by an import statement.

    @ivar fullName: The complete name given to the import statement,
        possibly including multiple dotted components.
    @type fullName: C{str}
    """
    kind = 'import'
    @others
</t>
<t tx="ekr.20160519172255.23">
def __init__(self, name, source):
    self.fullName = name
    self.redefined = []
    name = name.split('.')[0]
    super(Importation, self).__init__(name, source)
</t>
<t tx="ekr.20160519172255.24">
def redefines(self, other):
    if isinstance(other, Importation):
        return self.fullName == other.fullName
    else:
        # EKR: same as Binding.redefines.
        return isinstance(other, Definition) and self.name == other.name
</t>
<t tx="ekr.20160519172255.25">

class Argument(Binding):
    """
    Represents binding a name as an argument.
    """
    kind = 'arg' # EKR</t>
<t tx="ekr.20160519172255.26">

class Assignment(Binding):
    """
    Represents binding a name with an explicit assignment.

    The checker will raise warnings for any Assignment that isn't used. Also,
    the checker does not consider assignments in tuple/list unpacking to be
    Assignments, rather it treats them as simple Bindings.
    """
    kind = 'assign' # EKR
</t>
<t tx="ekr.20160519172255.27">

class FunctionDefinition(Definition):
    
    kind = 'def' # EKR
</t>
<t tx="ekr.20160519172255.28">

class ClassDefinition(Definition):
    
    kind = 'class' # EKR
</t>
<t tx="ekr.20160519172255.29">

class ExportBinding(Binding):
    """
    A binding created by an C{__all__} assignment.  If the names in the list
    can be determined statically, they will be treated as names for export and
    additional checking applied to them.

    The only C{__all__} assignment that can be recognized is one which takes
    the value of a literal list containing literal strings.  For example::

        __all__ = ["foo", "bar"]

    Names which are imported and not otherwise used but appear in the value of
    C{__all__} will not have an unused import warning reported for them.
    """
    kind = 'export' # EKR
    
    @others
</t>
<t tx="ekr.20160519172255.3">from __future__ import with_statement

import sys
import os
import _ast

### from pyflakes import checker, __version__
import checker # EKR
__version__ = 'EKR: __version__'
### from pyflakes import reporter as modReporter
import reporter as modReporter # EKR

__all__ = ['check', 'checkPath', 'checkRecursive', 'iterSourceCode', 'main']
</t>
<t tx="ekr.20160519172255.30">
def __init__(self, name, source, scope):
    if '__all__' in scope and isinstance(source, ast.AugAssign):
        self.names = list(scope['__all__'].names)
    else:
        self.names = []
    self.kind = 'import'
    if isinstance(source.value, (ast.List, ast.Tuple)):
        for node in source.value.elts:
            if isinstance(node, ast.Str):
                self.names.append(node.s)
    super(ExportBinding, self).__init__(name, source)
</t>
<t tx="ekr.20160519172255.31">

class Scope(dict):

    importStarred = False
        # set to True when import * is found

    # EKR: Adding more data to scopes takes negligible time.
    def __init__(self, node, name, parent):
        self.name = name
        self.node = node
        self.parent = parent
        # This code would be useful in some contexts, but not here and now.
        # self.children = []
        # if self.parent:
            # self.parent.children.append(self)
        
    @others

    </t>
<t tx="ekr.20160519172255.33">

class ClassScope(Scope):

    def __init__(self, node, name, parent):
        Scope.__init__(self, node, name, parent)

</t>
<t tx="ekr.20160519172255.34">

class FunctionScope(Scope):
    """
    I represent a name scope for a function.

    @ivar globals: Names declared 'global' in this function.
    """
    # EKR: only FunctionScope defines .globals ivar.
    usesLocals = False
    alwaysUsed = set([
        '__tracebackhide__',
        '__traceback_info__',
        '__traceback_supplement__'])

    @others
</t>
<t tx="ekr.20160519172255.35">
def __init__(self, node, name, parent):

    Scope.__init__(self, node, name, parent)
    # Simplify: manage the special locals as globals
    self.globals = self.alwaysUsed.copy()
    self.returnValue = None     # First non-empty return
    self.isGenerator = False    # Detect a generator
</t>
<t tx="ekr.20160519172255.36">
def unusedAssignments(self):
    """
    Return a generator for the assignments which have not been used.
    """
    # EKR: only called in FunctionScope.
    global n_scope_names ; n_scope_names += len(self.keys())
    for name, binding in self.items():
        if (not binding.used and
            name not in self.globals and
            not self.usesLocals and
            isinstance(binding, Assignment)
        ):
            yield name, binding
</t>
<t tx="ekr.20160519172255.37">

class GeneratorScope(Scope):

    def __init__(self, node, name, parent):
        Scope.__init__(self, node, name, parent)
</t>
<t tx="ekr.20160519172255.38">

class ModuleScope(Scope):

    def __init__(self, node, name, parent):
        assert parent is None, parent
            # Module's are the only scopes without a parent.
        name = 'Module: %s' % name
        Scope.__init__(self, node, name, parent)
</t>
<t tx="ekr.20160519172255.39">
def getNodeName(node):
    # Return the node's name, or None.
    return getattr(node, 'id', None) or getattr(node, 'name', None)
   </t>
<t tx="ekr.20160519172255.4">def check(codeString, filename, reporter=None, tree=None): # EKR: added tree.
    """
    Check the Python source given by C{codeString} for flakes.

    @param codeString: The Python source to check.
    @type codeString: C{str}

    @param filename: The name of the file the source came from, used to report
        errors.
    @type filename: C{str}

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: The number of warnings emitted.
    @rtype: C{int}
    """
    import leo.core.leoGlobals as g # EKR

    # print('EKR: api.check: %s' % filename)
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    # First, compile into an AST and handle syntax errors.
    if not tree:
        try:
            tree = compile(codeString, filename, "exec", _ast.PyCF_ONLY_AST)
        except SyntaxError:
            value = sys.exc_info()[1]
            msg = value.args[0]
    
            (lineno, offset, text) = value.lineno, value.offset, value.text
            g.es_print_exception() # EKR
    
            # If there's an encoding problem with the file, the text is None.
            if text is None:
                # Avoid using msg, since for the only known case, it contains a
                # bogus message that claims the encoding the file declared was
                # unknown.
                # EKR:
                reporter.unexpectedError(filename, 'no text: syntax error?')
            else:
                reporter.syntaxError(filename, msg, lineno, offset, text)
            return 1
        except Exception:
            g.es_print_exception() # EKR
            reporter.unexpectedError(filename, 'unexpected exception')
            return 1
    # Okay, it's syntactically valid.  Now check it.
    w = checker.Checker(tree, filename)
    w.messages.sort(key=lambda m: m.lineno)
    for warning in w.messages:
        reporter.flake(warning)
    return len(w.messages)
</t>
<t tx="ekr.20160519172255.40">

class Checker(object):
    """
    I check the cleanliness and sanity of Python code.

    @ivar _deferredFunctions: Tracking list used by L{deferFunction}.  Elements
        of the list are two-tuples.  The first element is the callable passed
        to L{deferFunction}.  The second element is a copy of the scope stack
        at the time L{deferFunction} was called.

    @ivar _deferredAssignments: Similar to C{_deferredFunctions}, but for
        callables which are deferred assignment checks.
    """

    nodeDepth = 0 # EKR: also set in ctor.
    offset = None
    traceTree = False

    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)
    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')
    if _customBuiltIns:
        builtIns.update(_customBuiltIns.split(','))
    del _customBuiltIns

    @others
</t>
<t tx="ekr.20160519172255.41">
def __init__(self, tree, filename='(none)', builtins=None,
             withDoctest='PYFLAKES_DOCTEST' in os.environ):
    
    if aft:
        pass
    else:
        self._nodeHandlers = {}
    self._deferredFunctions = []
    self._deferredAssignments = []
    self.deadScopes = []
    self.messages = []
    self.nodeDepth = 0
    self.filename = filename
    # EKR: self.builtIns defined in class node.
    if builtins:
        self.builtIns = self.builtIns.union(builtins)
    self.withDoctest = withDoctest
    self.exceptHandlers = [()]
    self.futuresAllowed = True
    self.root = tree
    self.pass_n = 1 # EKR.
    if new_scope: # EKR.
        self.scope = None
    self.handleNode(tree, parent=None)
        # EKR: new MODULE handler does all the work.
</t>
<t tx="ekr.20160519172255.42">
def deferFunction(self, func, node=None, args=None):
    """
    Schedule a function handler to be called just before completion.

    This is used for handling function bodies, which must be deferred
    because code later in the file might modify the global scope. When
    `callable` is called, the scope at the time this is called will be
    restored, however it will contain any new bindings added to it.
    """
    self._deferredFunctions.append((func, self.scopeStack[:], self.offset))
</t>
<t tx="ekr.20160519172255.43">
def deferAssignment(self, func):
    """
    Schedule an assignment handler to be called just after deferred
    function handlers.
    """
    global n_deferred_assignments ; n_deferred_assignments += 1
    self._deferredAssignments.append((func, self.scopeStack[:], self.offset))
</t>
<t tx="ekr.20160519172255.44">
def runDeferred(self, deferred):
    """
    Run the callables in C{deferred} using their associated scope stack.
    """
    for handler, scope, offset in deferred:
        self.scopeStack = scope
        self.offset = offset
        if new_scope:
            self.scope = self.scopeStack[-1] if self.scopeStack else None
        handler()
</t>
<t tx="ekr.20160519172255.45">
if new_scope:
    pass
else:
    # EKR: expensive.
    # It's not necessary, because pushStack/popStack encapsulate it.
    @property
    def scope(self):
        if new_scope: assert False
        return self.scopeStack[-1]
</t>
<t tx="ekr.20160519172255.46">
if new_scope:
    
    def popScope(self):
        self.deadScopes.append(self.scopeStack.pop())
        self.scope = self.scopeStack[-1] if self.scopeStack else None

else:
    
    def popScope(self):
        self.deadScopes.append(self.scopeStack.pop())</t>
<t tx="ekr.20160519172255.47">
def checkDeadScopes(self):
    """
    Look at scopes which have been fully examined and report names in them
    which were imported but unused.
    """
    global stats
    t1 = time.clock()
    self.pass_n = 4
        # This will raise an exception in handleNode if any nodes are visited.
    for scope in self.deadScopes:
        if isinstance(scope.get('__all__'), ExportBinding):
            all_names = set(scope['__all__'].names)
            if not scope.importStarred and \
               os.path.basename(self.filename) != '__init__.py':
                # Look for possible mistakes in the export list
                undefined = all_names.difference(scope)
                for name in undefined:
                    self.report(messages.UndefinedExport,
                                scope['__all__'].source, name)
        else:
            all_names = []
        # Look for imported names that aren't used.
        for value in scope.values():
            if isinstance(value, Importation):
                used = value.used or value.name in all_names
                if not used:
                    messg = messages.UnusedImport
                    self.report(messg, value.source, value.name)
                for node in value.redefined:
                    if isinstance(self.getParent(node), ast.For):
                        messg = messages.ImportShadowedByLoopVar
                    elif used:
                        continue
                    else:
                        messg = messages.RedefinedWhileUnused
                    self.report(messg, node, value.name, value.source)
    t2 = time.clock()
    stats['pass4'] = stats.get('pass4', 0.0) + t2-t1
</t>
<t tx="ekr.20160519172255.48">
if new_scope:
    
    def pushScope(self, node, name, scopeClass):
        global n_scopes ; n_scopes += 1
        parent = self.scopeStack and self.scopeStack[-1] or None
        self.scope = scopeClass(node, name, parent)
        self.scopeStack.append(self.scope)
        
else:
            
    def pushScope(self, node, name, scopeClass):
        global n_scopes ; n_scopes += 1
        parent = self.scopeStack and self.scopeStack[-1] or None
        scope = scopeClass(node, name, parent)
        self.scopeStack.append(scope)

</t>
<t tx="ekr.20160519172255.49">
def report(self, messageClass, *args, **kwargs):
    self.messages.append(messageClass(self.filename, *args, **kwargs))
</t>
<t tx="ekr.20160519172255.5">def checkPath(filename, reporter=None):
    """
    Check the given path, printing out any warnings detected.

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: the number of warnings printed
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    try:
        # in Python 2.6, compile() will choke on \r\n line endings. In later
        # versions of python it's smarter, and we want binary mode to give
        # compile() the best opportunity to do the right thing WRT text
        # encodings.
        if sys.version_info &lt; (2, 7):
            mode = 'rU'
        else:
            mode = 'rb'

        with open(filename, mode) as f:
            codestr = f.read()
        if sys.version_info &lt; (2, 7):
            codestr += '\n'     # Work around for Python &lt;= 2.6
    except UnicodeError:
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    except IOError:
        msg = sys.exc_info()[1]
        reporter.unexpectedError(filename, msg.args[1])
        return 1
    return check(codestr, filename, reporter)
</t>
<t tx="ekr.20160519172255.50">
def getParent(self, node):
    # Lookup the first parent which is not Tuple, List or Starred
    # EKR: handleNode sets node.parent.
    while True:
        node = node.parent
        if not hasattr(node, 'elts') and not hasattr(node, 'ctx'):
            return node
</t>
<t tx="ekr.20160519172255.51">
def getCommonAncestor(self, lnode, rnode, stop):
    if stop in (lnode, rnode) or not (hasattr(lnode, 'parent') and
                                      hasattr(rnode, 'parent')):
        return None
    if lnode is rnode:
        return lnode

    if (lnode.depth &gt; rnode.depth):
        return self.getCommonAncestor(lnode.parent, rnode, stop)
    if (lnode.depth &lt; rnode.depth):
        return self.getCommonAncestor(lnode, rnode.parent, stop)
    return self.getCommonAncestor(lnode.parent, rnode.parent, stop)
</t>
<t tx="ekr.20160519172255.52">
def descendantOf(self, node, ancestors, stop):
    for a in ancestors:
        if self.getCommonAncestor(node, a, stop):
            return True
    return False
</t>
<t tx="ekr.20160519172255.53">
def differentForks(self, lnode, rnode):
    """True, if lnode and rnode are located on different forks of IF/TRY"""
    ancestor = self.getCommonAncestor(lnode, rnode, self.root)
    parts = getAlternatives(ancestor)
    if parts:
        for items in parts:
            if self.descendantOf(lnode, items, ancestor) ^ \
               self.descendantOf(rnode, items, ancestor):
                return True
    return False
</t>
<t tx="ekr.20160519172255.54">
def addBinding(self, node, value):
    """
    Called when a binding is altered.

    - `node` is the statement responsible for the change
    - `value` is the new value, a Binding instance
    """
    trace = False and test_scope == 'test'
    # assert value.source in (node, node.parent):
    for scope in self.scopeStack[::-1]:
            # EKR: same as list(reversed(scopeStack))
        if value.name in scope:
            break
    existing = scope.get(value.name)

    if existing and not self.differentForks(node, existing.source):

        parent_stmt = self.getParent(value.source)
        if isinstance(existing, Importation) and isinstance(parent_stmt, ast.For):
            self.report(messages.ImportShadowedByLoopVar,
                        node, value.name, existing.source)

        elif scope is self.scope:
            # g.trace('====', scope, existing, existing.used, value)
            if (isinstance(parent_stmt, ast.comprehension) and
                not isinstance(self.getParent(existing.source),
                    (ast.For, ast.comprehension))
            ):
                # g.trace(value.name, parent_stmt, self.getParent(existing.source))
                # g.trace(g.callers(10))
                self.report(messages.RedefinedInListComp,
                            node, value.name, existing.source)
            elif not existing.used and value.redefines(existing):
                # Redefines Class or Function.
                self.report(messages.RedefinedWhileUnused,
                            node, value.name, existing.source)

        elif isinstance(existing, Importation) and value.redefines(existing):
            existing.redefined.append(node)

    if value.name in self.scope:
        # then assume the rebound name is used as a global or within a loop
        value.used = self.scope[value.name].used

    self.scope[value.name] = value
    if trace: g.trace('    pass: %s %20r in %s' % (
        self.pass_n, value, scope.name))
        # getattr(self.scope, 'name', self.scope.__class__.__name__)))
</t>
<t tx="ekr.20160519172255.55">
def getNodeHandler(self, node_class):

    try:
        return self._nodeHandlers[node_class]
    except KeyError:
        nodeType = getNodeType(node_class)
    self._nodeHandlers[node_class] = handler = getattr(self, nodeType)
    return handler
</t>
<t tx="ekr.20160519172255.56">
def handleNodeLoad(self, node):
    
    global n_load, test_scope
    trace = False # and test_scope == 'test'
    # EKR: ctx is Load or AugLoad.
    name = getNodeName(node)
    if not name:
        return
    # try local scope
    try:
        self.scope[name].used = (self.scope, node)
    except KeyError:
        pass
    else:
        # EKR: the name is in the scope,
        # scope[name] is a Binding, and we have just marked it used.
        if trace: g.trace('pass: %s %40s in %s' % (
            # self.pass_n, name, repr(self.scope)))
            self.pass_n, self.scope[name], repr(self.scope)))
        return

    # EKR: Create a list of previous defining scopes.
    n_load += 1
    defining_scopes = (FunctionScope, ModuleScope, GeneratorScope) # EKR
    scopes = [scope for scope in self.scopeStack[:-1]
        if isinstance(scope, defining_scopes)]
            
    if isinstance(self.scope, GeneratorScope) and scopes[-1] != self.scopeStack[-2]:
        scopes.append(self.scopeStack[-2])

    # try enclosing function scopes and global scope
    importStarred = self.scope.importStarred
    for scope in reversed(scopes):
        importStarred = importStarred or scope.importStarred
        try:
            scope[name].used = (self.scope, node)
        except KeyError:
            pass
        else:
            if trace: g.trace('pass: %s %40s in %s' % (
            self.pass_n, scope[name], repr(scope)))
            return

    # look in the built-ins
    if importStarred or name in self.builtIns:
        return
    if name == '__path__' and os.path.basename(self.filename) == '__init__.py':
        # the special name __path__ is valid only in packages
        return

    # protected with a NameError handler?
    if 'NameError' not in self.exceptHandlers[-1]:
        self.report(messages.UndefinedName, node, name)
</t>
<t tx="ekr.20160519172255.57">
# EKR: called by Name and ExceptHandler.
# EKR: ctx is Store or AugStore.

def handleNodeStore(self, node):
    
    global n_store, test_scope
    trace = False # and test_scope == 'test'
    name = getNodeName(node)
    if not name:
        return
    # if the name hasn't already been defined in the current scope
    if isinstance(self.scope, FunctionScope) and name not in self.scope:
        # for each function or module scope above us
        n_store += 1
        for scope in self.scopeStack[:-1]:
            if not isinstance(scope, (FunctionScope, ModuleScope)):
                continue
            # if the name was defined in that scope, and the name has
            # been accessed already in the current scope, and hasn't
            # been declared global
            used = name in scope and scope[name].used
            if trace: g.trace(name, 'used:', used, scope.name,
                'isGlobal', name  in self.scope.globals)
            if used and used[0] is self.scope and name not in self.scope.globals:
                # then it's probably a mistake
                self.report(messages.UndefinedLocal,
                            scope[name].used[1], name, scope[name].source)
                break

    parent_stmt = self.getParent(node)
    if (isinstance(parent_stmt, (ast.For, ast.comprehension)) or
        (parent_stmt != node.parent and not self.isLiteralTupleUnpacking(parent_stmt))
    ):
        binding = Binding(name, node)
    elif name == '__all__' and isinstance(self.scope, ModuleScope):
        binding = ExportBinding(name, node.parent, self.scope)
    else:
        binding = Assignment(name, node)
    self.addBinding(node, binding)
</t>
<t tx="ekr.20160519172255.58">
# EKR: ctx is Del.
def handleNodeDelete(self, node):

    def on_conditional_branch():
        """
        Return `True` if node is part of a conditional body.
        """
        current = getattr(node, 'parent', None)
        while current:
            if isinstance(current, (ast.If, ast.While, ast.IfExp)):
                return True
            current = getattr(current, 'parent', None)
        return False

    name = getNodeName(node)
    if not name:
        return

    if on_conditional_branch():
        # We can not predict if this conditional branch is going to
        # be executed.
        return

    if isinstance(self.scope, FunctionScope) and name in self.scope.globals:
        self.scope.globals.remove(name)
    else:
        try:
            del self.scope[name]
        except KeyError:
            self.report(messages.UndefinedName, node, name)
</t>
<t tx="ekr.20160519172255.59">
def handleChildren(self, tree, omit=None):
    # EKR: iter_child_nodes uses _FieldsOrder class.
    global n_handleChildren ; n_handleChildren += 1
    
    assert not aft, g.callers()
    
    for node in iter_child_nodes(tree, omit=omit):
        self.handleNode(node, tree)
</t>
<t tx="ekr.20160519172255.6">def iterSourceCode(paths):
    """
    Iterate over all Python source files in C{paths}.

    @param paths: A list of paths.  Directories will be recursed into and
        any .py files found will be yielded.  Any non-directories will be
        yielded as-is.
    """
    for path in paths:
        if os.path.isdir(path):
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    if filename.endswith('.py'):
                        yield os.path.join(dirpath, filename)
        else:
            yield path
</t>
<t tx="ekr.20160519172255.60">
def isLiteralTupleUnpacking(self, node):
    if isinstance(node, ast.Assign):
        for child in node.targets + [node.value]:
            if not hasattr(child, 'elts'):
                return False
        return True
</t>
<t tx="ekr.20160519172255.61">
def isDocstring(self, node):
    """
    Determine if the given node is a docstring, as long as it is at the
    correct place in the node tree.
    """
    return isinstance(node, ast.Str) or (isinstance(node, ast.Expr) and
                                         isinstance(node.value, ast.Str))
</t>
<t tx="ekr.20160519172255.62">
def getDocstring(self, node):
    if isinstance(node, ast.Expr):
        node = node.value
    if not isinstance(node, ast.Str):
        return (None, None)
    # Computed incorrectly if the docstring has backslash
    doctest_lineno = node.lineno - node.s.count('\n') - 1
    return (node.s, doctest_lineno)
</t>
<t tx="ekr.20160519172255.63">
# null_trace_n = 0

def handleNode(self, node, parent):
    # EKR: this the general node visiter.
    # assert isinstance(node, (ast.AST, ast.AsyncWith)), repr(node)
    global n_pass_nodes, n_null_nodes
    assert node, g.callers()
    # The following will fail unless 0 &lt; self.pass_n &lt; 3
    n_pass_nodes[self.pass_n] += 1
    if self.offset and getattr(node, 'lineno', None) is not None:
        node.lineno += self.offset[0]
        node.col_offset += self.offset[1]
    # if self.traceTree:
        # print('  ' * self.nodeDepth(node) + node.__class__.__name__)
    if (self.futuresAllowed and
        not (isinstance(node, (ast.Module, ast.ImportFrom)) or self.isDocstring(node))
             # EKR: works regardless of new_module.
    ):
        self.futuresAllowed = False
    # EKR: getCommonAncestor uses node.depth.
    self.nodeDepth += 1
    node.depth = self.nodeDepth
    node.parent = parent
    if aft:
        handler = getattr(self, node.__class__.__name__)
        handler(node)
    else:
        # EKR: this is the only call to getNodeHandler.
        handler = self.getNodeHandler(node.__class__)
        handler(node)
    self.nodeDepth -= 1
    # if self.traceTree:
        # print('  ' * self.nodeDepth(node) + 'end ' + node.__class__.__name__)

_getDoctestExamples = doctest.DocTestParser().get_examples
</t>
<t tx="ekr.20160519172255.64">
def handleDoctests(self, node):

    try:
        (docstring, node_lineno) = self.getDocstring(node.body[0])
        examples = docstring and self._getDoctestExamples(docstring)
    except (ValueError, IndexError):
        # e.g. line 6 of the docstring for &lt;string&gt; has inconsistent
        # leading whitespace: ...
        return
    if not examples:
        return
    if 0:
        g.trace('=========', g.callers())
        g.trace('examples:', examples)
    node_offset = self.offset or (0, 0)
    name = getattr(node, 'name', None) # EKR
    self.pushScope(node, name, FunctionScope)
    if 0:
        print('')
        g.trace(self.offset, node, self.scopeStack)
    underscore_in_builtins = '_' in self.builtIns
    if not underscore_in_builtins:
        self.builtIns.add('_')
    for example in examples:
        try:
            tree = compile(example.source, "&lt;doctest&gt;", "exec", ast.PyCF_ONLY_AST)
        except SyntaxError:
            e = sys.exc_info()[1]
            position = (node_lineno + example.lineno + e.lineno,
                        example.indent + 4 + (e.offset or 0))
            self.report(messages.DoctestSyntaxError, node, position)
        else:
            self.offset = (node_offset[0] + node_lineno + example.lineno,
                           node_offset[1] + example.indent + 4)
            assert isinstance(tree, ast.Module)
            if aft:
                # Explicitly visit the module's children.
                for z in tree.body:
                    self.handleNode(z, tree)
            else:
                self.handleChildren(tree)
            self.offset = node_offset
    if not underscore_in_builtins:
        self.builtIns.remove('_')
    self.popScope()
</t>
<t tx="ekr.20160519172255.66">
def GLOBAL(self, node):
    """
    Keep track of globals declarations.
    """
    # In doctests, the global scope is an anonymous function at index 1.
    global_scope_index = 1 if self.withDoctest else 0
    global_scope = self.scopeStack[global_scope_index]

    # Ignore 'global' statement in global scope.
    if self.scope is not global_scope:

        # One 'global' statement can bind multiple (comma-delimited) names.
        for node_name in node.names:
            node_value = Assignment(node_name, node)

            # Remove UndefinedName messages already reported for this name.
            self.messages = [
                m for m in self.messages if
                    not isinstance(m, messages.UndefinedName) and
                    not isinstance(m, messages.ReturnOutsideFunction) and
                        # EKR: Real bug fix.
                    m.message_args[0] != node_name]

            # Bind name to global scope if it doesn't exist already.
            global_scope.setdefault(node_name, node_value)

            # Bind name to non-global scopes, but as already "used".
            node_value.used = (global_scope, node)
            for scope in self.scopeStack[global_scope_index + 1:]:
                scope[node_name] = node_value

if aft:
    Global = Nonlocal = GLOBAL

NONLOCAL = GLOBAL
</t>
<t tx="ekr.20160519172255.67">
# GeneratorExp(expr elt, comprehension* generators)
# SetComp(expr elt, comprehension* generators)

def GENERATOREXP(self, node):
    # EKR: always push a new scope.
    name = 'Generator: %s' % id(node)
    self.pushScope(node, name, GeneratorScope)
    if aft:
        # EKR: call generators first.
        for z in node.generators:
            self.handleNode(z, node)
        self.handleNode(node.elt, node)
    else:
        self.handleChildren(node)
    self.popScope()
    
if aft:
    SetComp = GeneratorExp = GENERATOREXP
    
# DictComp(expr key, expr value, comprehension* generators)
    
def DictComp(self, node):
    name = 'Generator: %s' % id(node)
    self.pushScope(node, name, GeneratorScope)
    if aft:
        # EKR: call generators first.
        for z in node.generators:
            self.handleNode(z, node)
        self.handleNode(node.key, node)
        self.handleNode(node.value, node)
    else:
        self.handleChildren(node)
    self.popScope()
    
def ListComp(self, node):
    # EKR: Push a new scope only in Python 3.
    name = 'Generator: %s' % id(node)
    if g.isPython3:
        self.pushScope(node, name, GeneratorScope)
    if aft:
        # EKR: call generators first.
        for z in node.generators:
            self.handleNode(z, node)
        self.handleNode(node.elt, node)
    else:
        self.handleChildren(node)
    if g.isPython3:
        self.popScope()

LISTCOMP = handleChildren if PY2 else GENERATOREXP
    
DICTCOMP = SETCOMP = GENERATOREXP
</t>
<t tx="ekr.20160519172255.68">
def NAME(self, node):
    """
    Handle occurrence of Name (which can be a load/store/delete access.)
    """
    # Locate the name in locals / function / globals scopes.
    if isinstance(node.ctx, (ast.Load, ast.AugLoad)):
        self.handleNodeLoad(node)
        if (node.id == 'locals' and
            isinstance(self.scope, FunctionScope) and
            isinstance(node.parent, ast.Call)
        ):
            # we are doing locals() call in current scope
            self.scope.usesLocals = True
                # EKR: why does this matter???
    elif isinstance(node.ctx, (ast.Store, ast.AugStore)):
        self.handleNodeStore(node)
    elif isinstance(node.ctx, ast.Del):
        self.handleNodeDelete(node)
    else:
        # must be a Param context -- this only happens for names in function
        # arguments, but these aren't dispatched through here
        raise RuntimeError("Got impossible expression context: %r" % (node.ctx,))
        
if aft:
    Name = NAME

</t>
<t tx="ekr.20160519172255.69">
def RETURN(self, node):
    
    # if isinstance(self.scope, ClassScope):
    if isinstance(self.scope, (ClassScope, ModuleScope)):
        # EKR: A real bug fix.
        self.report(messages.ReturnOutsideFunction, node)
        return
    if (
        node.value and
        hasattr(self.scope, 'returnValue') and
        not self.scope.returnValue
    ):
        self.scope.returnValue = node.value
    if node.value: # EKR
        self.handleNode(node.value, node)

if aft:
    Return = RETURN</t>
<t tx="ekr.20160519172255.7">def checkRecursive(paths, reporter):
    """
    Recursively check all source files in C{paths}.

    @param paths: A list of paths to Python source files and directories
        containing Python source files.
    @param reporter: A L{Reporter} where all of the warnings and errors
        will be reported to.
    @return: The number of warnings found.
    """
    warnings = 0
    for sourcePath in iterSourceCode(paths):
        warnings += checkPath(sourcePath, reporter)
    return warnings
</t>
<t tx="ekr.20160519172255.70">
def YIELD(self, node):
    self.scope.isGenerator = True
    self.handleNode(node.value, node)
    
if aft:
    Yield = Await = YieldFrom = YIELD

AWAIT = YIELDFROM = YIELD
</t>
<t tx="ekr.20160519172255.71">
def FUNCTIONDEF(self, node):
    
    global n_FunctionDef ; n_FunctionDef += 1
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    self.LAMBDA(node) # EKR: defer's traversal of the body!
    self.addBinding(node, FunctionDefinition(node.name, node))
    if self.withDoctest:
        self.deferFunction(lambda: self.handleDoctests(node))
if aft:
    FunctionDef = AsyncFunctionDef = FUNCTIONDEF

ASYNCFUNCTIONDEF = FUNCTIONDEF
</t>
<t tx="ekr.20160519172255.72">
def LAMBDA(self, node):
    
    # Pass 1: visit *only* annotations and defaults.
    annotations, args, defaults = self.get_function_args(node)
    for child in annotations + defaults:
        if child:
            self.handleNode(child, node)
    # EKR: The dog that isn't barking:
    # pass 1 defers traversing the def's/lambda's body!
    &lt;&lt; define runFunction &gt;&gt;
    self.deferFunction(runFunction)

if aft:
    Lambda = LAMBDA
</t>
<t tx="ekr.20160519172255.73">
def CLASSDEF(self, node):
    """
    Check names used in a class definition, including its decorators, base
    classes, and the body of its definition.  Additionally, add its name to
    the current scope.
    """
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    for baseNode in node.bases:
        self.handleNode(baseNode, node)
    if not PY2:
        for keywordNode in node.keywords:
            self.handleNode(keywordNode, node)
    self.pushScope(node, node.name, ClassScope)
    if self.withDoctest:
        self.deferFunction(lambda: self.handleDoctests(node))
    # EKR: Unlike def's &amp; lambda's, we *do* traverse the class's body.
    for stmt in node.body:
        self.handleNode(stmt, node)
    self.popScope()
    self.addBinding(node, ClassDefinition(node.name, node))
    
if aft:
    ClassDef = CLASSDEF
</t>
<t tx="ekr.20160519172255.74">
def AUGASSIGN(self, node):
    self.handleNodeLoad(node.target)
    self.handleNode(node.value, node)
    self.handleNode(node.target, node)

if aft:
    AugAssign = AUGASSIGN</t>
<t tx="ekr.20160519172255.75">
def IMPORT(self, node):
    for alias in node.names:
        name = alias.asname or alias.name
        importation = Importation(name, node)
        self.addBinding(node, importation)

if aft:
    Import = IMPORT
</t>
<t tx="ekr.20160519172255.76">
def IMPORTFROM(self, node):
    if node.module == '__future__':
        if not self.futuresAllowed:
            self.report(messages.LateFutureImport,
                        node, [n.name for n in node.names])
    else:
        self.futuresAllowed = False

    for alias in node.names:
        if alias.name == '*':
            self.scope.importStarred = True
            self.report(messages.ImportStarUsed, node, node.module)
            continue
        name = alias.asname or alias.name
        importation = Importation(name, node)
        if node.module == '__future__':
            importation.used = (self.scope, node)
        self.addBinding(node, importation)
        
if aft:
    ImportFrom = IMPORTFROM

</t>
<t tx="ekr.20160519172255.77">
def TRY(self, node):
    handler_names = []
    # List the exception handlers
    for handler in node.handlers:
        if isinstance(handler.type, ast.Tuple):
            for exc_type in handler.type.elts:
                handler_names.append(getNodeName(exc_type))
        elif handler.type:
            handler_names.append(getNodeName(handler.type))
    # Memorize the except handlers and process the body
    self.exceptHandlers.append(handler_names)
    for child in node.body:
        self.handleNode(child, node)
    self.exceptHandlers.pop()
    # Process the other nodes: "except:", "else:", "finally:"
    if aft:
        for field in ('handlers', 'orelse', 'finalbody'):
            for z in getattr(node, field, []):
                self.handleNode(z, node)
    else:
        self.handleChildren(node, omit='body')
    
if aft:
    Try = TryExcept = TRY

TRYEXCEPT = TRY
</t>
<t tx="ekr.20160519172255.78">
# Python 2: ExceptHandler(expr? type, expr? name, stmt* body)
# Python 3: ExceptHandler(expr? type, identifier? name, stmt* body)

def EXCEPTHANDLER(self, node):
    # 3.x: in addition to handling children, we must handle the name of
    # the exception, which is not a Name node, but a simple string.
    if aft:
        if g.isPython3:
            if isinstance(node.name, str):
                self.handleNodeStore(node)
        elif node.name:
            self.handleNode(node.name, node)
        if node.type:
            self.handleNode(node.type, node)
        for z in node.body:
            self.handleNode(z, node)
    else:
        if isinstance(node.name, str):
            self.handleNodeStore(node)  
        self.handleChildren(node)
    
if aft:
    ExceptHandler = EXCEPTHANDLER

</t>
<t tx="ekr.20160519172255.79">"""
Provide the class Message and its subclasses.
"""

@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20160519172255.8">def _exitOnSignal(sigName, message):
    """Handles a signal with sys.exit.

    Some of these signals (SIGPIPE, for example) don't exist or are invalid on
    Windows. So, ignore errors that might arise.
    """
    import signal

    try:
        sigNumber = getattr(signal, sigName)
    except AttributeError:
        # the signal constants defined in the signal module are defined by
        # whether the C library supports them or not. So, SIGPIPE might not
        # even be defined.
        return

    def handler(sig, f):
        sys.exit(message)

    try:
        signal.signal(sigNumber, handler)
    except ValueError:
        # It's also possible the signal is defined, but then it's invalid. In
        # this case, signal.signal raises ValueError.
        pass
</t>
<t tx="ekr.20160519172255.80">class Message(object):
    message = ''
    message_args = ()

    @others
</t>
<t tx="ekr.20160519172255.81">def __init__(self, filename, loc):
    self.filename = filename
    self.lineno = loc.lineno
    self.col = getattr(loc, 'col_offset', 0)
</t>
<t tx="ekr.20160519172255.82">def __str__(self):
    return '%s:%s: %s' % (self.filename, self.lineno,
                          self.message % self.message_args)
</t>
<t tx="ekr.20160519172255.83">class UnusedImport(Message):
    message = '%r imported but unused'

    @others
</t>
<t tx="ekr.20160519172255.84">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.85">class RedefinedWhileUnused(Message):
    message = 'redefinition of unused %r from line %r'

    @others
</t>
<t tx="ekr.20160519172255.86">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.87">class RedefinedInListComp(Message):
    message = 'list comprehension redefines %r from line %r'

    @others
</t>
<t tx="ekr.20160519172255.88">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.89">class ImportShadowedByLoopVar(Message):
    message = 'import %r from line %r shadowed by loop variable'

    @others
</t>
<t tx="ekr.20160519172255.9">def main(prog=None):
    """Entry point for the script "pyflakes"."""
    import optparse

    # Handle "Keyboard Interrupt" and "Broken pipe" gracefully
    _exitOnSignal('SIGINT', '... stopped')
    _exitOnSignal('SIGPIPE', 1)

    parser = optparse.OptionParser(prog=prog, version=__version__)
    (__, args) = parser.parse_args()
    reporter = modReporter._makeDefaultReporter()
    if args:
        warnings = checkRecursive(args, reporter)
    else:
        warnings = check(sys.stdin.read(), '&lt;stdin&gt;', reporter)
    raise SystemExit(warnings &gt; 0)
</t>
<t tx="ekr.20160519172255.90">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.91">class ImportStarUsed(Message):
    message = "'from %s import *' used; unable to detect undefined names"

    @others
</t>
<t tx="ekr.20160519172255.92">def __init__(self, filename, loc, modname):
    Message.__init__(self, filename, loc)
    self.message_args = (modname,)
</t>
<t tx="ekr.20160519172255.93">class UndefinedName(Message):
    message = 'undefined name %r'

    @others
</t>
<t tx="ekr.20160519172255.94">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.95">class DoctestSyntaxError(Message):
    message = 'syntax error in doctest'

    @others
</t>
<t tx="ekr.20160519172255.96">def __init__(self, filename, loc, position=None):
    Message.__init__(self, filename, loc)
    if position:
        (self.lineno, self.col) = position
    self.message_args = ()
</t>
<t tx="ekr.20160519172255.97">class UndefinedExport(Message):
    message = 'undefined name %r in __all__'

    @others
</t>
<t tx="ekr.20160519172255.98">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.99">class UndefinedLocal(Message):
    message = ('local variable %r (defined in enclosing scope on line %r) '
               'referenced before assignment')

    @others
</t>
<t tx="ekr.20160519172710.1">
# Binding and Definitions classes...</t>
<t tx="ekr.20160519172730.1">
# Scope classes...
</t>
<t tx="ekr.20160519172836.1">
ignore_kinds = {}

def ignore(self, node):
    
    # EKR: Ignoring a node is not strictly the same as not calling handleNode
    # because handleNode sets node.parent and node.depth fields.
    # However, these fields aren't used for ignored nodes.
    
    global n_ignore ; n_ignore += 1
    if aft:
        name = node.__class__.__name__
        if name not in self.ignore_kinds:
            self.ignore_kinds[name] = True
            g.trace(name, g.callers())

&lt;&lt; non-aft handlers &gt;&gt;
if aft:
    &lt;&lt; default node handlers &gt;&gt;
else:
    CONTINUE = BREAK = PASS = ignore
    NUM = STR = BYTES = ELLIPSIS = ignore

    # EKR: AstFullTraverser doesn't visit these nodes.
    # expression contexts are node instances too, though being constants
    LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore
    
    # EKR: AstFullTraverser doesn't visit these nodes.
    # same for operators
    AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \
        BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \
        EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = ignore
        
    # EKR: MatMult is new in Python 3.5
    MATMULT = ignore

    # "stmt" type nodes
    DELETE = PRINT = FOR = ASYNCFOR = WHILE = IF = WITH = WITHITEM = \
        ASYNCWITH = ASYNCWITHITEM = RAISE = TRYFINALLY = ASSERT = EXEC = \
        EXPR = ASSIGN = handleChildren
    
    # "expr" type nodes
    BOOLOP = BINOP = UNARYOP = IFEXP = DICT = SET = \
        COMPARE = CALL = REPR = ATTRIBUTE = SUBSCRIPT = LIST = TUPLE = \
        STARRED = NAMECONSTANT = handleChildren
    
    # "slice" type nodes
    SLICE = EXTSLICE = INDEX = handleChildren
    
    # additional node types
    COMPREHENSION = KEYWORD = handleChildren
</t>
<t tx="ekr.20160519173152.1">
# EKR: like visitors
</t>
<t tx="ekr.20160519173318.1"></t>
<t tx="ekr.20160519173339.1"></t>
<t tx="ekr.20160519180137.1">http://epydoc.sourceforge.net/manual-epytext.html

Epytext defines four types of inline markup that specify how text should be displayed:
    
I{...}: Italicized text.
B{...}: Bold-faced text.
C{...}: Source code or a Python identifier.
M{...}: A mathematical expression.

Also seen:
    
L{...}: </t>
<t tx="ekr.20160519180953.1">
if PY2:
    def getNodeType(node_class):
        # workaround str.upper() which is locale-dependent
        # return str(unicode(node_class.__name__).upper())
        return node_class.__name__.upper()
            # EKR: hehe: pyflakes complains about unicode.
else:
    def getNodeType(node_class):
        return node_class.__name__.upper()</t>
<t tx="ekr.20160519181035.1">
# Python &gt;= 3.3 uses ast.Try instead of (ast.TryExcept + ast.TryFinally)
# EKR: used only by differentForks
if PY32:
    def getAlternatives(n):
        if isinstance(n, (ast.If, ast.TryFinally)):
            return [n.body]
        if isinstance(n, ast.TryExcept):
            return [n.body + n.orelse] + [[hdl] for hdl in n.handlers]
else:
    def getAlternatives(n):
        if isinstance(n, ast.If):
            return [n.body]
        if isinstance(n, ast.Try):
            return [n.body + n.orelse] + [[hdl] for hdl in n.handlers]</t>
<t tx="ekr.20160519181348.1"></t>
<t tx="ekr.20160519182919.1"># handle iter before target, and generators before element
# fields = node_class._fields
fields = ['value', 'w', 'iter', 'z', 'x']

if 'iter' in fields:
    key_first = 'iter'.find
elif 'generators' in fields:
    key_first = 'generators'.find
else:
    key_first = 'value'.find

aList = tuple(sorted(fields, key=key_first, reverse=True))
print(aList)
print(['iter'.find(z) for z in fields])
</t>
<t tx="ekr.20160520081237.1"># g.cls()
if c.isChanged():
    import time
    c.save()
    time.sleep(0.1)
&lt;&lt; test switches &gt;&gt;
&lt;&lt; test imports &gt;&gt;
checker.test_scope = test_scope
checker.unit_test()
aft = checker.aft
print('aft: %s' % checker.aft)
compare_traverse = False and test_kind != 'resolve'
gc.collect() # Runs a full collection. Stabilizes timing statistics a bit.
stats = {}
test_list = [
&lt;&lt; define s_list &gt;&gt;
]
@others
if test_scope == 'test':
    for s in test_list:
        print('\n'.join(['%3s %s' % (i1+1, s1.rstrip())
            for i1, s1 in enumerate(s.splitlines())]))
        TestController().run_test(scope=test_scope, s=s)
        print('=' * 20)
else:
    TestController().run_test(scope=test_scope, s=None)
</t>
<t tx="ekr.20160520081827.1">def run_test(self, scope, s):
    
    stats = self.stats
    g_option_fn = None
    if scope == 'test':
        files = []
    else:
        g.trace('scope:', scope)
        files = leoTest.LinterTable().get_files_for_scope(scope, fn=g_option_fn)
        s = None
    t1 = time.clock()
    self.check_all(files, s)
    t2 = time.clock()
    if scope != 'test':
        self.print_stats(len(files), t1, t2)
</t>
<t tx="ekr.20160520082209.1">def check_all(self, files, s=None):
    '''Run pyflakes on all files.'''
    if s:
        fn = '&lt;test&gt;'
        tree = self.compile_string(fn, s)
        self.check_string(fn, s, tree)
    else:
        for fn in files:
            s = self.read_string(fn)
            if s and s.strip():
                tree = self.compile_string(fn, s)
                if compare_traverse:
                    self.traverse_tree(tree)
                    self.handle_tree(tree)
                self.check_string(fn, s, tree=tree) # EKR: added tree
            else:
                print('can not read:', fn)

</t>
<t tx="ekr.20160520102401.1">@nosearch</t>
<t tx="ekr.20160520160409.1">import ast
import gc
import imp
import sys
import time
import leo.core.leoGlobals as g
import leo.core.leoTest as leoTest
import api
import leo_ast
imp.reload(leo_ast)
if test_kind == 'resolve':
    import resolve
    imp.reload(resolve)
else:
    import api
    import checker
    import messages
    import reporter
    imp.reload(api)
    imp.reload(checker)
    imp.reload(messages)
    imp.reload(reporter)</t>
<t tx="ekr.20160520162336.1">def check_string(self, fn, s, tree):
    
    if test_kind == 'resolve':
        t1 = time.clock()
        sfn = g.shortFileName(fn)
        w = resolve.Resolve(tree, sfn)
        t2 = time.clock()
        self.stats['resolve'] = self.stats.get('resolve', 0.0) + t2 - t1
    else:
        t1 = time.clock()
        sfn = g.shortFileName(fn)
        r = reporter.Reporter(
            errorStream=sys.stderr,
            warningStream=sys.stderr,
            )
        errors = api.check(s, sfn, r, tree=tree)
        t2 = time.clock()
        self.stats['check'] = self.stats.get('check', 0.0) + t2 - t1
        if errors:
            print('pyflakes: %s error%s in %s' % (
                errors, g.plural(errors), fn))
</t>
<t tx="ekr.20160520162722.1">@others</t>
<t tx="ekr.20160520184945.1">'''AST (Abstract Syntax Tree) related classes.'''
import ast
import xml.sax.saxutils as saxutils
import textwrap
import token as token_module
import leo.core.leoGlobals as g
@others
@language python
@tabwidth -4
@pagewidth 70
</t>
<t tx="ekr.20160520184945.10">def do_types_list(self, attr, node, val):
    assert attr == 'typ'
    return '[%s]' % ','.join(
        [repr(z) for z in getattr(node, attr)])
</t>
<t tx="ekr.20160520184945.100"># BoolOp(boolop op, expr* values)

def do_BoolOp(self, node):
    for z in node.values:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.101">def do_Bytes(self, node):
    pass # Python 3.x only.
</t>
<t tx="ekr.20160520184945.102"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    # Call the nodes in token order.
    self.visit(node.func)
    for z in node.args:
        self.visit(z)
    for z in node.keywords:
        self.visit(z)
    if getattr(node, 'starargs', None):
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None):
        self.visit(node.kwargs)
</t>
<t tx="ekr.20160520184945.103"># Compare(expr left, cmpop* ops, expr* comparators)

def do_Compare(self, node):
    # Visit all nodes in token order.
    self.visit(node.left)
    assert len(node.ops) == len(node.comparators)
    for i in range(len(node.ops)):
        self.visit(node.ops[i])
        self.visit(node.comparators[i])
    # self.visit(node.left)
    # for z in node.comparators:
        # self.visit(z)
</t>
<t tx="ekr.20160520184945.104"># Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

def do_Eq(self, node): pass

def do_Gt(self, node): pass

def do_GtE(self, node): pass

def do_In(self, node): pass

def do_Is(self, node): pass

def do_IsNot(self, node): pass

def do_Lt(self, node): pass

def do_LtE(self, node): pass

def do_NotEq(self, node): pass

def do_NotIn(self, node): pass
</t>
<t tx="ekr.20160520184945.105"># comprehension (expr target, expr iter, expr* ifs)

def do_comprehension(self, node):
    self.visit(node.target) # A name.
    self.visit(node.iter) # An attribute.
    for z in node.ifs:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.106"># Dict(expr* keys, expr* values)

def do_Dict(self, node):
    # Visit all nodes in token order.
    assert len(node.keys) == len(node.values)
    for i in range(len(node.keys)):
        self.visit(node.keys[i])
        self.visit(node.values[i])
</t>
<t tx="ekr.20160520184945.107">def do_Ellipsis(self, node):
    pass
</t>
<t tx="ekr.20160520184945.108"># Expr(expr value)

def do_Expr(self, node):
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.109">def do_Expression(self, node):
    '''An inner expression'''
    self.visit(node.body)
</t>
<t tx="ekr.20160520184945.11">class AstFormatter(object):
    '''
    A class to recreate source code from an AST.

    This does not have to be perfect, but it should be close.

    Also supports optional annotations such as line numbers, file names, etc.
    '''
    # No ctor.
    # pylint: disable=consider-using-enumerate
    @others
</t>
<t tx="ekr.20160520184945.110">def do_ExtSlice(self, node):
    for z in node.dims:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.111"># GeneratorExp(expr elt, comprehension* generators)

def do_GeneratorExp(self, node):
    self.visit(node.elt)
    for z in node.generators:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.112"># IfExp(expr test, expr body, expr orelse)

def do_IfExp(self, node):
    self.visit(node.body)
    self.visit(node.test)
    self.visit(node.orelse)
</t>
<t tx="ekr.20160520184945.113">def do_Index(self, node):
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.114"># keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.115"># List(expr* elts, expr_context ctx)

def do_List(self, node):
    for z in node.elts:
        self.visit(z)
    # self.visit(node.ctx)
# ListComp(expr elt, comprehension* generators)

def do_ListComp(self, node):
    self.visit(node.elt)
    for z in node.generators:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.116"># Name(identifier id, expr_context ctx)

def do_Name(self, node):
    # self.visit(node.ctx)
    pass

def do_NameConstant(self, node): # Python 3 only.
    pass
    # s = repr(node.value)
    # return 'bool' if s in ('True', 'False') else s
</t>
<t tx="ekr.20160520184945.117">def do_Num(self, node):
    pass # Num(object n) # a number as a PyObject.
</t>
<t tx="ekr.20160520184945.118"># Python 2.x only
# Repr(expr value)

def do_Repr(self, node):
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.119">def do_Slice(self, node):
    if getattr(node, 'lower', None):
        self.visit(node.lower)
    if getattr(node, 'upper', None):
        self.visit(node.upper)
    if getattr(node, 'step', None):
        self.visit(node.step)
</t>
<t tx="ekr.20160520184945.12"></t>
<t tx="ekr.20160520184945.120">def do_Str(self, node):
    pass # represents a string constant.
</t>
<t tx="ekr.20160520184945.121"># Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    self.visit(node.value)
    self.visit(node.slice)
    # self.visit(node.ctx)
</t>
<t tx="ekr.20160520184945.122"># Tuple(expr* elts, expr_context ctx)

def do_Tuple(self, node):
    for z in node.elts:
        self.visit(z)
    # self.visit(node.ctx)
</t>
<t tx="ekr.20160520184945.123"># UnaryOp(unaryop op, expr operand)

def do_UnaryOp(self, node):
    # self.op_name(node.op)
    self.visit(node.operand)
</t>
<t tx="ekr.20160520184945.124"></t>
<t tx="ekr.20160520184945.125"># identifier name, identifier? asname)

def do_alias(self, node):
    # self.visit(node.name)
    # if getattr(node,'asname')
        # self.visit(node.asname)
    pass
</t>
<t tx="ekr.20160520184945.126"># Assert(expr test, expr? msg)

def do_Assert(self, node):
    self.visit(node.test)
    if node.msg:
        self.visit(node.msg)
</t>
<t tx="ekr.20160520184945.127"># Assign(expr* targets, expr value)

def do_Assign(self, node):
    for z in node.targets:
        self.visit(z)
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.128"># AugAssign(expr target, operator op, expr value)

def do_AugAssign(self, node):
    # g.trace('FT',Utils().format(node),g.callers())
    self.visit(node.target)
    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.129">def do_Break(self, tree):
    pass
</t>
<t tx="ekr.20160520184945.13"># def __call__(self,node):
    # '''__call__ method for AstFormatter class.'''
    # return self.format(node)
</t>
<t tx="ekr.20160520184945.130">def do_Continue(self, tree):
    pass
</t>
<t tx="ekr.20160520184945.131"># Delete(expr* targets)

def do_Delete(self, node):
    for z in node.targets:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.132"># Python 2: ExceptHandler(expr? type, expr? name, stmt* body)
# Python 3: ExceptHandler(expr? type, identifier? name, stmt* body)

def do_ExceptHandler(self, node):
    if node.type:
        self.visit(node.type)
    if node.name and isinstance(node.name, ast.Name):
        self.visit(node.name)
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.133"># Python 2.x only
# Exec(expr body, expr? globals, expr? locals)

def do_Exec(self, node):
    self.visit(node.body)
    if getattr(node, 'globals', None):
        self.visit(node.globals)
    if getattr(node, 'locals', None):
        self.visit(node.locals)
</t>
<t tx="ekr.20160520184945.134"># For(expr target, expr iter, stmt* body, stmt* orelse)

def do_For(self, node):
    self.visit(node.target)
    self.visit(node.iter)
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.135"># Global(identifier* names)

def do_Global(self, node):
    pass
</t>
<t tx="ekr.20160520184945.136"># If(expr test, stmt* body, stmt* orelse)

def do_If(self, node):
    self.visit(node.test)
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.137"># Import(alias* names)

def do_Import(self, node):
    pass
# ImportFrom(identifier? module, alias* names, int? level)

def do_ImportFrom(self, node):
    # for z in node.names:
        # self.visit(z)
    pass
</t>
<t tx="ekr.20160520184945.138"># Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    pass
</t>
<t tx="ekr.20160520184945.139">def do_Pass(self, node):
    pass
</t>
<t tx="ekr.20160520184945.14">def format(self, node):
    '''Format the node (or list of nodes) and its descendants.'''
    self.level = 0
    val = self.visit(node)
    return val and val.strip() or ''
</t>
<t tx="ekr.20160520184945.140"># Python 2.x only
# Print(expr? dest, expr* values, bool nl)

def do_Print(self, node):
    if getattr(node, 'dest', None):
        self.visit(node.dest)
    for expr in node.values:
        self.visit(expr)
</t>
<t tx="ekr.20160520184945.141"># Raise(expr? type, expr? inst, expr? tback)

def do_Raise(self, node):
    if getattr(node, 'type', None):
        self.visit(node.type)
    if getattr(node, 'inst', None):
        self.visit(node.inst)
    if getattr(node, 'tback', None):
        self.visit(node.tback)
</t>
<t tx="ekr.20160520184945.142"># Return(expr? value)

def do_Return(self, node):
    if node.value:
        self.visit(node.value)
</t>
<t tx="ekr.20160520184945.143"># Starred(expr value, expr_context ctx)

def do_Starred(self, node):

    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.144"># Python 3 only: Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.handlers:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
    for z in node.finalbody:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.145"># TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)

def do_TryExcept(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.handlers:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.146"># TryFinally(stmt* body, stmt* finalbody)

def do_TryFinally(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.finalbody:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.147"># While(expr test, stmt* body, stmt* orelse)

def do_While(self, node):
    self.visit(node.test) # Bug fix: 2013/03/23.
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.148"># 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node):
    if getattr(node, 'context_expr', None):
        self.visit(node.context_expr)
    if getattr(node, 'optional_vars', None):
        self.visit(node.optional_vars)
    if getattr(node, 'items', None): # Python 3.
        for item in node.items:
            self.visit(item.context_expr)
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars:
                        self.visit(z)
                except TypeError: # Not iterable.
                    self.visit(item.optional_vars)
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.149">#  Yield(expr? value)

def do_Yield(self, node):
    if node.value:
        self.visit(node.value)
</t>
<t tx="ekr.20160520184945.15">def visit(self, node):
    '''Return the formatted version of an Ast node, or list of Ast nodes.'''
    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])
    elif node is None:
        return 'None'
    else:
        assert isinstance(node, ast.AST), node.__class__.__name__
        method_name = 'do_' + node.__class__.__name__
        method = getattr(self, method_name)
        s = method(node)
        assert g.isString(s), type(s)
        return s
</t>
<t tx="ekr.20160520184945.150"># YieldFrom(expr value)

def do_YieldFrom(self, node):

    self.visit(node.value)
</t>
<t tx="ekr.20160520184945.151">def visit(self, node):
    '''Visit a *single* ast node.  Visitors are responsible for visiting children!'''
    assert isinstance(node, ast.AST), node.__class__.__name__
    trace = False
    # Visit the children with the new parent.
    old_parent = self.parent
    self.parent = node # Bug fix: 2016/05/18.
    class_name = node.__class__.__name__
    method_name = 'do_' + node.__class__.__name__
    method = getattr(self, method_name)
    # if trace: g.trace(class_name)
    val = method(node)
    self.parent = old_parent
    return val
    
# def do_nothing(self, node):
    # pass
    
# def get_visitor(self, class_name):
    # '''Compute the method and put it in self.d.'''
    # method_name = 'do_' + class_name
    # if hasattr(self, method_name):
        # # g.trace(method_name)
        # method = getattr(self, method_name)
    # else:
        # g.trace('no visitor for', class_name)
        # method = self.do_nothing
    # self.d[class_name] = method
    # assert method
    # return method

def visit_children(self, node):
    assert False, 'must visit children explicitly'
</t>
<t tx="ekr.20160520184945.152">def visit_list(self, aList):
    '''Visit all ast nodes in aList.'''
    assert isinstance(aList, (list, tuple)), repr(aList)
    for z in aList:
        self.visit(z)
    return None
</t>
<t tx="ekr.20160520184945.153">class AstPatternFormatter(AstFormatter):
    '''
    A subclass of AstFormatter that replaces values of constants by Bool,
    Bytes, Int, Name, Num or Str.
    '''
    # No ctor.
    @others
</t>
<t tx="ekr.20160520184945.154"># Return generic markers allow better pattern matches.

def do_BoolOp(self, node): # Python 2.x only.
    return 'Bool'

def do_Bytes(self, node): # Python 3.x only.
    return 'Bytes' # return str(node.s)

def do_Name(self, node):
    return 'Bool' if node.id in ('True', 'False') else node.id
    
def do_NameConstant(self, node): # Python 3 only.
    s = repr(node.value)
    return 'bool' if s in ('True', 'False') else s

def do_Num(self, node):
    return 'Num' # return repr(node.n)

def do_Str(self, node):
    '''This represents a string constant.'''
    return 'Str' # return repr(node.s)
</t>
<t tx="ekr.20160520184945.16"></t>
<t tx="ekr.20160520184945.17"># 2: ClassDef(identifier name, expr* bases,
#             stmt* body, expr* decorator_list)
# 3: ClassDef(identifier name, expr* bases,
#             keyword* keywords, expr? starargs, expr? kwargs
#             stmt* body, expr* decorator_list)
#
# keyword arguments supplied to call (NULL identifier for **kwargs)
# keyword = (identifier? arg, expr value)

def do_ClassDef(self, node):

    result = []
    name = node.name # Only a plain string is valid.
    bases = [self.visit(z) for z in node.bases] if node.bases else []
    if getattr(node, 'keywords', None): # Python 3
        for keyword in node.keywords:
            bases.append('%s=%s' % (keyword.arg, self.visit(keyword.value)))
    if getattr(node, 'starargs', None): # Python 3
        bases.append('*%s', self.visit(node.starargs))
    if getattr(node, 'kwargs', None): # Python 3
        bases.append('*%s', self.visit(node.kwargs))
    if bases:
        result.append(self.indent('class %s(%s):\n' % (name, ','.join(bases))))
    else:
        result.append(self.indent('class %s:\n' % name))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.18"># 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node):
    '''Format a FunctionDef node.'''
    result = []
    if node.decorator_list:
        for z in node.decorator_list:
            result.append('@%s\n' % self.visit(z))
    name = node.name # Only a plain string is valid.
    args = self.visit(node.args) if node.args else ''
    if getattr(node, 'returns', None): # Python 3.
        returns = self.visit(node.returns)
        result.append(self.indent('def %s(%s): -&gt; %s\n' % (name, args, returns)))
    else:
        result.append(self.indent('def %s(%s):\n' % (name, args)))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.19">def do_Interactive(self, node):
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160520184945.2">class AstDumper(object):
    '''
    Return a formatted dump (a string) of the AST node.

    Adapted from Python's ast.dump.

    annotate_fields:    True: show names of fields (can't eval the dump).
    disabled_field:     List of names of fields not to show: e.g. ['ctx',]
    include_attributes: True: show line numbers and column offsets.
    indent:             Number of spaces for each indent.
    '''
    @others
</t>
<t tx="ekr.20160520184945.20">def do_Module(self, node):
    assert 'body' in node._fields
    result = ''.join([self.visit(z) for z in node.body])
    return result # 'module:\n%s' % (result)
</t>
<t tx="ekr.20160520184945.21">def do_Lambda(self, node):
    return self.indent('lambda %s: %s' % (
        self.visit(node.args),
        self.visit(node.body)))
</t>
<t tx="ekr.20160520184945.22"></t>
<t tx="ekr.20160520184945.23">def do_Expr(self, node):
    '''An outer expression: must be indented.'''
    return self.indent('%s\n' % self.visit(node.value))
</t>
<t tx="ekr.20160520184945.24">def do_Expression(self, node):
    '''An inner expression: do not indent.'''
    return '%s\n' % self.visit(node.body)
</t>
<t tx="ekr.20160520184945.25">def do_GeneratorExp(self, node):
    elt = self.visit(node.elt) or ''
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] # Kludge: probable bug.
    return '&lt;gen %s for %s&gt;' % (elt, ','.join(gens))
</t>
<t tx="ekr.20160520184945.252">class TokenSync(object):
    '''A class to sync and remember tokens.'''
    # To do: handle comments, line breaks...
    @others
</t>
<t tx="ekr.20160520184945.253">def __init__(self, s, tokens):
    '''Ctor for TokenSync class.'''
    assert isinstance(tokens, list) # Not a generator.
    self.s = s
    self.first_leading_line = None
    self.lines = [z.rstrip() for z in g.splitLines(s)]
    # Order is important from here on...
    self.nl_token = self.make_nl_token()
    self.line_tokens = self.make_line_tokens(tokens)
    self.blank_lines = self.make_blank_lines()
    self.string_tokens = self.make_string_tokens()
    self.ignored_lines = self.make_ignored_lines()
</t>
<t tx="ekr.20160520184945.254">def make_blank_lines(self):
    '''Return of list of line numbers of blank lines.'''
    result = []
    for i, aList in enumerate(self.line_tokens):
        # if any([self.token_kind(z) == 'nl' for z in aList]):
        if len(aList) == 1 and self.token_kind(aList[0]) == 'nl':
            result.append(i)
    return result
</t>
<t tx="ekr.20160520184945.255">def make_ignored_lines(self):
    '''
    Return a copy of line_tokens containing ignored lines,
    that is, full-line comments or blank lines.
    These are the lines returned by leading_lines().
    '''
    result = []
    for i, aList in enumerate(self.line_tokens):
        for z in aList:
            if self.is_line_comment(z):
                result.append(z)
                break
        else:
            if i in self.blank_lines:
                result.append(self.nl_token)
            else:
                result.append(None)
    assert len(result) == len(self.line_tokens)
    for i, aList in enumerate(result):
        if aList:
            self.first_leading_line = i
            break
    else:
        self.first_leading_line = len(result)
    return result
</t>
<t tx="ekr.20160520184945.256">def make_line_tokens(self, tokens):
    '''
    Return a list of lists of tokens for each list in self.lines.
    The strings in self.lines may end in a backslash, so care is needed.
    '''
    trace = False
    n, result = len(self.lines), []
    for i in range(0, n + 1):
        result.append([])
    for token in tokens:
        t1, t2, t3, t4, t5 = token
        kind = token_module.tok_name[t1].lower()
        srow, scol = t3
        erow, ecol = t4
        line = erow - 1 if kind == 'string' else srow - 1
        result[line].append(token)
        if trace: g.trace('%3s %s' % (line, self.dump_token(token)))
    assert len(self.lines) + 1 == len(result), len(result)
    return result
</t>
<t tx="ekr.20160520184945.257">def make_nl_token(self):
    '''Return a newline token with '\n' as both val and raw_val.'''
    t1 = token_module.NEWLINE
    t2 = '\n'
    t3 = (0, 0) # Not used.
    t4 = (0, 0) # Not used.
    t5 = '\n'
    return t1, t2, t3, t4, t5
</t>
<t tx="ekr.20160520184945.258">def make_string_tokens(self):
    '''Return a copy of line_tokens containing only string tokens.'''
    result = []
    for aList in self.line_tokens:
        result.append([z for z in aList if self.token_kind(z) == 'string'])
    assert len(result) == len(self.line_tokens)
    return result
</t>
<t tx="ekr.20160520184945.259">def check_strings(self):
    '''Check that all strings have been consumed.'''
    # g.trace(len(self.string_tokens))
    for i, aList in enumerate(self.string_tokens):
        if aList:
            g.trace('warning: line %s. unused strings: %s' % (i, aList))
</t>
<t tx="ekr.20160520184945.26">def do_AugLoad(self, node):
    return 'AugLoad'

def do_Del(self, node):
    return 'Del'

def do_Load(self, node):
    return 'Load'

def do_Param(self, node):
    return 'Param'

def do_Store(self, node):
    return 'Store'
</t>
<t tx="ekr.20160520184945.260">def dump_token(self, token, verbose=False):
    '''Dump the token. It is either a string or a 5-tuple.'''
    if g.isString(token):
        return token
    else:
        t1, t2, t3, t4, t5 = token
        kind = g.toUnicode(token_module.tok_name[t1].lower())
        # raw_val = g.toUnicode(t5)
        val = g.toUnicode(t2)
        if verbose:
            return 'token: %10s %r' % (kind, val)
        else:
            return val
</t>
<t tx="ekr.20160520184945.261">def is_line_comment(self, token):
    '''Return True if the token represents a full-line comment.'''
    t1, t2, t3, t4, t5 = token
    kind = token_module.tok_name[t1].lower()
    raw_val = t5
    return kind == 'comment' and raw_val.lstrip().startswith('#')
</t>
<t tx="ekr.20160520184945.262">def join(self, aList, sep=','):
    '''return the items of the list joined by sep string.'''
    tokens = []
    for i, token in enumerate(aList or []):
        tokens.append(token)
        if i &lt; len(aList) - 1:
            tokens.append(sep)
    return tokens
</t>
<t tx="ekr.20160520184945.263">def last_node(self, node):
    '''Return the node of node's tree with the largest lineno field.'''

    class LineWalker(ast.NodeVisitor):

        def __init__(self):
            '''Ctor for LineWalker class.'''
            self.node = None
            self.lineno = -1

        def visit(self, node):
            '''LineWalker.visit.'''
            if hasattr(node, 'lineno'):
                if node.lineno &gt; self.lineno:
                    self.lineno = node.lineno
                    self.node = node
            if isinstance(node, list):
                for z in node:
                    self.visit(z)
            else:
                self.generic_visit(node)

    w = LineWalker()
    w.visit(node)
    return w.node
</t>
<t tx="ekr.20160520184945.264">def leading_lines(self, node):
    '''Return a list of the preceding comment and blank lines'''
    # This can be called on arbitrary nodes.
    trace = False
    leading = []
    if hasattr(node, 'lineno'):
        i, n = self.first_leading_line, node.lineno
        while i &lt; n:
            token = self.ignored_lines[i]
            if token:
                s = self.token_raw_val(token).rstrip() + '\n'
                leading.append(s)
                if trace: g.trace('%11s: %s' % (i, s.rstrip()))
            i += 1
        self.first_leading_line = i
    return leading
</t>
<t tx="ekr.20160520184945.265">def leading_string(self, node):
    '''Return a string containing all lines preceding node.'''
    return ''.join(self.leading_lines(node))
</t>
<t tx="ekr.20160520184945.266">def line_at(self, node, continued_lines=True):
    '''Return the lines at the node, possibly including continuation lines.'''
    n = getattr(node, 'lineno', None)
    if n is None:
        return '&lt;no line&gt; for %s' % node.__class__.__name__
    elif continued_lines:
        aList, n = [], n - 1
        while n &lt; len(self.lines):
            s = self.lines[n]
            if s.endswith('\\'):
                aList.append(s[: -1])
                n += 1
            else:
                aList.append(s)
                break
        return ''.join(aList)
    else:
        return self.lines[n - 1]
</t>
<t tx="ekr.20160520184945.267">def sync_string(self, node):
    '''Return the spelling of the string at the given node.'''
    # g.trace('%-10s %2s: %s' % (' ', node.lineno, self.line_at(node)))
    n = node.lineno
    tokens = self.string_tokens[n - 1]
    if tokens:
        token = tokens.pop(0)
        self.string_tokens[n - 1] = tokens
        return self.token_val(token)
    else:
        g.trace('===== underflow', n, node.s)
        return node.s
</t>
<t tx="ekr.20160520184945.268">def token_kind(self, token):
    '''Return the token's type.'''
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(token_module.tok_name[t1].lower())

def token_raw_val(self, token):
    '''Return the value of the token.'''
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(t5)

def token_val(self, token):
    '''Return the raw value of the token.'''
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(t2)
</t>
<t tx="ekr.20160520184945.269">def tokens_for_statement(self, node):
    assert isinstance(node, ast.AST), node
    name = node.__class__.__name__
    if hasattr(node, 'lineno'):
        tokens = self.line_tokens[node.lineno - 1]
        g.trace(' '.join([self.dump_token(z) for z in tokens]))
    else:
        g.trace('no lineno', name)
</t>
<t tx="ekr.20160520184945.27"></t>
<t tx="ekr.20160520184945.270">def trailing_comment(self, node):
    '''
    Return a string containing the trailing comment for the node, if any.
    The string always ends with a newline.
    '''
    if hasattr(node, 'lineno'):
        return self.trailing_comment_at_lineno(node.lineno)
    else:
        g.trace('no lineno', node.__class__.__name__, g.callers())
        return '\n'
</t>
<t tx="ekr.20160520184945.271">def trailing_comment_at_lineno(self, lineno):
    '''Return any trailing comment at the given node.lineno.'''
    trace = False
    tokens = self.line_tokens[lineno - 1]
    for token in tokens:
        if self.token_kind(token) == 'comment':
            raw_val = self.token_raw_val(token).rstrip()
            if not raw_val.strip().startswith('#'):
                val = self.token_val(token).rstrip()
                s = ' %s\n' % val
                if trace: g.trace(lineno, s.rstrip(), g.callers())
                return s
    return '\n'
</t>
<t tx="ekr.20160520184945.272">def trailing_lines(self):
    '''return any remaining ignored lines.'''
    trace = False
    trailing = []
    i = self.first_leading_line
    while i &lt; len(self.ignored_lines):
        token = self.ignored_lines[i]
        if token:
            s = self.token_raw_val(token).rstrip() + '\n'
            trailing.append(s)
            if trace: g.trace('%11s: %s' % (i, s.rstrip()))
        i += 1
    self.first_leading_line = i
    return trailing
</t>
<t tx="ekr.20160520184945.28"># 2: arguments = (expr* args, identifier? vararg, identifier?
#                arg? kwarg, expr* defaults)
# 3: arguments = (arg*  args, arg? vararg,
#                arg* kwonlyargs, expr* kw_defaults,
#                arg? kwarg, expr* defaults)

def do_arguments(self, node):
    '''Format the arguments node.'''
    kind = self.kind(node)
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    args2 = []
    n_plain = len(args) - len(defaults)
    for i in range(len(args)):
        if i &lt; n_plain:
            args2.append(args[i])
        else:
            args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
    if g.isPython3:
        args  = [self.visit(z) for z in node.kwonlyargs]
        defaults = [self.visit(z) for z in node.kw_defaults]
        n_plain = len(args) - len(defaults)
        for i in range(len(args)):
            if i &lt; n_plain:
                args2.append(args[i])
            else:
                args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
        # Add the vararg and kwarg expressions.
        vararg = getattr(node, 'vararg', None)
        if vararg: args2.append('*' + self.visit(vararg))
        kwarg = getattr(node, 'kwarg', None)
        if kwarg: args2.append('**' + self.visit(kwarg))
    else:
        # Add the vararg and kwarg names.
        name = getattr(node, 'vararg', None)
        if name: args2.append('*' + name)
        name = getattr(node, 'kwarg', None)
        if name: args2.append('**' + name)
    return ','.join(args2)
</t>
<t tx="ekr.20160520184945.29"># 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if getattr(node, 'annotation', None):
        return self.visit(node.annotation)
    else:
        return ''
</t>
<t tx="ekr.20160520184945.3">def __init__(self, u, annotate_fields, disabled_fields, format, include_attributes, indent_ws):
    '''Ctor for AstDumper class.'''
    self.u = u
    self.annotate_fields = annotate_fields
    self.disabled_fields = disabled_fields
    self.format = format
    self.include_attributes = include_attributes
    self.indent_ws = indent_ws
</t>
<t tx="ekr.20160520184945.30"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    return '%s.%s' % (
        self.visit(node.value),
        node.attr) # Don't visit node.attr: it is always a string.
</t>
<t tx="ekr.20160520184945.31">def do_Bytes(self, node): # Python 3.x only.
    assert g.isPython3
    return str(node.s)
</t>
<t tx="ekr.20160520184945.32"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    # g.trace(node,Utils().dump_ast(node))
    func = self.visit(node.func)
    args = [self.visit(z) for z in node.args]
    for z in node.keywords:
        # Calls f.do_keyword.
        args.append(self.visit(z))
    if getattr(node, 'starargs', None):
        args.append('*%s' % (self.visit(node.starargs)))
    if getattr(node, 'kwargs', None):
        args.append('**%s' % (self.visit(node.kwargs)))
    args = [z for z in args if z] # Kludge: Defensive coding.
    return '%s(%s)' % (func, ','.join(args))
</t>
<t tx="ekr.20160520184945.33"># keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    value = self.visit(node.value)
    # This is a keyword *arg*, not a Python keyword!
    return '%s=%s' % (node.arg, value)
</t>
<t tx="ekr.20160520184945.34">def do_comprehension(self, node):
    result = []
    name = self.visit(node.target) # A name.
    it = self.visit(node.iter) # An attribute.
    result.append('%s in %s' % (name, it))
    ifs = [self.visit(z) for z in node.ifs]
    if ifs:
        result.append(' if %s' % (''.join(ifs)))
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.35">def do_Dict(self, node):
    result = []
    keys = [self.visit(z) for z in node.keys]
    values = [self.visit(z) for z in node.values]
    if len(keys) == len(values):
        result.append('{\n' if keys else '{')
        items = []
        for i in range(len(keys)):
            items.append('  %s:%s' % (keys[i], values[i]))
        result.append(',\n'.join(items))
        result.append('\n}' if keys else '}')
    else:
        print('Error: f.Dict: len(keys) != len(values)\nkeys: %s\nvals: %s' % (
            repr(keys), repr(values)))
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.36">def do_Ellipsis(self, node):
    return '...'
</t>
<t tx="ekr.20160520184945.37">def do_ExtSlice(self, node):
    return ':'.join([self.visit(z) for z in node.dims])
</t>
<t tx="ekr.20160520184945.38">def do_Index(self, node):
    return self.visit(node.value)
</t>
<t tx="ekr.20160520184945.39">def do_List(self, node):
    # Not used: list context.
    # self.visit(node.ctx)
    elts = [self.visit(z) for z in node.elts]
    elts = [z for z in elts if z] # Defensive.
    return '[%s]' % ','.join(elts)
</t>
<t tx="ekr.20160520184945.4">def dump(self, node, level=0):
    sep1 = '\n%s' % (self.indent_ws * (level + 1))
    if isinstance(node, ast.AST):
        fields = [(a, self.dump(b, level + 1)) for a, b in self.get_fields(node)]
            # ast.iter_fields(node)]
        if self.include_attributes and node._attributes:
            fields.extend([(a, self.dump(getattr(node, a), level + 1))
                for a in node._attributes])
        # Not used at present.
        # aList = self.extra_attributes(node)
        # if aList: fields.extend(aList)
        if self.annotate_fields:
            aList = ['%s=%s' % (a, b) for a, b in fields]
        else:
            aList = [b for a, b in fields]
        compressed = not any([isinstance(b, list) and len(b) &gt; 1 for a, b in fields])
        name = node.__class__.__name__
        if compressed and len(','.join(aList)) &lt; 100:
            return '%s(%s)' % (name, ','.join(aList))
        else:
            sep = '' if len(aList) &lt;= 1 else sep1
            return '%s(%s%s)' % (name, sep, sep1.join(aList))
    elif isinstance(node, list):
        compressed = not any([isinstance(z, list) and len(z) &gt; 1 for z in node])
        sep = '' if compressed and len(node) &lt;= 1 else sep1
        return '[%s]' % ''.join(
            ['%s%s' % (sep, self.dump(z, level + 1)) for z in node])
    else:
        return repr(node)
</t>
<t tx="ekr.20160520184945.40">def do_ListComp(self, node):
    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] # Kludge: probable bug.
    return '%s for %s' % (elt, ''.join(gens))
</t>
<t tx="ekr.20160520184945.41">def do_Name(self, node):
    return node.id

def do_NameConstant(self, node): # Python 3 only.
    s = repr(node.value)
    return 'bool' if s in ('True', 'False') else s
</t>
<t tx="ekr.20160520184945.42">def do_Num(self, node):
    return repr(node.n)
</t>
<t tx="ekr.20160520184945.43"># Python 2.x only

def do_Repr(self, node):
    return 'repr(%s)' % self.visit(node.value)
</t>
<t tx="ekr.20160520184945.44">def do_Slice(self, node):
    lower, upper, step = '', '', ''
    if getattr(node, 'lower', None) is not None:
        lower = self.visit(node.lower)
    if getattr(node, 'upper', None) is not None:
        upper = self.visit(node.upper)
    if getattr(node, 'step', None) is not None:
        step = self.visit(node.step)
    if step:
        return '%s:%s:%s' % (lower, upper, step)
    else:
        return '%s:%s' % (lower, upper)
</t>
<t tx="ekr.20160520184945.45">def do_Str(self, node):
    '''This represents a string constant.'''
    return repr(node.s)
</t>
<t tx="ekr.20160520184945.46"># Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    value = self.visit(node.value)
    the_slice = self.visit(node.slice)
    return '%s[%s]' % (value, the_slice)
</t>
<t tx="ekr.20160520184945.47">def do_Tuple(self, node):
    elts = [self.visit(z) for z in node.elts]
    return '(%s)' % ','.join(elts)
</t>
<t tx="ekr.20160520184945.48"></t>
<t tx="ekr.20160520184945.49">def do_BinOp(self, node):
    return '%s%s%s' % (
        self.visit(node.left),
        self.op_name(node.op),
        self.visit(node.right))
</t>
<t tx="ekr.20160520184945.5">def get_fields(self, node):
    fields = [z for z in ast.iter_fields(node)]
    result = []
    for a, b in fields:
        if a not in self.disabled_fields:
            if b not in (None, []):
                result.append((a, b),)
    return result
</t>
<t tx="ekr.20160520184945.50">def do_BoolOp(self, node):
    op_name = self.op_name(node.op)
    values = [self.visit(z) for z in node.values]
    return op_name.join(values)
</t>
<t tx="ekr.20160520184945.51">def do_Compare(self, node):
    result = []
    lt = self.visit(node.left)
    # ops   = [self.visit(z) for z in node.ops]
    ops = [self.op_name(z) for z in node.ops]
    comps = [self.visit(z) for z in node.comparators]
    result.append(lt)
    if len(ops) == len(comps):
        for i in range(len(ops)):
            result.append('%s%s' % (ops[i], comps[i]))
    else:
        g.trace('ops', repr(ops), 'comparators', repr(comps))
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.52">def do_UnaryOp(self, node):
    return '%s%s' % (
        self.op_name(node.op),
        self.visit(node.operand))
</t>
<t tx="ekr.20160520184945.53">def do_IfExp(self, node):
    return '%s if %s else %s ' % (
        self.visit(node.body),
        self.visit(node.test),
        self.visit(node.orelse))
</t>
<t tx="ekr.20160520184945.54"></t>
<t tx="ekr.20160520184945.55">def do_Assert(self, node):
    test = self.visit(node.test)
    if getattr(node, 'msg', None):
        message = self.visit(node.msg)
        return self.indent('assert %s, %s' % (test, message))
    else:
        return self.indent('assert %s' % test)
</t>
<t tx="ekr.20160520184945.56">def do_Assign(self, node):
    return self.indent('%s=%s\n' % (
        '='.join([self.visit(z) for z in node.targets]),
        self.visit(node.value)))
</t>
<t tx="ekr.20160520184945.57">def do_AugAssign(self, node):
    return self.indent('%s%s=%s\n' % (
        self.visit(node.target),
        self.op_name(node.op), # Bug fix: 2013/03/08.
        self.visit(node.value)))
</t>
<t tx="ekr.20160520184945.58">def do_Break(self, node):
    return self.indent('break\n')
</t>
<t tx="ekr.20160520184945.59">def do_Continue(self, node):
    return self.indent('continue\n')
</t>
<t tx="ekr.20160520184945.6">def extra_attributes(self, node):
    '''Return the tuple (field,repr(field)) for all extra fields.'''
    d = {
        # 'e': self.do_repr,
        # 'cache':self.do_cache_list,
        # 'reach':self.do_reaching_list,
        # 'typ':  self.do_types_list,
    }
    aList = []
    for attr in sorted(d.keys()):
        if hasattr(node, attr):
            val = getattr(node, attr)
            f = d.get(attr)
            s = f(attr, node, val)
            if s:
                aList.append((attr, s),)
    return aList
</t>
<t tx="ekr.20160520184945.60">def do_Delete(self, node):
    targets = [self.visit(z) for z in node.targets]
    return self.indent('del %s\n' % ','.join(targets))
</t>
<t tx="ekr.20160520184945.61">def do_ExceptHandler(self, node):
    result = []
    result.append(self.indent('except'))
    if getattr(node, 'type', None):
        result.append(' %s' % self.visit(node.type))
    if getattr(node, 'name', None):
        if isinstance(node.name, ast.AST):
            result.append(' as %s' % self.visit(node.name))
        else:
            result.append(' as %s' % node.name) # Python 3.x.
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.62"># Python 2.x only

def do_Exec(self, node):
    body = self.visit(node.body)
    args = [] # Globals before locals.
    if getattr(node, 'globals', None):
        args.append(self.visit(node.globals))
    if getattr(node, 'locals', None):
        args.append(self.visit(node.locals))
    if args:
        return self.indent('exec %s in %s\n' % (
            body, ','.join(args)))
    else:
        return self.indent('exec %s\n' % (body))
</t>
<t tx="ekr.20160520184945.63">def do_For(self, node):
    result = []
    result.append(self.indent('for %s in %s:\n' % (
        self.visit(node.target),
        self.visit(node.iter))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.64">def do_Global(self, node):
    return self.indent('global %s\n' % (
        ','.join(node.names)))
</t>
<t tx="ekr.20160520184945.65">def do_If(self, node):
    result = []
    result.append(self.indent('if %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.66">def do_Import(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('import %s\n' % (
        ','.join(names)))
</t>
<t tx="ekr.20160520184945.67">def get_import_names(self, node):
    '''Return a list of the the full file names in the import statement.'''
    result = []
    for ast2 in node.names:
        if self.kind(ast2) == 'alias':
            data = ast2.name, ast2.asname
            result.append(data)
        else:
            g.trace('unsupported kind in Import.names list', self.kind(ast2))
    return result
</t>
<t tx="ekr.20160520184945.68">def do_ImportFrom(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('from %s import %s\n' % (
        node.module,
        ','.join(names)))
</t>
<t tx="ekr.20160520184945.69"># Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    return self.indent('nonlocal %s\n' % ', '.join(node.names))
</t>
<t tx="ekr.20160520184945.7">def do_cache_list(self, attr, node, val):
    return self.u.dump_cache(node)
</t>
<t tx="ekr.20160520184945.70">def do_Pass(self, node):
    return self.indent('pass\n')
</t>
<t tx="ekr.20160520184945.71"># Python 2.x only

def do_Print(self, node):
    vals = []
    for z in node.values:
        vals.append(self.visit(z))
    if getattr(node, 'dest', None):
        vals.append('dest=%s' % self.visit(node.dest))
    if getattr(node, 'nl', None):
        # vals.append('nl=%s' % self.visit(node.nl))
        vals.append('nl=%s' % node.nl)
    return self.indent('print(%s)\n' % (
        ','.join(vals)))
</t>
<t tx="ekr.20160520184945.72">def do_Raise(self, node):
    args = []
    for attr in ('type', 'inst', 'tback'):
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    if args:
        return self.indent('raise %s\n' % (
            ','.join(args)))
    else:
        return self.indent('raise\n')
</t>
<t tx="ekr.20160520184945.73">def do_Return(self, node):
    if node.value:
        return self.indent('return %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('return\n')
</t>
<t tx="ekr.20160520184945.74"># Starred(expr value, expr_context ctx)

def do_Starred(self, node):

    return '*' + self.visit(node.value)
</t>
<t tx="ekr.20160520184945.75"># def do_Suite(self,node):
    # for z in node.body:
        # s = self.visit(z)
</t>
<t tx="ekr.20160520184945.76"># Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node): # Python 3

    result = []
    self.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    if node.finalbody:
        result.append(self.indent('finally:\n'))
        for z in node.finalbody:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.77">def do_TryExcept(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.78">def do_TryFinally(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append(self.indent('finally:\n'))
    for z in node.finalbody:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.79">def do_While(self, node):
    result = []
    result.append(self.indent('while %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.8">def do_reaching_list(self, attr, node, val):
    assert attr == 'reach'
    return '[%s]' % ','.join(
        [self.format(z).strip() or repr(z)
            for z in getattr(node, attr)])
</t>
<t tx="ekr.20160520184945.80"># 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node):
    result = []
    result.append(self.indent('with '))
    if getattr(node, 'context_expression', None):
        result.append(self.visit(node.context_expresssion))
    vars_list = []
    if getattr(node, 'optional_vars', None):
        try:
            for z in node.optional_vars:
                vars_list.append(self.visit(z))
        except TypeError: # Not iterable.
            vars_list.append(self.visit(node.optional_vars))
    if getattr(node, 'items', None): # Python 3.
        for item in node.items:
            result.append(self.visit(item.context_expr))
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars:
                        vars_list.append(self.visit(z))
                except TypeError: # Not iterable.
                    vars_list.append(self.visit(item.optional_vars))
    result.append(','.join(vars_list))
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append('\n')
    return ''.join(result)
</t>
<t tx="ekr.20160520184945.81">def do_Yield(self, node):
    if getattr(node, 'value', None):
        return self.indent('yield %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('yield\n')
</t>
<t tx="ekr.20160520184945.82"># YieldFrom(expr value)

def do_YieldFrom(self, node):

    return self.indent('yield from %s\n' % (
        self.visit(node.value)))
</t>
<t tx="ekr.20160520184945.83"></t>
<t tx="ekr.20160520184945.84">def kind(self, node):
    '''Return the name of node's class.'''
    return node.__class__.__name__
</t>
<t tx="ekr.20160520184945.85">def indent(self, s):
    return '%s%s' % (' ' * 4 * self.level, s)
</t>
<t tx="ekr.20160520184945.86">@nobeautify

def op_name (self,node,strict=True):
    '''Return the print name of an operator node.'''
    d = {
        # Binary operators.
        'Add':       '+',
        'BitAnd':    '&amp;',
        'BitOr':     '|',
        'BitXor':    '^',
        'Div':       '/',
        'FloorDiv':  '//',
        'LShift':    '&lt;&lt;',
        'Mod':       '%',
        'Mult':      '*',
        'Pow':       '**',
        'RShift':    '&gt;&gt;',
        'Sub':       '-',
        # Boolean operators.
        'And':   ' and ',
        'Or':    ' or ',
        # Comparison operators
        'Eq':    '==',
        'Gt':    '&gt;',
        'GtE':   '&gt;=',
        'In':    ' in ',
        'Is':    ' is ',
        'IsNot': ' is not ',
        'Lt':    '&lt;',
        'LtE':   '&lt;=',
        'NotEq': '!=',
        'NotIn': ' not in ',
        # Context operators.
        'AugLoad':  '&lt;AugLoad&gt;',
        'AugStore': '&lt;AugStore&gt;',
        'Del':      '&lt;Del&gt;',
        'Load':     '&lt;Load&gt;',
        'Param':    '&lt;Param&gt;',
        'Store':    '&lt;Store&gt;',
        # Unary operators.
        'Invert':   '~',
        'Not':      ' not ',
        'UAdd':     '+',
        'USub':     '-',
    }
    name = d.get(self.kind(node),'&lt;%s&gt;' % node.__class__.__name__)
    if strict: assert name,self.kind(node)
    return name
</t>
<t tx="ekr.20160520184945.87">class AstFullTraverser(object):
    '''
    A fast traverser for AST trees: it visits every node (except node.ctx fields).

    Sets .context and .parent ivars before visiting each node.
    '''

    def __init__(self):
        '''Ctor for AstFullTraverser class.'''
        self.context = None
        self.d = {} # Keys are node.__class__ strings. Values are methods.
        self.parent = None
        self.trace = False
    @others
</t>
<t tx="ekr.20160520184945.88"></t>
<t tx="ekr.20160520184945.89"># 2: ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
# 3: ClassDef(identifier name, expr* bases,
#             keyword* keywords, expr? starargs, expr? kwargs
#             stmt* body, expr* decorator_list)
#
# keyword arguments supplied to call (NULL identifier for **kwargs)
# keyword = (identifier? arg, expr value)

def do_ClassDef(self, node):
    old_context = self.context
    self.context = node
    for z in node.bases:
        self.visit(z)
    if getattr(node, 'keywords', None): # Python 3
        for keyword in node.keywords:
            self.visit(keyword.value)
    if getattr(node, 'starargs', None): # Python 3
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None): # Python 3
        self.visit(node.kwargs)
    for z in node.body:
        self.visit(z)
    for z in node.decorator_list:
        self.visit(z)
    self.context = old_context
</t>
<t tx="ekr.20160520184945.9">def do_repr(self, attr, node, val):
    return repr(val)
</t>
<t tx="ekr.20160520184945.90"># 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node):

    old_context = self.context
    self.context = node
    # Visit the tree in token order.
    for z in node.decorator_list:
        self.visit(z)
    assert g.isString(node.name)
    self.visit(node.args)
    if getattr(node, 'returns', None): # Python 3.
        self.visit(node.returns)
    for z in node.body:
        self.visit(z)
    self.context = old_context
</t>
<t tx="ekr.20160520184945.91">def do_Interactive(self, node):
    assert False, 'Interactive context not supported'
</t>
<t tx="ekr.20160520184945.92"># Lambda(arguments args, expr body)

def do_Lambda(self, node):
    old_context = self.context
    self.context = node
    self.visit(node.args)
    self.visit(node.body)
    self.context = old_context
</t>
<t tx="ekr.20160520184945.93">def do_Module(self, node):
    self.context = node
    for z in node.body:
        self.visit(z)
    self.context = None
</t>
<t tx="ekr.20160520184945.94"># Not used in this class, but may be called by subclasses.

def do_AugLoad(self, node):
    pass

def do_Del(self, node):
    pass

def do_Load(self, node):
    pass

def do_Param(self, node):
    pass

def do_Store(self, node):
    pass
</t>
<t tx="ekr.20160520184945.95">def kind(self, node):
    return node.__class__.__name__
</t>
<t tx="ekr.20160520184945.96"></t>
<t tx="ekr.20160520184945.97"># 2: arguments = (expr* args, identifier? vararg,
#                 identifier? kwarg, expr* defaults)
# 3: arguments = (arg*  args, arg? vararg,
#                 arg* kwonlyargs, expr* kw_defaults,
#                 arg? kwarg, expr* defaults)

def do_arguments(self, node):

    for z in node.args:
        self.visit(z)
    if g.isPython3 and getattr(node, 'vararg', None):
        # An identifier in Python 2.
        self.visit(node.vararg)
    if getattr(node, 'kwonlyargs', None): # Python 3.
        self.visit_list(node.kwonlyargs)
    if getattr(node, 'kw_defaults', None): # Python 3.
        self.visit_list(node.kw_defaults)
    if g.isPython3 and getattr(node, 'kwarg', None):
        # An identifier in Python 2.
        self.visit(node.kwarg)
    for z in node.defaults:
        self.visit(z)

# 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if getattr(node, 'annotation', None):
        self.visit(node.annotation)
</t>
<t tx="ekr.20160520184945.98"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    self.visit(node.value)
    # self.visit(node.ctx)
</t>
<t tx="ekr.20160520184945.99"># BinOp(expr left, operator op, expr right)

def do_BinOp(self, node):
    self.visit(node.left)
    # self.op_name(node.op)
    self.visit(node.right)
</t>
<t tx="ekr.20160520210256.1">def read_string(self, fn):
    
    t1 = time.clock()
    s = g.readFileIntoEncodedString(fn, silent=False)
    t2 = time.clock()
    self.stats['read'] = self.stats.get('read', 0.0) + t2 - t1
    return s
</t>
<t tx="ekr.20160520210414.1">def compile_string(self, fn, s):
    
    t1 = time.clock()
    tree = None
    try:
        tree = compile(s, fn, "exec", ast.PyCF_ONLY_AST)
    except SyntaxError:
        g.es_print('syntax error')
        g.es_print_exception()
    except Exception:
        g.es_print('unexpected exception')
        g.es_print_exception() # EKR
    t2 = time.clock()
    self.stats['parse'] = self.stats.get('parse', 0.0) + t2 - t1
    return tree
</t>
<t tx="ekr.20160520210931.1">def traverse_tree(self, tree):

    global stats
    t1 = time.clock()
    leo_ast.AstFullTraverser().visit(tree)
    t2 = time.clock()
    stats['visit'] = stats.get('visit', 0.0) + t2 - t1</t>
<t tx="ekr.20160521023438.1">def handle_tree(self, tree):

    t1 = time.clock()
    checker.NullChecker().handleChildren(tree)
    t2 = time.clock()
    self.stats['handle'] = self.stats.get('handle', 0.0) + t2 - t1
</t>
<t tx="ekr.20160521023529.1">

class NullChecker:
    '''A do-nothing checker for timing comparisons.'''
    def __init__(self):
        self._nodeHandlers = {}
        
    @others
</t>
<t tx="ekr.20160521023730.2">
def handleChildren(self, tree, omit=None):
    # EKR: iter_child_nodes uses _FieldsOrder class.
    for node in iter_child_nodes(tree, omit=omit):
        self.handleNode(node, tree)
</t>
<t tx="ekr.20160521023730.4">
def handleNode(self, node, parent):
    # EKR: this the general node visiter.
    if node:
        node.parent = parent
        # EKR: this is the only call to getNodeHandler.
        handler = self.getNodeHandler(node.__class__)
        handler(node)

# _getDoctestExamples = doctest.DocTestParser().get_examples
</t>
<t tx="ekr.20160521024555.1">
def getNodeHandler(self, node_class):
    try:
        return self._nodeHandlers[node_class]
    except KeyError:
        nodeType = getNodeType(node_class)
    self._nodeHandlers[node_class] = handler = getattr(self, nodeType)
    return handler
</t>
<t tx="ekr.20160521024930.1">
def ignore(self, node):
    pass

# "stmt" type nodes
DELETE = PRINT = FOR = ASYNCFOR = WHILE = IF = WITH = WITHITEM = \
    ASYNCWITH = ASYNCWITHITEM = RAISE = TRYFINALLY = ASSERT = EXEC = \
    EXPR = ASSIGN = handleChildren

CONTINUE = BREAK = PASS = ignore

# "expr" type nodes
BOOLOP = BINOP = UNARYOP = IFEXP = DICT = SET = \
    COMPARE = CALL = REPR = ATTRIBUTE = SUBSCRIPT = LIST = TUPLE = \
    STARRED = NAMECONSTANT = handleChildren

NUM = STR = BYTES = ELLIPSIS = ignore

# "slice" type nodes
SLICE = EXTSLICE = INDEX = handleChildren

# expression contexts are node instances too, though being constants
LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore

# same for operators
AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \
    BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \
    EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = ignore

# additional node types
COMPREHENSION = KEYWORD = handleChildren</t>
<t tx="ekr.20160521024930.10">
def AUGASSIGN(self, node):
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160521024930.11">
def IMPORT(self, node):
    pass
</t>
<t tx="ekr.20160521024930.12">
def IMPORTFROM(self, node):
    pass
</t>
<t tx="ekr.20160521024930.13">
def TRY(self, node):
    for child in node.body:
        self.handleNode(child, node)
    self.handleChildren(node, omit='body')

TRYEXCEPT = TRY
</t>
<t tx="ekr.20160521024930.14">
def EXCEPTHANDLER(self, node):
    self.handleChildren(node)
</t>
<t tx="ekr.20160521024930.2">
def GLOBAL(self, node):
    pass

NONLOCAL = GLOBAL
</t>
<t tx="ekr.20160521024930.3">
def GENERATOREXP(self, node):
    self.handleChildren(node)

LISTCOMP = handleChildren if PY2 else GENERATOREXP

DICTCOMP = SETCOMP = GENERATOREXP
</t>
<t tx="ekr.20160521024930.4">
def NAME(self, node):
    pass</t>
<t tx="ekr.20160521024930.5">
def RETURN(self, node):
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160521024930.6">
def YIELD(self, node):
    self.handleNode(node.value, node)

AWAIT = YIELDFROM = YIELD
</t>
<t tx="ekr.20160521024930.7">
def FUNCTIONDEF(self, node):
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    self.LAMBDA(node)

ASYNCFUNCTIONDEF = FUNCTIONDEF
</t>
<t tx="ekr.20160521024930.8">
def LAMBDA(self, node):
    annotations = []
    if PY2:
        defaults = node.args.defaults
    else:
        for arg in node.args.args + node.args.kwonlyargs:
            annotations.append(arg.annotation)
        defaults = node.args.defaults + node.args.kw_defaults

    # Only for Python3 FunctionDefs
    is_py3_func = hasattr(node, 'returns')
    for arg_name in ('vararg', 'kwarg'):
        wildcard = getattr(node.args, arg_name)
        if not wildcard:
            continue
        if is_py3_func:
            if PY33:  # Python 2.5 to 3.3
                argannotation = arg_name + 'annotation'
                annotations.append(getattr(node.args, argannotation))
            else:     # Python &gt;= 3.4
                annotations.append(wildcard.annotation)
    if is_py3_func:
        annotations.append(node.returns)
    for child in annotations + defaults:
        if child:
            self.handleNode(child, node)
            
    # EKR: Was deferred.
    if isinstance(node.body, list):
        # case for FunctionDefs
        for stmt in node.body:
            self.handleNode(stmt, node)
    else:
        # case for Lambdas
        self.handleNode(node.body, node)
</t>
<t tx="ekr.20160521024930.9">
def CLASSDEF(self, node):
    """
    Check names used in a class definition, including its decorators, base
    classes, and the body of its definition.  Additionally, add its name to
    the current scope.
    """
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    for baseNode in node.bases:
        self.handleNode(baseNode, node)
    if not PY2:
        for keywordNode in node.keywords:
            self.handleNode(keywordNode, node)
    for stmt in node.body:
        self.handleNode(stmt, node)
</t>
<t tx="ekr.20160521154847.1"></t>
<t tx="ekr.20160521155725.1"></t>
<t tx="ekr.20160521155817.1"></t>
<t tx="ekr.20160522063947.1">
def MODULE(self, node):
    global stats
    if new_scope:
        self.scopeStack = []
        self.pushScope(node, self.filename, ModuleScope)
    else:
        self.scopeStack = [ModuleScope(node, self.filename, None)]
    moduleScope = self.scopeStack[-1] # EKR: I think I introduced this.
    self.pass1(node)
        # Traverse all top-level symbols.
    self.pass2(node)
        # Traverse all def/lambda bodies.
    self.pass3(node)
        # Check deferred assignments.
    if new_scope:
        self.scopeStack = []
        self.scope = None
    else:
        del self.scopeStack[1:]
    self.deadScopes.append(moduleScope)
    self.checkDeadScopes()
        # Pass 4.

if aft:
    Module = MODULE</t>
<t tx="ekr.20160522070940.1">
# def nodeDepth(node):
    # '''Return the node's depth. For debugging only.'''
    # n = 0
    # while node:
        # node = getattr(node, 'parent', None)
        # if node:
            # n += 1
    # return n
</t>
<t tx="ekr.20160522081903.1">
if aft:
    @others</t>
<t tx="ekr.20160522081949.10"></t>
<t tx="ekr.20160522081949.11">
# 2: arguments = (expr* args, identifier? vararg,
#                 identifier? kwarg, expr* defaults)
# 3: arguments = (arg*  args, arg? vararg,
#                 arg* kwonlyargs, expr* kw_defaults,
#                 arg? kwarg, expr* defaults)

def arguments(self, node):

    for z in node.args:
        self.handleNode(z, node)
    if g.isPython3 and getattr(node, 'vararg', None):
        # An identifier in Python 2.
        self.handleNode(node.vararg, node)
    if getattr(node, 'kwonlyargs', None): # Python 3.
        assert isinstance(aList, (list, tuple)), repr(aList)
        for z in aList:
            self.handleNode(z, node)
    if getattr(node, 'kw_defaults', None): # Python 3.
        assert isinstance(aList, (list, tuple)), repr(aList)
        for z in aList:
            self.handleNode(z, node)
    if g.isPython3 and getattr(node, 'kwarg', None):
        # An identifier in Python 2.
        self.handleNode(node.kwarg, node)
    for z in node.defaults:
        self.handleNode(z, node)

# 3: arg = (identifier arg, expr? annotation)

def arg(self, node):
    if getattr(node, 'annotation', None):
        self.handleNode(node.annotation, node)
</t>
<t tx="ekr.20160522081949.12">
# Attribute(expr value, identifier attr, expr_context ctx)

def Attribute(self, node):
    self.handleNode(node.value, node)
    # self.handleNode(node.ctx, node)
</t>
<t tx="ekr.20160522081949.13">
# BinOp(expr left, operator op, expr right)

def BinOp(self, node):
    self.handleNode(node.left, node)
    # self.op_name(node.op)
    self.handleNode(node.right, node)
</t>
<t tx="ekr.20160522081949.14">
# BoolOp(boolop op, expr* values)

def BoolOp(self, node):
    
    # self.handleNode(node.op)
    for z in node.values:
        self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.16">
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def Call(self, node):
    # Call the nodes in token order.
    self.handleNode(node.func, node)
    for z in node.args:
        self.handleNode(z, node)
    for z in node.keywords:
        self.handleNode(z, node)
    if getattr(node, 'starargs', None):
        self.handleNode(node.starargs, node)
    if getattr(node, 'kwargs', None):
        self.handleNode(node.kwargs, node)
</t>
<t tx="ekr.20160522081949.17">
# Compare(expr left, cmpop* ops, expr* comparators)

def Compare(self, node):
    # Visit all nodes in token order.
    self.handleNode(node.left, node)
    assert len(node.ops) == len(node.comparators)
    for i in range(len(node.ops)):
        if not isinstance(node.ops[i], ast.cmpop):
            # Could be a name, etc.
            self.handleNode(node.ops[i], node)
        if not isinstance(node.comparators[i], ast.cmpop):
            self.handleNode(node.comparators[i], node)
</t>
<t tx="ekr.20160522081949.19">
# comprehension (expr target, expr iter, expr* ifs)

def comprehension(self, node):
    # EKR: visit iter first.
    self.handleNode(node.iter, node) # An attribute.
    self.handleNode(node.target, node) # A name.
    for z in node.ifs:
        self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.20">
# Dict(expr* keys, expr* values)

def Dict(self, node):
    # Visit all nodes in token order.
    assert len(node.keys) == len(node.values)
    for i in range(len(node.keys)):
        self.handleNode(node.keys[i], node)
        self.handleNode(node.values[i], node)
</t>
<t tx="ekr.20160522081949.22">
# Expr(expr value)

def Expr(self, node):
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160522081949.23">
def Expression(self, node):
    '''An inner expression'''
    self.handleNode(node.body, node)
</t>
<t tx="ekr.20160522081949.24">
def ExtSlice(self, node):
    for z in node.dims:
        self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.26">
# IfExp(expr test, expr body, expr orelse)

def IfExp(self, node):
    self.handleNode(node.body, node)
    self.handleNode(node.test, node)
    self.handleNode(node.orelse, node)
</t>
<t tx="ekr.20160522081949.27">
def Index(self, node):
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160522081949.28">
# keyword = (identifier arg, expr value)

def keyword(self, node):
    # node.arg is a string.
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160522081949.29">
# List(expr* elts, expr_context ctx)

def List(self, node):
   
    for z in node.elts:
        self.handleNode(z, node)
    # self.handleNode(node.ctx, node)

# It would not be good to have to test for lists.
# if aft:
    # def list(self, node):
        # g.trace(g.callers())
        # assert self.pass_n == 2, self.pass_n
        # for z in node:
            # self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.32">
# Python 2.x only
# Repr(expr value)

def Repr(self, node):
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160522081949.33">
def Slice(self, node):
    if getattr(node, 'lower', None):
        self.handleNode(node.lower, node)
    if getattr(node, 'upper', None):
        self.handleNode(node.upper, node)
    if getattr(node, 'step', None):
        self.handleNode(node.step, node)
</t>
<t tx="ekr.20160522081949.35">
# Subscript(expr value, slice slice, expr_context ctx)

def Subscript(self, node):
    # EKR: Visit value first.
    self.handleNode(node.value, node)
    self.handleNode(node.slice, node)
    # self.handleNode(node.ctx, node)
</t>
<t tx="ekr.20160522081949.36">
# Tuple(expr* elts, expr_context ctx)

def Tuple(self, node):
    # g.trace(node.elts)
    for z in node.elts:
        self.handleNode(z, node)
    # self.handleNode(node.ctx, node)
        # EKR: ignore ctx fields (LOAD, STORE, etc.</t>
<t tx="ekr.20160522081949.37">
# UnaryOp(unaryop op, expr operand)

def UnaryOp(self, node):
    # self.op_name(node.op)
    self.handleNode(node.operand, node)
</t>
<t tx="ekr.20160522081949.38"></t>
<t tx="ekr.20160522081949.40">
# Assert(expr test, expr? msg)

def Assert(self, node):
    self.handleNode(node.test, node)
    if node.msg:
        self.handleNode(node.msg, node)
</t>
<t tx="ekr.20160522081949.41">
# Assign(expr* targets, expr value)

def Assign(self, node):
    # EKR: Visit value first.
    self.handleNode(node.value, node)
    for z in node.targets:
        self.handleNode(z, node)
    
</t>
<t tx="ekr.20160522081949.45">
# Delete(expr* targets)

def Delete(self, node):
    for z in node.targets:
        self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.47">
# Python 2.x only
# Exec(expr body, expr? globals, expr? locals)

def Exec(self, node):
    self.handleNode(node.body, node)
    if getattr(node, 'globals', None):
        self.handleNode(node.globals, node)
    if getattr(node, 'locals', None):
        self.handleNode(node.locals, node)
</t>
<t tx="ekr.20160522081949.48">
# For(expr target, expr iter, stmt* body, stmt* orelse)

def For(self, node):
    
    # EKR: visit iter first.
    self.handleNode(node.iter, node)
    self.handleNode(node.target, node)
    for z in node.body:
        self.handleNode(z, node)
    for z in node.orelse:
        self.handleNode(z, node)

AsyncFor = For</t>
<t tx="ekr.20160522081949.50">
# If(expr test, stmt* body, stmt* orelse)

def If(self, node):

    if not isinstance(node.test, ast.operator):
        self.handleNode(node.test, node)
    for z in node.body:
        self.handleNode(z, node)
    for z in node.orelse:
        self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.54">
# Python 2.x only
# Print(expr? dest, expr* values, bool nl)

def Print(self, node):
    if getattr(node, 'dest', None):
        self.handleNode(node.dest, node)
    for expr in node.values:
        self.handleNode(expr, node)
</t>
<t tx="ekr.20160522081949.55">
# Raise(expr? type, expr? inst, expr? tback)    Python 3
# Raise(expr? exc, expr? cause)                 Python 2

def Raise(self, node):

    if g.isPython3:
        if getattr(node, 'exc', None):
            self.handleNode(node.exc, node)
        if getattr(node, 'cause', None):
            self.handleNode(node.cause, node)
    else:
        if getattr(node, 'type', None):
            self.handleNode(node.type, node)
        if getattr(node, 'inst', None):
            self.handleNode(node.inst, node)
        if getattr(node, 'tback', None):
            self.handleNode(node.tback, node)
</t>
<t tx="ekr.20160522081949.57">
# Starred(expr value, expr_context ctx)

def Starred(self, node):

    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160522081949.60">
# TryFinally(stmt* body, stmt* finalbody)

def TryFinally(self, node):
    for z in node.body:
        self.handleNode(z, node)
    for z in node.finalbody:
        self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.61">
# While(expr test, stmt* body, stmt* orelse)

def While(self, node):
    self.handleNode(node.test, node) # Bug fix: 2013/03/23.
    for z in node.body:
        self.handleNode(z, node)
    for z in node.orelse:
        self.handleNode(z, node)
</t>
<t tx="ekr.20160522081949.62">
# 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def With(self, node):
    if getattr(node, 'context_expr', None):
        self.handleNode(node.context_expr, node)
    if getattr(node, 'optional_vars', None):
        self.handleNode(node.optional_vars, node)
    if getattr(node, 'items', None): # Python 3.
        for item in node.items:
            self.handleNode(item.context_expr, node)
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars:
                        self.handleNode(z, node)
                except TypeError: # Not iterable.
                    self.handleNode(item.optional_vars, node)
    for z in node.body:
        self.handleNode(z, node)
        
AsyncWith = With
</t>
<t tx="ekr.20160522082410.1">
def NameConstant(self, node): # Python 3 only.

    assert aft
    assert isinstance(node.value, (bool, str, None.__class__)), node.value.__class__.__name__
    # g.trace(node.value)
    # if node.value:
    #     self.handleNode(node.value, node)
    # self.handleNode(node.value, node)
    # s = repr(node.value)
    # return 'bool' if s in ('True', 'False') else s
</t>
<t tx="ekr.20160523065519.1">@nosearch</t>
<t tx="ekr.20160523065801.1">trace_dict = {}

def CHANGEDgetNodeHandler(self, node_class):
    
    if jit:
        # Create self.X corresponding to node_class.__name__
        name = node_class.__name__
        handler = getattr(self, name, None)
        if handler:
            return handler
        try:
            fields = _FieldsOrder()[node_class]
            if False and fields != self.trace_dict.get(name,[]):
                g.trace(name, fields)
                self.trace_dict[name] = fields
        except AttributeError:
            fields = None
        
        if fields:
            # Create handler equivalent handleChildren specialized for the node.
            
            def special_iter(node): # omit, fields=fields, 
                '''iter_child_nodes with fixed fields.'''
                for name in fields:
                    field = getattr(node, name, None)
                    if isinstance(field, ast.AST):
                        yield field
                    elif isinstance(field, list):
                        for item in field:
                            yield item
            
            def handler(tree, omit=None):
                '''A "specialized" handler" for the given Ast node.'''
                for node in special_iter(tree):
                    self.handleNode(node, parent=tree)
        else:
            # Should not happen: all constant nodes have been assigned to ignore.
            g.trace(node_class.__name__)
            handler = self.ignore
        setattr(self, name, handler)
        return handler
    elif aft:
        handler = self._nodeHandlers.get(node_class)
        if not handler:
            handler = getattr(self, 'do_'+node_class.__name__)
            self._nodeHandlers[node_class] = handler
        return handler
    else:
        try:
            return self._nodeHandlers[node_class]
        except KeyError:
            nodeType = getNodeType(node_class)
        self._nodeHandlers[node_class] = handler = getattr(self, nodeType)
        return handler
</t>
<t tx="ekr.20160523070015.1">if aft:
    do_alias = ignore
    do_Continue = do_Break = do_Pass = ignore
    do_Num = do_Str = do_Bytes = do_Ellipsis = ignore
    do_Load = do_Store = do_Del = do_AugLoad = do_AugStore = do_Param = ignore
        # expression contexts are (constant) node instances
    do_And = do_Or = do_Add = do_Sub = do_Mult = do_Div = do_Mod = do_Pow = do_LShift = do_RShift = ignore
    do_BitOr = do_BitXor = do_BitAnd = do_FloorDiv = do_Invert = do_Not = do_UAdd = do_USub = ignore
    do_Eq = do_NotEq = do_Lt = do_LtE = do_Gt = do_GtE = do_Is = do_IsNot = do_In = do_NotIn = ignore
        
        
From handleNode:
    
    if jit:
        handler = getattr(self,
            node.__class__.__name__,
            self.getNodeHandler(node.__class__))
        handler(node)
    else:
        handler = self.getNodeHandler(node.__class__)
        handler(node)</t>
<t tx="ekr.20160523085953.1">class TestController:
    
    def __init__(self):
        '''Ctor for TestController class.'''
        self.stats = {}
        
    @others</t>
<t tx="ekr.20160523090911.3">
def unit_test(raise_on_fail=True):
    '''Run basic unit tests for this file.'''
    import _ast
    # import leo.core.leoAst as leoAst
    # Compute all fields to test.
    aList = sorted(dir(_ast))
    remove = [
        'Interactive', 'Suite', # Not necessary.
        'PyCF_ONLY_AST', # A constant,
        'AST', # The base class,
        # Grammar symbols...
        'expr', 'mod', 'stmt',
        'boolop', 'cmpop', 'unaryop', 'operator',
        # Field names...
        'expr_context', 'excepthandler', 'slice', 'withitem',
    ]
    aList = [z for z in aList if not z.startswith('_') and not z in remove]
    # Now test them.
    # Create a real tree so handleNode doesn't have to test for an empty tree.
    fn, s = '&lt;test&gt;', 'pass'
    tree = compile(s, fn, "exec", ast.PyCF_ONLY_AST)
    ft = Checker(tree)
    operator_classes = (
        ast.cmpop, ast.boolop,
        ast.expr_context,
        ast.operator, ast.unaryop,
    )
    errors, nodes, operators = 0, 0, 0
    if aft:
        for z in aList:
            class_ = getattr(ast, z, None)
            if hasattr(ft, z):
                nodes += 1
            elif aft and issubclass(class_, operator_classes):
                operators += 1
            else:
                errors += 1
                print('Missing pyflakes visitor for: %s' % z)
    s = '%s node types, %s errors' % (nodes, errors)
    if raise_on_fail:
        assert not errors, s
    else:
        print(s)
</t>
<t tx="ekr.20160523093026.1">
# Set(expr* elts)

def Set(self, node):
    for z in node.elts:
        self.handleNode(z, node)
        </t>
<t tx="ekr.20160523172121.1"></t>
<t tx="ekr.20160523172144.1"></t>
<t tx="ekr.20160523172328.1">def print_stats(self, n, t1, t2):
    
    stats = self.stats
    m = resolve if test_kind == 'resolve' else checker
    # compute...
    stats['total'] = t2 - t1
    for name in ('pass1', 'pass2', 'pass3', 'pass4', ):
        stats[name] = m.stats.get(name, 0.0)
    if 'handle' in stats and 'visit' in stats:
        handle_t = stats.get('handle',0.0)
        visit_t = stats.get('visit',0.0)
        stats['total2'] = t2 - t1 - handle_t - visit_t
    # print...
    print('%s file%s' % (n, g.plural(n)))
    if 1:
        print('nodes visited...')
        for i in (1,2):
            print('  pass%s: %7s' % (i, m.n_pass_nodes[i]))
        n_handleNode = sum(m.n_pass_nodes[i] for i in (1,2))
        print('  total: %7s' % n_handleNode)
    if 1:
        print('method calls...')
        print('  handleNode:      %7s' % n_handleNode)
        print('  handleChildren:  %7s' % m.n_handleChildren)
        print('  FunctionDef:     %7s' % m.n_FunctionDef)
        print('  ignore:          %7s' % m.n_ignore)
        print('  Load:            %7s' % m.n_load)
        print('  Store:           %7s' % m.n_store)
        print('  deferAssignment: %7s' % m.n_deferred_assignments)
    if 1:
        print('data...')
        print('  Scopes:          %7s' % m.n_scopes)
        print('  Scope names:     %7s' % m.n_scope_names)
    print('times (sec.)...')
    keys = (
        # 'read', 'parse', 'visit', 'handle',
        'check',
        '  pass1', '  pass2',
        # '  pass3', '  pass4',
        'total', 'total2')
    for key in keys:
        if key.strip() in stats:
            print('  %-7s %5.2f' % (key, stats.get(key.strip())))
    if 'total2' in stats:
        print('  total2 = total - visit - handle')
</t>
<t tx="ekr.20160523173355.1">
def runFunction():
    '''A function that will be run in pass 2.'''

    assert self.pass_n == 2, self.pass_n
    if hasattr(node, 'name'):
        def_name = 'def: %s' % node.name
    else:
        def_name = 'Lambda: %s' % id(node)
    self.pushScope(node, def_name, FunctionScope)
    for name in args:
        self.addBinding(node, Argument(name, node))
        
    # EKR: *Now* traverse the body of the Def/Lambda.
    if isinstance(node.body, list):
        # case for FunctionDefs
        for stmt in node.body:
            self.handleNode(stmt, node)
    else:
        # case for Lambdas
        self.handleNode(node.body, node)
        
    # EKR: defer checking assignments until pass 3.

    def checkUnusedAssignments():
        """
        Check to see if any assignments have not been used.
        """
        assert self.pass_n == 3, self.pass_n
        # g.trace(self.scope)
        for name, binding in self.scope.unusedAssignments():
            self.report(messages.UnusedVariable, binding.source, name)
    
    self.deferAssignment(checkUnusedAssignments)

    if PY32:
        def checkReturnWithArgumentInsideGenerator():
            """
            Check to see if there is any return statement with
            arguments but the function is a generator.
            """
            # g.trace(self.scope)
            assert self.pass_n == 3, self.pass_n
            if self.scope.isGenerator and self.scope.returnValue:
                self.report(messages.ReturnWithArgsInsideGenerator,
                            self.scope.returnValue)
        self.deferAssignment(checkReturnWithArgumentInsideGenerator)

    self.popScope()</t>
<t tx="ekr.20160523173531.1">
def get_function_args(self, node):

    annotations, args = [], []

    if PY2:
        def addArgs(arglist):
            for arg in arglist:
                if isinstance(arg, ast.Tuple):
                    addArgs(arg.elts)
                else:
                    args.append(arg.id)
        addArgs(node.args.args)
        defaults = node.args.defaults
    else:
        for arg in node.args.args + node.args.kwonlyargs:
            args.append(arg.arg)
            annotations.append(arg.annotation)
        defaults = node.args.defaults + node.args.kw_defaults

    # Only for Python3 FunctionDefs
    is_py3_func = hasattr(node, 'returns')

    for arg_name in ('vararg', 'kwarg'):
        wildcard = getattr(node.args, arg_name)
        if not wildcard:
            continue
        args.append(wildcard if PY33 else wildcard.arg)
        if is_py3_func:
            if PY33:  # Python 2.5 to 3.3
                argannotation = arg_name + 'annotation'
                annotations.append(getattr(node.args, argannotation))
            else:     # Python &gt;= 3.4
                annotations.append(wildcard.annotation)

    if is_py3_func:
        annotations.append(node.returns)

    if len(set(args)) &lt; len(args):
        for (idx, arg) in enumerate(args):
            if arg in args[:idx]:
                self.report(messages.DuplicateArgument, node, arg)
                
    return annotations, args, defaults</t>
<t tx="ekr.20160523175246.1"></t>
<t tx="ekr.20160523175246.10"># Add any other common imports here.

file_template = '''\
import unittest
from make_stub_files import *
'''

file_template = g.adjustTripleString(file_template,c.tab_width)
</t>
<t tx="ekr.20160523175246.11">test_template = '''
class %s (unittest.TestCase):
    def runTest(self):
%s
'''

test_template = g.adjustTripleString(test_template,c.tab_width)
</t>
<t tx="ekr.20160523175246.12">
def __init__(self,c,path=''):
    '''TestWriter ctor.'''
    self.c = c
    load_dir = g.os_path_dirname(c.fileName())
    self.path = g.os_path_finalize_join(load_dir,path)
    self.nodes = []
    assert g.os_path_exists(self.path),self.path
</t>
<t tx="ekr.20160523175246.13">
def clean(self,s):
    '''Munge s so that it can be used as a file name.'''
    result,tag = [],'@test'
    if s.startswith(tag):
        s = s[len(tag):]
    for ch in s.strip():
        if ch.isalnum():
            result.append(ch)
        else:
            result.append('_')
        # elif ch.isspace():
            # result.append('_')
    s = ''.join(result)
    if s.endswith('.py'):
        s = s[:-3]
    if not s.startswith('test'):
        s = 'test_' + s
    return s.replace('__','_').strip()
</t>
<t tx="ekr.20160523175246.14">
def get_body(self, p):
    '''Convert p.b to a valid script.'''
    s_old = p.b
    # Suppress @others but not section references.
    p.b = p.b.replace('@others', '')
    assert p.b.find('@others') == -1
    s = g.getScript(c, p,
                    useSelectedText=False,
                    forcePythonSentinels=True,
                    useSentinels=False)
    p.b = s_old
    s = ''.join([' '*8+z for z in g.splitLines(s) if z.strip()])
            # Add leading indentation needed by test_template.
    return s.rstrip()+'\n'
</t>
<t tx="ekr.20160523175246.15">
def run(self,fn=None):
    
    n, p = 0, c.rootPosition()
    while p:
        if p.h.startswith('@ignore '):
            p.moveToNodeAfterTree()
        elif p.h.startswith('@test '):
            self.nodes.append(p.copy())
            if not fn:
                fn2 = self.clean(p.h)+'.py'
                self.write_file(fn2)
                self.test(fn2)
                self.nodes=[]
            n += 1
            p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if n == 0:
        print('no @file or @suite nodes found.')
    else:
        if fn:
            self.write_file(fn)
            self.test(fn)
        dest = g.os_path_join(self.path, fn) if fn else self.path
        print('wrote %s test%s to %s' % (n,self.plural(n), dest))
</t>
<t tx="ekr.20160523175246.16">
def plural(self, n):
    return 's' if n &gt; 1 else ''
</t>
<t tx="ekr.20160523175246.17">
def test(self,fn):
    '''Test the newly created file.'''
    import imp
    import sys

    if self.path not in sys.path:
        sys.path.append(self.path)
    assert fn.endswith('.py')
    name = fn[:-3]
    try:
        f,path,desc = imp.find_module(name,[self.path])
        imp.load_module(name,f,path,desc)
        # print('imported %s' % (name))
    except Exception:
        print('can not import: %s' % (name))
        g.es_print_exception()
</t>
<t tx="ekr.20160523175246.18">
def write_file(self,fn):

    assert g.os_path_exists(self.path),self.path
    fn = g.os_path_finalize_join(self.path,fn)
    f = open(fn,'w')
    f.write(self.file_template)
    # g.trace(''.join([z.h for z in self.nodes]))
    for p in self.nodes:
        f.write(self.test_template % (self.clean(p.h),self.get_body(p)))
    f.close()
    g.trace('wrote', fn)
</t>
<t tx="ekr.20160523175246.19">g.cls()
for p1 in c.all_unique_positions():
    if p1.h.startswith('@clean checker.py'):
        for p in p1.subtree():
            if (not p.h.strip().startswith('&lt;&lt;') and
                p.b.strip() and
                not p.b.startswith('\n')
                # and not p.b.startswith('#')
            ):
                print(repr(p.b[:3]), p.h)
print('done')
</t>
<t tx="ekr.20160523175246.2"></t>
<t tx="ekr.20160523175246.20"></t>
<t tx="ekr.20160523175246.21"># pylint: disable=relative-import
g.cls()
import test_msf
import unittest
loader = unittest.TestLoader()
suite = loader.loadTestsFromTestCase(test_msf.TestMakeStubFiles)
unittest.TextTestRunner(verbosity=0).run(suite)
</t>
<t tx="ekr.20160523175246.22">
    # First, look at the [Def Name Patterns]
    if 0: # This never seems to match anything.
        stack = self.traverser.class_name_stack
        if stack:
            name = '%s.%s' % (stack[-1], func)
        else:
            name = func
        for pattern in self.def_patterns:
            found, s = pattern.match(name)
            if found:
                if trace: g.trace('%s: %s -&gt; %s' % (pattern.find_s, name, s))
                return s</t>
<t tx="ekr.20160523175246.23">
def match(self, patterns, s):
    '''Return s with at most one pattern matched.'''
    assert False, g.callers()
    for pattern in patterns:
        found, s = pattern.match(s)
        if found:
            break
    return s
</t>
<t tx="ekr.20160523175246.24">
seen_patterns = []

def visit(self, node):
    '''
    Return the formatted version of an Ast node after
    applying all general patterns.
    '''
    # This is the heart of this script.
    trace = False
    s = AstFormatter.visit(self, node)
    if self.fast_match:
        # Match only the patterns associated with this node.
        name = node.__class__.__name__
        for pattern in self.patterns_dict.get(name, []):
            found, s = pattern.match(s)
            if trace and found and pattern not in self.seen_patterns:
                self.seen_patterns.append(pattern)
                g.trace('%10s %s' % (name, pattern))
        if trace:
            # This finds and reports all missed patterns.
            for pattern in self.general_patterns:
                found, s = pattern.match(s)
                if True and found and pattern not in self.seen_patterns:
                    self.seen_patterns.append(pattern)
                    g.trace('**** %5s %s' % (name, pattern))
    else: # Match all general patterns.
        for pattern in self.general_patterns:
            found, s = pattern.match(s)
    return s
</t>
<t tx="ekr.20160523175246.25"></t>
<t tx="ekr.20160523175246.26">    # Look inside the square brackets.
    brackets = s[len(s2):]
    if brackets and brackets[0] == '[' and brackets[-1] == ']':
        s3 = brackets[1:-1]
        if s3:
            return all([self.is_known_type(z.strip())
                for z in self.split_types(s3)])
        else:
            return True
    else:
        s3 = brackets[1:-1]
        g.trace('can not happen:\ns2: %s\ns3: %s\npattern: %s' % (
            ' '*5+s2, ' '*5+s3, pattern))
    </t>
<t tx="ekr.20160523175246.27">    result = []
    for z in aList:
        for kind in ('Dict', 'List', 'Optional', 'Tuple', 'Union'):
            if z.startswith(kind):
                result.append(z)
                break
        else:
            result.append(z if self.is_known_type(z) else 'Any')
    g.trace(aList, result)
    return result
</t>
<t tx="ekr.20160523175246.28">    r = sorted(set(aList))
    if trace: g.trace('1', r)
    table = (
        self.reduce_unknowns,
        self.reduce_numbers,
        self.merge_tuples,
        self.merge_dicts,
        self.merge_lists,
        self.make_optional,
    )
    # Apply all reductions even on lists of length one.
    for f in table:
        r = f(r)
    if trace: g.trace('2', r)
    if not r:
        return 'None'
    elif len(r) == 1:
        return self.show(r[0])
    elif 'None' in r:
        r = [z for z in aList if z != 'None']
        if len(r) == 0:
            return self.show('None')
        elif len(r) == 1:
            return self.show('Optional[%s]' % r[0])
        else:
            return self.show('Optional[Union[%s]]' % (', '.join(sorted(r))))
    else:
        return self.show('Union[%s]' % (', '.join(sorted(r))))
</t>
<t tx="ekr.20160523175246.29">
def make_optional(self,r):
    
    if r and 'None' in r:
        r = [z for z in r if z != 'None']
        r = self.show('Optional[%s]' % r[0]) if r else self.show('None')
    return r</t>
<t tx="ekr.20160523175246.3">test
pyflakes
</t>
<t tx="ekr.20160523175246.5"></t>
<t tx="ekr.20160523175246.6"></t>
<t tx="ekr.20160523175246.7">&lt;&lt; docstring &gt;&gt;
# **Note**: this is a Leo script.
# It **does** have access to c, g and p.
import os
import re
@others
test_dir = os.path.dirname(c.fileName())+os.sep+'test'
assert os.path.exists(test_dir), test_dir
assert os.path.isdir(test_dir), test_dir

if 1:
    # Writes each test to a separate file in the test directory.
    TestWriter(c,path=test_dir).run(fn=None)    
if 0:
    # Writes all tests to a single file: test/unit_tests.py
    TestWriter(c,path=test_dir).run(fn='unit_tests.py')
</t>
<t tx="ekr.20160523175246.8">@
@language rest
'''
This script transliterates @test nodes into .py file. The two main ways of
using this script are as follows::

    TestWriter(c,path='test').run(fn='unit_tests.py') # writes one file
    TestWriter(c,path='test').run(fn=None)            # writes separate files.
     
The first writes all tests to test/unit_tests.py; the second writes each
unit test to a separate .py file in the test directory.

The script imports each written file and reports any syntax errors.

This is a straightforward script; it should be easy to modify it to suit
individual needs.

The &lt;\&lt; file_template &gt;&gt; and &lt;\&lt; test_template &gt;&gt; sections in the TestWriter
class determines exactly what this script writes.
'''
</t>
<t tx="ekr.20160523175246.9">

class TestWriter:
    
    &lt;&lt; define file_template &gt;&gt;
    &lt;&lt; define test_template &gt;&gt;

    @others
</t>
<t tx="ekr.20160523181737.1">
def pass1(self, node):
    
    global stats
    t1 = time.clock()
    self.pass_n = 1
    # This looks like it is a full pass.
    # In fact, traversing of def/lambda happens in pass 2.
    if aft:
        for z in node.body:
            self.handleNode(z, node)
    else:
        self.handleChildren(node)
    t2 = time.clock()
    stats['pass1'] = stats.get('pass1', 0.0) + t2-t1
</t>
<t tx="ekr.20160523181742.1">
def pass2(self, node):
    
    global stats
    t1 = time.clock()
    # Traverse the bodies of all def's &amp; lambda's.
    self.pass_n = 2
    self.runDeferred(self._deferredFunctions)
        # Run all the queued runFunction functions or scanFunction methods.
    self._deferredFunctions = None
        # Set _deferredFunctions to None so that deferFunction will fail
        # noisily if called after we've run through the deferred functions.
    t2 = time.clock()
    stats['pass2'] = stats.get('pass2', 0.0) + t2-t1
</t>
<t tx="ekr.20160523181745.1">
def pass3(self, node):
    
    global stats
    t1 = time.clock()
    self.pass_n = 3
        # handleNode will raise an exception if it is called.
    self.runDeferred(self._deferredAssignments)
        # Run all queued calls to checkUnusedAssignments and
        # (If Python 2) checkReturnWithArgumentInsideGenerator
    self._deferredAssignments = None
        # Set _deferredAssignments to None so that deferAssignment will fail
        # noisily if called after we've run through the deferred assignments.
    t2 = time.clock()
    stats['pass3'] = stats.get('pass3', 0.0) + t2-t1
</t>
<t tx="ekr.20160524084528.1">
def Break(self, node):
    pass</t>
<t tx="ekr.20160524084549.1">
def Continue(self, node):
    pass</t>
<t tx="ekr.20160524084621.1">
def Pass(self, node):
    pass</t>
<t tx="ekr.20160524091057.1">
def Num(self, node):
    pass</t>
<t tx="ekr.20160524091119.1">
def Str(self, node):
    pass</t>
<t tx="ekr.20160524091135.1">
def Bytes(self, node):
    pass</t>
<t tx="ekr.20160524091305.1">
def Ellipsis(self, node):
    pass</t>
<t tx="ekr.20160524091403.1">
def alias(self, node):
    pass</t>
<t tx="ekr.20160524091908.1">@others</t>
<t tx="ekr.20160525070614.1">
def dump(self, brief=False): # EKR
    aList = [
        '%s: %s parent: %s...' % (
            self.__class__.__name__, self.name, self.parent and self.parent.name or 'None')
    ]
    if brief:
        for key in sorted(self):
            value = self.get(key)
            aList.append('    '+repr(value))
    else:
        for key in sorted(self):
            value = self.get(key)
            if hasattr(value, 'dump'):
                aList.append('  %s' % value.dump(scope=self))
            else:
                aList.append('%15s %r' % (key, value))
    return '\n'.join(aList)
</t>
<t tx="ekr.20160525071459.1">
def dump(self, scope=None):
    if self.used:
        #####  only dump scope if it doesn't match the given scope.
        ##### Add names to scope.
        scope2, binding = self.used
        name = binding.__class__.__name__
        if hasattr(binding, 'lineno'):
            s = 'line: %2s %s' % (binding.lineno, name)
        else:
            s = name
    else:
        s = False
    return '%s: %s used: %s' % (
        self.__class__.__name__, self.name, s)
</t>
<t tx="ekr.20160525151651.1">
def __repr__(self):
    # scope_class = self.__class__.__name__
    # return '&lt;%s at 0x%x %s&gt;' % (scope_class, id(self), dict.__repr__(self))
    # return '%s %s' % (scope_class, self.name)
    return self.name
</t>
<t tx="ekr.20160526060219.1">
# Stats:
# jit:  not significantly better than original.
# aft:  checker: 1.97 total: 3.84 # 20% overall improvement.
# None: checker: 2.44 total: 4.99

aft = True
    # True: use AstFullTraverser class for traversals.
    # This is proving to be difficult, because ast.visit doesn't have a parent arg.
# jit = False
    # This is only slightly faster than the default handleChildren method.
    # True: create node handlers in getNodeHandler.
new_scope = aft
    # True: replace self.scope property by simple code in push/popStack.</t>
<t tx="ekr.20160526063937.1">
def scanFunction(self, node, args):
    
    # This was in runFunction...
    assert self.pass_n == 2, self.pass_n
    if g.isPython3:
        assert isinstance(node, (ast.FunctionDef, ast.Lambda, ast.AsyncFunctionDef)), node
    else:
        assert isinstance(node, (ast.FunctionDef, ast.Lambda)), node
    if hasattr(node, 'name'):
        def_name = 'def: %s' % node.name
    else:
        def_name = 'Lambda: %s' % id(node)
    self.pushScope(node, def_name, FunctionScope)
    for arg_name in args:
        self.addBinding(node, Argument(arg_name, node))
    # *Now* traverse the body of the def/lambda.
    if isinstance(node.body, list): # Bug fix.
        for z in node.body:
            self.handleNode(z, node)
    else:
        self.handleNode(node.body, node)
    # Defer checking assignments until pass 3.
    bunch = g.Bunch(
        offset=self.offset,
        scopeStack = self.scopeStack[:])
    self.check_assign_list.append(bunch)
    self.popScope()</t>
<t tx="ekr.20160526064907.1">test_scope='all'
test_kind = 'normal', # 'resolve'</t>
<t tx="ekr.20160526074410.1">
def checkAssignments(self):
    """
    Check to see if any assignments have not been used.
    """
    assert self.pass_n == 3, self.pass_n
    g.trace(self.scope)
    for name, binding in self.scope.unusedAssignments():
        self.report(messages.UnusedVariable, binding.source, name)
    
    if PY32:
        if self.scope.isGenerator and self.scope.returnValue:
            self.report(messages.ReturnWithArgsInsideGenerator,
                        scope.returnValue)
</t>
<t tx="ekr.20160526165301.1">'''\
# This import ruins all other tests for undefined..
from alpha import *         # ImportStarUsed                        
''',

# The following all pass...
'''\
import sys                  # UnusedImport  
import os                   # Used below...
xxx = 2                     # Unused, but only local unused vars are reported.
from __future__ import F    # LateFutureImport
for os in range(3):
    print(os)               # ImportShadowedByLoopVar
print(x)                    # UndefinedName
return 42                   # ReturnOutsideFunction

def f(arg, arg):    # DuplicateArgument
    unused = 1      # UnusedVariable
    print(f1)       # UndefinedName

def gen():
    yield 1
    return 2        # (Python 2 Only) ReturnWithArgsInsideGenerator

class aClass:
    return 25       # ReturnOutsideFunction
    
def redefined_test():
    n = 1   
    print({n: n for n in range(5)}) # RedefinedInListComp
    
a = 1

def local_test():
    print(a)        # UndefinedLocal
    a = 2
    print(a)        # Suppress UnusedVariable
    
def duplicate():
    local_test()
   
def duplicate():    # RedefinedWhileUnused
    pass

''',
</t>
<t tx="ekr.20160531100422.1">g.cls()
# All enabled tests run properly when run from Python 2.
import imp
import os
import unittest
import checker
imp.reload(checker)
path = g.os_path_finalize_join(os.curdir, '..')
file_, pathname, description = imp.find_module('pyflakes', [path])
pyflakes = imp.load_module('pyflakes', file_, pathname, description)
print('pyflakes: %s' % pyflakes)
from pyflakes.test import test_api, test_doctests, test_imports, test_other
from pyflakes.test import test_return_with_arguments_inside_generator
from pyflakes.test import test_undefined_names
if 0:
    module_tests = []
    individual_tests = (
        'pyflakes.test.test_doctests.Test.test_offsetInLambdasInDoctests',
    )
else:
    individual_tests = []
    module_tests = (
        ## test_api,
        test_doctests,
        test_imports,
        test_other,
        test_return_with_arguments_inside_generator,
        test_undefined_names,
    )
loader = unittest.TestLoader()
suite = unittest.TestSuite()
for test in individual_tests:
    suite.addTest(loader.loadTestsFromName(test))
        #  (pyflakes.test.test_doctests.Test)
for module in module_tests:
    # g.trace(module)
    suite.addTest(loader.loadTestsFromModule(module))
unittest.TextTestRunner(verbosity=1).run(suite)</t>
<t tx="ekr.20160531210435.1">@language rest
@wrap

In retrospect, it would have been better to use pyflakes's unit tests from the beginning, but at that time I wasn't sure what the scope of the project would be.

Today's work reorganized the folder structure so it is possible to import pyflakes and pyflakes.test from with the project.  There were a few other changes, not interesting enough to recount here.

As of recent revs, the @button unit-test code works with both python 2 and 3.  This runs all unit tests except the test_api and test_doctests modules. The test_api fail because they depend on code outside this project.  The test_doctest tests fail for other reasons that I'm looking into.</t>
<t tx="ekr.20160603042535.1"></t>
</tnodes>
</leo_file>
