<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20160519180137.1"><vh>epytext markup</vh></v>
<v t="ekr.20160520102401.1"><vh>Reference</vh>
<v t="ekr.20160519172255.2"><vh>@@clean api.py</vh>
<v t="ekr.20160519172255.3"><vh>&lt;&lt;declarations&gt;&gt; (api)</vh></v>
<v t="ekr.20160519172255.4"><vh>api.check</vh></v>
<v t="ekr.20160519172255.5"><vh>api.checkPath</vh></v>
<v t="ekr.20160519172255.6"><vh>api.iterSourceCode</vh></v>
<v t="ekr.20160519172255.7"><vh>api.checkRecursive</vh></v>
<v t="ekr.20160519172255.8"><vh>api._exitOnSignal</vh></v>
<v t="ekr.20160519172255.9"><vh>api.main</vh></v>
</v>
<v t="ekr.20160519172255.79"><vh>@@clean messages.py</vh>
<v t="ekr.20160519172255.80"><vh>class Message</vh>
<v t="ekr.20160519172255.81"><vh>__init__</vh></v>
<v t="ekr.20160519172255.82"><vh>__str__</vh></v>
</v>
<v t="ekr.20160519172255.83"><vh>class UnusedImport</vh>
<v t="ekr.20160519172255.84"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.85"><vh>class RedefinedWhileUnused</vh>
<v t="ekr.20160519172255.86"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.87"><vh>class RedefinedInListComp</vh>
<v t="ekr.20160519172255.88"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.89"><vh>class ImportShadowedByLoopVar</vh>
<v t="ekr.20160519172255.90"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.91"><vh>class ImportStarUsed</vh>
<v t="ekr.20160519172255.92"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.93"><vh>class UndefinedName</vh>
<v t="ekr.20160519172255.94"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.95"><vh>class DoctestSyntaxError</vh>
<v t="ekr.20160519172255.96"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.97"><vh>class UndefinedExport</vh>
<v t="ekr.20160519172255.98"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.99"><vh>class UndefinedLocal</vh>
<v t="ekr.20160519172255.100"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.101"><vh>class DuplicateArgument</vh>
<v t="ekr.20160519172255.102"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.103"><vh>class LateFutureImport</vh>
<v t="ekr.20160519172255.104"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.105"><vh>class UnusedVariable</vh>
<v t="ekr.20160519172255.106"><vh>__init__</vh></v>
</v>
<v t="ekr.20160519172255.107"><vh>class ReturnWithArgsInsideGenerator</vh></v>
<v t="ekr.20160519172255.108"><vh>class ReturnOutsideFunction</vh></v>
</v>
<v t="ekr.20160519172255.109"><vh>@@clean reporter.py</vh>
<v t="ekr.20160519172255.110"><vh>&lt;&lt;declarations&gt;&gt; (reporter)</vh></v>
<v t="ekr.20160519172255.111"><vh>class Reporter</vh>
<v t="ekr.20160519172255.112"><vh>__init__</vh></v>
<v t="ekr.20160519172255.113"><vh>unexpectedError</vh></v>
<v t="ekr.20160519172255.114"><vh>syntaxError</vh></v>
<v t="ekr.20160519172255.115"><vh>flake</vh></v>
</v>
<v t="ekr.20160519172255.116"><vh>_makeDefaultReporter</vh></v>
</v>
<v t="ekr.20160519172255.117"><vh>@@clean __init__.py</vh></v>
<v t="ekr.20160519172255.119"><vh>@@clean __main__.py</vh>
<v t="ekr.20160519172255.120"><vh>&lt;&lt;declarations&gt;&gt; (__main__)</vh></v>
</v>
<v t="ekr.20160519172255.10"><vh>@@clean checker.py</vh>
<v t="ekr.20160519172255.11"><vh>&lt;&lt;imports&gt;&gt; (checker)</vh></v>
<v t="ekr.20160519181348.1"><vh>top-level getters</vh>
<v t="ekr.20160519181035.1"><vh>getAlternatives</vh></v>
<v t="ekr.20160519172255.39"><vh>getNodeName</vh></v>
<v t="ekr.20160519180953.1"><vh>getNodeType (returns uppercase class name)</vh></v>
<v t="ekr.20160519172255.15"><vh>iter_child_nodes</vh></v>
</v>
<v t="ekr.20160519172255.12"><vh>class _FieldsOrder(dict)</vh>
<v t="ekr.20160519172255.13"><vh>_get_fields</vh></v>
<v t="ekr.20160519172255.14"><vh>__missing__</vh></v>
</v>
<v t="ekr.20160519172710.1"><vh>Bindings &amp; Definitions</vh>
<v t="ekr.20160519172255.16"><vh>class Binding</vh>
<v t="ekr.20160519172255.17"><vh>__init__</vh></v>
<v t="ekr.20160519172255.18"><vh>__str__</vh></v>
<v t="ekr.20160519172255.19"><vh>__repr__</vh></v>
<v t="ekr.20160519172255.20"><vh>redefines</vh></v>
</v>
<v t="ekr.20160519172255.21"><vh>class Definition (Binding)</vh></v>
<v t="ekr.20160519172255.22"><vh>class Importation (Definition)</vh>
<v t="ekr.20160519172255.23"><vh>__init__</vh></v>
<v t="ekr.20160519172255.24"><vh>redefines</vh></v>
</v>
<v t="ekr.20160519172255.25"><vh>class Argument (Binding)</vh></v>
<v t="ekr.20160519172255.26"><vh>class Assignment (Binding)</vh></v>
<v t="ekr.20160519172255.27"><vh>class FunctionDefinition (Definition)</vh></v>
<v t="ekr.20160519172255.28"><vh>class ClassDefinition (Definition)</vh></v>
<v t="ekr.20160519172255.29"><vh>class ExportBinding (Binding)</vh>
<v t="ekr.20160519172255.30"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20160519172730.1"><vh>Scopes</vh>
<v t="ekr.20160519172255.31"><vh>class Scope</vh>
<v t="ekr.20160519172255.32"><vh>__repr__</vh></v>
</v>
<v t="ekr.20160519172255.33"><vh>class ClassScope (Scope)</vh></v>
<v t="ekr.20160519172255.34"><vh>class FunctionScope (Scope)</vh>
<v t="ekr.20160519172255.35"><vh>__init__</vh></v>
<v t="ekr.20160519172255.36"><vh>unusedAssignments</vh></v>
</v>
<v t="ekr.20160519172255.37"><vh>class GeneratorScope (Scope)</vh></v>
<v t="ekr.20160519172255.38"><vh>class ModuleScope (Scope)</vh></v>
</v>
<v t="ekr.20160519172255.40"><vh>class Checker</vh>
<v t="ekr.20160519172255.41"><vh>Checker.__init__</vh></v>
<v t="ekr.20160519172255.42"><vh>deferFunction</vh></v>
<v t="ekr.20160519172255.43"><vh>deferAssignment</vh></v>
<v t="ekr.20160519172255.44"><vh>runDeferred</vh></v>
<v t="ekr.20160519173318.1"><vh>scopes...</vh>
<v t="ekr.20160519172255.45"><vh>scope (property)</vh></v>
<v t="ekr.20160519172255.46"><vh>popScope</vh></v>
<v t="ekr.20160519172255.47"><vh>checkDeadScopes</vh></v>
<v t="ekr.20160519172255.48"><vh>pushScope</vh></v>
</v>
<v t="ekr.20160519172255.49"><vh>report</vh></v>
<v t="ekr.20160519173339.1"><vh>tree structure</vh>
<v t="ekr.20160519172255.50"><vh>getParent</vh></v>
<v t="ekr.20160519172255.51"><vh>getCommonAncestor</vh></v>
<v t="ekr.20160519172255.52"><vh>descendantOf</vh></v>
<v t="ekr.20160519172255.53"><vh>differentForks</vh></v>
</v>
<v t="ekr.20160519172255.54"><vh>addBinding</vh></v>
<v t="ekr.20160519172255.55"><vh>getNodeHandler</vh></v>
<v t="ekr.20160519173152.1"><vh>handle...</vh>
<v t="ekr.20160519172255.59"><vh>handleChildren</vh></v>
<v t="ekr.20160519172255.64"><vh>handleDoctests</vh></v>
<v t="ekr.20160519172255.63"><vh>handleNode (sets parent/depth fields)</vh></v>
<v t="ekr.20160519172255.58"><vh>handleNodeDelete</vh></v>
<v t="ekr.20160519172255.56"><vh>handleNodeLoad</vh></v>
<v t="ekr.20160519172255.57"><vh>handleNodeStore</vh></v>
</v>
<v t="ekr.20160519172255.60"><vh>isLiteralTupleUnpacking</vh></v>
<v t="ekr.20160519172255.61"><vh>isDocstring</vh></v>
<v t="ekr.20160519172255.62"><vh>getDocstring</vh></v>
<v t="ekr.20160519172255.65"><vh>ignore</vh></v>
<v t="ekr.20160519172836.1"><vh>Node handlers</vh>
<v t="ekr.20160519172255.66"><vh>GLOBAL &amp; NONLOCAL</vh></v>
<v t="ekr.20160519172255.67"><vh>GENERATOREXP &amp; comprehensions</vh></v>
<v t="ekr.20160519172255.68"><vh>NAME</vh></v>
<v t="ekr.20160519172255.69"><vh>RETURN</vh></v>
<v t="ekr.20160519172255.70"><vh>YIELD</vh></v>
<v t="ekr.20160519172255.71"><vh>FUNCTIONDEF</vh></v>
<v t="ekr.20160519172255.72"><vh>LAMBDA</vh></v>
<v t="ekr.20160519172255.73"><vh>CLASSDEF</vh></v>
<v t="ekr.20160519172255.74"><vh>AUGASSIGN</vh></v>
<v t="ekr.20160519172255.75"><vh>IMPORT</vh></v>
<v t="ekr.20160519172255.76"><vh>IMPORTFROM</vh></v>
<v t="ekr.20160519172255.77"><vh>TRY</vh></v>
<v t="ekr.20160519172255.78"><vh>EXCEPTHANDLER</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20160519172947.1"><vh>Found:handleChildren</vh>
<v t="ekr.20160519172255.67"></v>
<v t="ekr.20160519172255.77"></v>
<v t="ekr.20160519172255.78"></v>
<v t="ekr.20160519172255.59"></v>
<v t="ekr.20160519172255.64"></v>
<v t="ekr.20160519172255.41"></v>
</v>
<v t="ekr.20160519182919.1"><vh>test of getFields code</vh></v>
<v t="ekr.20160519173152.1"></v>
<v t="ekr.20160519172836.1"></v>
<v t="ekr.20160519185320.1"><vh>Found:getAlternatives</vh>
<v t="ekr.20160519172255.53"></v>
<v t="ekr.20160519181035.1"></v>
</v>
<v t="ekr.20160520081237.1"><vh>@button test @key=Ctrl-1</vh>
<v t="ekr.20160519172255.11"></v>
<v t="ekr.20160520081718.1"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20160519172255.12"></v>
<v t="ekr.20160519181348.1"></v>
<v t="ekr.20160519172710.1"></v>
<v t="ekr.20160519172730.1"></v>
<v t="ekr.20160519172255.40"></v>
<v t="ekr.20160520081827.1"><vh>run_test &amp; helpers</vh>
<v t="ekr.20160520082209.1"><vh>check_all</vh></v>
<v t="ekr.20160520082308.1"><vh>api.check</vh></v>
<v t="ekr.20160520082346.1"><vh>class Reporter</vh>
<v t="ekr.20160520082346.2"><vh>__init__</vh></v>
<v t="ekr.20160520082346.3"><vh>unexpectedError</vh></v>
<v t="ekr.20160520082346.4"><vh>syntaxError</vh></v>
<v t="ekr.20160520082346.5"><vh>flake</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20160519172255.10">"""
Main module.

Implement the central Checker class.
Also, it models the Bindings and Scopes.
"""

@language python
@tabwidth -4

&lt;&lt;imports&gt;&gt;

# Globally defined names which are not attributes of the builtins module, or
# are only present on some platforms.
_MAGIC_GLOBALS = ['__file__', '__builtins__', 'WindowsError']

@others
</t>
<t tx="ekr.20160519172255.100">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.101">class DuplicateArgument(Message):
    message = 'duplicate argument %r in function definition'

    @others
</t>
<t tx="ekr.20160519172255.102">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.103">class LateFutureImport(Message):
    message = 'future import(s) %r after other statements'

    @others
</t>
<t tx="ekr.20160519172255.104">def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)
</t>
<t tx="ekr.20160519172255.105">class UnusedVariable(Message):
    """
    Indicates that a variable has been explicity assigned to but not actually
    used.
    """
    message = 'local variable %r is assigned to but never used'

    @others
</t>
<t tx="ekr.20160519172255.106">def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)
</t>
<t tx="ekr.20160519172255.107">class ReturnWithArgsInsideGenerator(Message):
    """
    Indicates a return statement with arguments inside a generator.
    """
    message = '\'return\' with argument inside generator'
</t>
<t tx="ekr.20160519172255.108">class ReturnOutsideFunction(Message):
    """
    Indicates a return statement outside of a function/method.
    """
    message = '\'return\' outside function'
</t>
<t tx="ekr.20160519172255.109">"""
Provide the Reporter class.
"""

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="ekr.20160519172255.11">import doctest
import os
import sys

PY2 = sys.version_info &lt; (3, 0)
PY32 = sys.version_info &lt; (3, 3)    # Python 2.5 to 3.2
PY33 = sys.version_info &lt; (3, 4)    # Python 2.5 to 3.3
builtin_vars = dir(__import__('__builtin__' if PY2 else 'builtins'))

try:
    import ast
except ImportError:     # Python 2.5
    import _ast as ast

    if 'decorator_list' not in ast.ClassDef._fields:
        # Patch the missing attribute 'decorator_list'
        ast.ClassDef.decorator_list = ()
        ast.FunctionDef.decorator_list = property(lambda s: s.decorators)

from pyflakes import messages
</t>
<t tx="ekr.20160519172255.110">import re
import sys
</t>
<t tx="ekr.20160519172255.111">class Reporter(object):
    """
    Formats the results of pyflakes checks to users.
    """
    @others
</t>
<t tx="ekr.20160519172255.112">def __init__(self, warningStream, errorStream):
    """
    Construct a L{Reporter}.

    @param warningStream: A file-like object where warnings will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stdout} is a good value.
    @param errorStream: A file-like object where error output will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stderr} is a good value.
    """
    self._stdout = warningStream
    self._stderr = errorStream
</t>
<t tx="ekr.20160519172255.113">def unexpectedError(self, filename, msg):
    """
    An unexpected error occurred trying to process C{filename}.

    @param filename: The path to a file that we could not process.
    @ptype filename: C{unicode}
    @param msg: A message explaining the problem.
    @ptype msg: C{unicode}
    """
    self._stderr.write("%s: %s\n" % (filename, msg))
</t>
<t tx="ekr.20160519172255.114">def syntaxError(self, filename, msg, lineno, offset, text):
    """
    There was a syntax errror in C{filename}.

    @param filename: The path to the file with the syntax error.
    @ptype filename: C{unicode}
    @param msg: An explanation of the syntax error.
    @ptype msg: C{unicode}
    @param lineno: The line number where the syntax error occurred.
    @ptype lineno: C{int}
    @param offset: The column on which the syntax error occurred, or None.
    @ptype offset: C{int}
    @param text: The source code containing the syntax error.
    @ptype text: C{unicode}
    """
    line = text.splitlines()[-1]
    if offset is not None:
        offset = offset - (len(text) - len(line))
        self._stderr.write('%s:%d:%d: %s\n' %
                           (filename, lineno, offset + 1, msg))
    else:
        self._stderr.write('%s:%d: %s\n' % (filename, lineno, msg))
    self._stderr.write(line)
    self._stderr.write('\n')
    if offset is not None:
        self._stderr.write(re.sub(r'\S', ' ', line[:offset]) +
                           "^\n")
</t>
<t tx="ekr.20160519172255.115">def flake(self, message):
    """
    pyflakes found something wrong with the code.

    @param: A L{pyflakes.messages.Message}.
    """
    self._stdout.write(str(message))
    self._stdout.write('\n')
</t>
<t tx="ekr.20160519172255.116">def _makeDefaultReporter():
    """
    Make a reporter that can be used when no reporter is specified.
    """
    return Reporter(sys.stdout, sys.stderr)
</t>
<t tx="ekr.20160519172255.117">@language python
@tabwidth -4
__version__ = '1.0.0'

</t>
<t tx="ekr.20160519172255.119">@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="ekr.20160519172255.12">class _FieldsOrder(dict):
    """Fix order of AST node fields."""
    @others
</t>
<t tx="ekr.20160519172255.120">from pyflakes.api import main

# python -m pyflakes (with Python &gt;= 2.7)
if __name__ == '__main__':
    main(prog='pyflakes')
</t>
<t tx="ekr.20160519172255.13">def _get_fields(self, node_class):
    # handle iter before target, and generators before element
    # EKR: the effect of the key is to assign 0 to 'iter' or 'generators' or 'value'
    # and -1 to everything else. So the target is *last*, so reverse=True is needed.
    fields = node_class._fields
    if 'iter' in fields:
        key_first = 'iter'.find
    elif 'generators' in fields:
        key_first = 'generators'.find
    else:
        key_first = 'value'.find
    return tuple(sorted(fields, key=key_first, reverse=True))


</t>
<t tx="ekr.20160519172255.14">def __missing__(self, node_class):
    # EKR: called if self[node_class] does not exist.
    self[node_class] = fields = self._get_fields(node_class)
    return fields
</t>
<t tx="ekr.20160519172255.15">def iter_child_nodes(node, omit=None, _fields_order=_FieldsOrder()):
    """
    Yield all direct child nodes of *node*, that is, all fields that
    are nodes and all items of fields that are lists of nodes.
    """
    for name in _fields_order[node.__class__]:
        if name == omit:
            continue
        field = getattr(node, name, None)
        if isinstance(field, ast.AST):
            yield field
        elif isinstance(field, list):
            for item in field:
                yield item
</t>
<t tx="ekr.20160519172255.16">class Binding(object):
    """
    Represents the binding of a value to a name.

    The checker uses this to keep track of which names have been bound and
    which names have not. See L{Assignment} for a special type of binding that
    is checked with stricter rules.

    @ivar used: pair of (L{Scope}, line-number) indicating the scope and
                line number that this binding was last used
    """
    @others
</t>
<t tx="ekr.20160519172255.17">def __init__(self, name, source):
    self.name = name
    self.source = source
    self.used = False
</t>
<t tx="ekr.20160519172255.18">def __str__(self):
    return self.name
</t>
<t tx="ekr.20160519172255.19">def __repr__(self):
    return '&lt;%s object %r from line %r at 0x%x&gt;' % (self.__class__.__name__,
                                                    self.name,
                                                    self.source.lineno,
                                                    id(self))
</t>
<t tx="ekr.20160519172255.2">"""
API for the command-line I{pyflakes} tool.
"""

@language python
@tabwidth -4

&lt;&lt;declarations&gt;&gt;
@others
</t>
<t tx="ekr.20160519172255.20">def redefines(self, other):
    return isinstance(other, Definition) and self.name == other.name
</t>
<t tx="ekr.20160519172255.21">class Definition(Binding):
    """
    A binding that defines a function or a class.
    """
</t>
<t tx="ekr.20160519172255.22">class Importation(Definition):
    """
    A binding created by an import statement.

    @ivar fullName: The complete name given to the import statement,
        possibly including multiple dotted components.
    @type fullName: C{str}
    """
    @others
</t>
<t tx="ekr.20160519172255.23">def __init__(self, name, source):
    self.fullName = name
    self.redefined = []
    name = name.split('.')[0]
    super(Importation, self).__init__(name, source)
</t>
<t tx="ekr.20160519172255.24">def redefines(self, other):
    if isinstance(other, Importation):
        return self.fullName == other.fullName
    return isinstance(other, Definition) and self.name == other.name
</t>
<t tx="ekr.20160519172255.25">class Argument(Binding):
    """
    Represents binding a name as an argument.
    """
</t>
<t tx="ekr.20160519172255.26">class Assignment(Binding):
    """
    Represents binding a name with an explicit assignment.

    The checker will raise warnings for any Assignment that isn't used. Also,
    the checker does not consider assignments in tuple/list unpacking to be
    Assignments, rather it treats them as simple Bindings.
    """
</t>
<t tx="ekr.20160519172255.27">class FunctionDefinition(Definition):
    pass
</t>
<t tx="ekr.20160519172255.28">class ClassDefinition(Definition):
    pass
</t>
<t tx="ekr.20160519172255.29">class ExportBinding(Binding):
    """
    A binding created by an C{__all__} assignment.  If the names in the list
    can be determined statically, they will be treated as names for export and
    additional checking applied to them.

    The only C{__all__} assignment that can be recognized is one which takes
    the value of a literal list containing literal strings.  For example::

        __all__ = ["foo", "bar"]

    Names which are imported and not otherwise used but appear in the value of
    C{__all__} will not have an unused import warning reported for them.
    """
    @others
</t>
<t tx="ekr.20160519172255.3">from __future__ import with_statement

import sys
import os
import _ast

from pyflakes import checker, __version__
from pyflakes import reporter as modReporter

__all__ = ['check', 'checkPath', 'checkRecursive', 'iterSourceCode', 'main']
</t>
<t tx="ekr.20160519172255.30">def __init__(self, name, source, scope):
    if '__all__' in scope and isinstance(source, ast.AugAssign):
        self.names = list(scope['__all__'].names)
    else:
        self.names = []
    if isinstance(source.value, (ast.List, ast.Tuple)):
        for node in source.value.elts:
            if isinstance(node, ast.Str):
                self.names.append(node.s)
    super(ExportBinding, self).__init__(name, source)
</t>
<t tx="ekr.20160519172255.31">class Scope(dict):
    importStarred = False       # set to True when import * is found

    @others
</t>
<t tx="ekr.20160519172255.32">def __repr__(self):
    scope_cls = self.__class__.__name__
    return '&lt;%s at 0x%x %s&gt;' % (scope_cls, id(self), dict.__repr__(self))
</t>
<t tx="ekr.20160519172255.33">class ClassScope(Scope):
    pass
</t>
<t tx="ekr.20160519172255.34">class FunctionScope(Scope):
    """
    I represent a name scope for a function.

    @ivar globals: Names declared 'global' in this function.
    """
    usesLocals = False
    alwaysUsed = set(['__tracebackhide__',
                      '__traceback_info__', '__traceback_supplement__'])

    @others
</t>
<t tx="ekr.20160519172255.35">def __init__(self):
    super(FunctionScope, self).__init__()
    # Simplify: manage the special locals as globals
    self.globals = self.alwaysUsed.copy()
    self.returnValue = None     # First non-empty return
    self.isGenerator = False    # Detect a generator
</t>
<t tx="ekr.20160519172255.36">def unusedAssignments(self):
    """
    Return a generator for the assignments which have not been used.
    """
    for name, binding in self.items():
        if (not binding.used and name not in self.globals
                and not self.usesLocals
                and isinstance(binding, Assignment)):
            yield name, binding
</t>
<t tx="ekr.20160519172255.37">class GeneratorScope(Scope):
    pass
</t>
<t tx="ekr.20160519172255.38">class ModuleScope(Scope):
    pass
</t>
<t tx="ekr.20160519172255.39">
def getNodeName(node):
    # Returns node.id, or node.name, or None
    if hasattr(node, 'id'):     # One of the many nodes with an id
        return node.id
    if hasattr(node, 'name'):   # a ExceptHandler node
        return node.name
</t>
<t tx="ekr.20160519172255.4">def check(codeString, filename, reporter=None):
    """
    Check the Python source given by C{codeString} for flakes.

    @param codeString: The Python source to check.
    @type codeString: C{str}

    @param filename: The name of the file the source came from, used to report
        errors.
    @type filename: C{str}

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: The number of warnings emitted.
    @rtype: C{int}
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    # First, compile into an AST and handle syntax errors.
    try:
        tree = compile(codeString, filename, "exec", _ast.PyCF_ONLY_AST)
    except SyntaxError:
        value = sys.exc_info()[1]
        msg = value.args[0]

        (lineno, offset, text) = value.lineno, value.offset, value.text

        # If there's an encoding problem with the file, the text is None.
        if text is None:
            # Avoid using msg, since for the only known case, it contains a
            # bogus message that claims the encoding the file declared was
            # unknown.
            reporter.unexpectedError(filename, 'problem decoding source')
        else:
            reporter.syntaxError(filename, msg, lineno, offset, text)
        return 1
    except Exception:
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    # Okay, it's syntactically valid.  Now check it.
    w = checker.Checker(tree, filename)
    w.messages.sort(key=lambda m: m.lineno)
    for warning in w.messages:
        reporter.flake(warning)
    return len(w.messages)
</t>
<t tx="ekr.20160519172255.40">class Checker(object):
    """
    I check the cleanliness and sanity of Python code.

    @ivar _deferredFunctions: Tracking list used by L{deferFunction}.  Elements
        of the list are two-tuples.  The first element is the callable passed
        to L{deferFunction}.  The second element is a copy of the scope stack
        at the time L{deferFunction} was called.

    @ivar _deferredAssignments: Similar to C{_deferredFunctions}, but for
        callables which are deferred assignment checks.
    """

    nodeDepth = 0
    offset = None
    traceTree = False

    builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)
    _customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')
    if _customBuiltIns:
        builtIns.update(_customBuiltIns.split(','))
    del _customBuiltIns

    @others
</t>
<t tx="ekr.20160519172255.41">def __init__(self, tree, filename='(none)', builtins=None,
             withDoctest='PYFLAKES_DOCTEST' in os.environ):
    self._nodeHandlers = {}
    self._deferredFunctions = []
    self._deferredAssignments = []
    self.deadScopes = []
    self.messages = []
    self.filename = filename
    if builtins:
        self.builtIns = self.builtIns.union(builtins)
    self.withDoctest = withDoctest
    self.scopeStack = [ModuleScope()]
    self.exceptHandlers = [()]
    self.futuresAllowed = True
    self.root = tree
    self.handleChildren(tree)
        # EKR: visit the children of the module node.
    self.runDeferred(self._deferredFunctions)
    # Set _deferredFunctions to None so that deferFunction will fail
    # noisily if called after we've run through the deferred functions.
    self._deferredFunctions = None
    self.runDeferred(self._deferredAssignments)
    # Set _deferredAssignments to None so that deferAssignment will fail
    # noisily if called after we've run through the deferred assignments.
    self._deferredAssignments = None
    del self.scopeStack[1:]
    self.popScope()
    self.checkDeadScopes()
</t>
<t tx="ekr.20160519172255.42">def deferFunction(self, callable):
    """
    Schedule a function handler to be called just before completion.

    This is used for handling function bodies, which must be deferred
    because code later in the file might modify the global scope. When
    `callable` is called, the scope at the time this is called will be
    restored, however it will contain any new bindings added to it.
    """
    self._deferredFunctions.append((callable, self.scopeStack[:], self.offset))
</t>
<t tx="ekr.20160519172255.43">def deferAssignment(self, callable):
    """
    Schedule an assignment handler to be called just after deferred
    function handlers.
    """
    self._deferredAssignments.append((callable, self.scopeStack[:], self.offset))
</t>
<t tx="ekr.20160519172255.44">def runDeferred(self, deferred):
    """
    Run the callables in C{deferred} using their associated scope stack.
    """
    for handler, scope, offset in deferred:
        self.scopeStack = scope
        self.offset = offset
        handler()
</t>
<t tx="ekr.20160519172255.45">@property
def scope(self):
    return self.scopeStack[-1]
</t>
<t tx="ekr.20160519172255.46">def popScope(self):
    self.deadScopes.append(self.scopeStack.pop())
</t>
<t tx="ekr.20160519172255.47">def checkDeadScopes(self):
    """
    Look at scopes which have been fully examined and report names in them
    which were imported but unused.
    """
    for scope in self.deadScopes:
        if isinstance(scope.get('__all__'), ExportBinding):
            all_names = set(scope['__all__'].names)
            if not scope.importStarred and \
               os.path.basename(self.filename) != '__init__.py':
                # Look for possible mistakes in the export list
                undefined = all_names.difference(scope)
                for name in undefined:
                    self.report(messages.UndefinedExport,
                                scope['__all__'].source, name)
        else:
            all_names = []

        # Look for imported names that aren't used.
        for value in scope.values():
            if isinstance(value, Importation):
                used = value.used or value.name in all_names
                if not used:
                    messg = messages.UnusedImport
                    self.report(messg, value.source, value.name)
                for node in value.redefined:
                    if isinstance(self.getParent(node), ast.For):
                        messg = messages.ImportShadowedByLoopVar
                    elif used:
                        continue
                    else:
                        messg = messages.RedefinedWhileUnused
                    self.report(messg, node, value.name, value.source)
</t>
<t tx="ekr.20160519172255.48">def pushScope(self, scopeClass=FunctionScope):
    self.scopeStack.append(scopeClass())
</t>
<t tx="ekr.20160519172255.49">def report(self, messageClass, *args, **kwargs):
    self.messages.append(messageClass(self.filename, *args, **kwargs))
</t>
<t tx="ekr.20160519172255.5">def checkPath(filename, reporter=None):
    """
    Check the given path, printing out any warnings detected.

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: the number of warnings printed
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    try:
        # in Python 2.6, compile() will choke on \r\n line endings. In later
        # versions of python it's smarter, and we want binary mode to give
        # compile() the best opportunity to do the right thing WRT text
        # encodings.
        if sys.version_info &lt; (2, 7):
            mode = 'rU'
        else:
            mode = 'rb'

        with open(filename, mode) as f:
            codestr = f.read()
        if sys.version_info &lt; (2, 7):
            codestr += '\n'     # Work around for Python &lt;= 2.6
    except UnicodeError:
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    except IOError:
        msg = sys.exc_info()[1]
        reporter.unexpectedError(filename, msg.args[1])
        return 1
    return check(codestr, filename, reporter)
</t>
<t tx="ekr.20160519172255.50">def getParent(self, node):
    # Lookup the first parent which is not Tuple, List or Starred
    # EKR: handleNode sets node.parent.
    while True:
        node = node.parent
        if not hasattr(node, 'elts') and not hasattr(node, 'ctx'):
            return node
</t>
<t tx="ekr.20160519172255.51">def getCommonAncestor(self, lnode, rnode, stop):
    if stop in (lnode, rnode) or not (hasattr(lnode, 'parent') and
                                      hasattr(rnode, 'parent')):
        return None
    if lnode is rnode:
        return lnode

    if (lnode.depth &gt; rnode.depth):
        return self.getCommonAncestor(lnode.parent, rnode, stop)
    if (lnode.depth &lt; rnode.depth):
        return self.getCommonAncestor(lnode, rnode.parent, stop)
    return self.getCommonAncestor(lnode.parent, rnode.parent, stop)
</t>
<t tx="ekr.20160519172255.52">def descendantOf(self, node, ancestors, stop):
    for a in ancestors:
        if self.getCommonAncestor(node, a, stop):
            return True
    return False
</t>
<t tx="ekr.20160519172255.53">def differentForks(self, lnode, rnode):
    """True, if lnode and rnode are located on different forks of IF/TRY"""
    ancestor = self.getCommonAncestor(lnode, rnode, self.root)
    parts = getAlternatives(ancestor)
    if parts:
        for items in parts:
            if self.descendantOf(lnode, items, ancestor) ^ \
               self.descendantOf(rnode, items, ancestor):
                return True
    return False
</t>
<t tx="ekr.20160519172255.54">def addBinding(self, node, value):
    """
    Called when a binding is altered.

    - `node` is the statement responsible for the change
    - `value` is the new value, a Binding instance
    """
    # assert value.source in (node, node.parent):
    for scope in self.scopeStack[::-1]:
        if value.name in scope:
            break
    existing = scope.get(value.name)

    if existing and not self.differentForks(node, existing.source):

        parent_stmt = self.getParent(value.source)
        if isinstance(existing, Importation) and isinstance(parent_stmt, ast.For):
            self.report(messages.ImportShadowedByLoopVar,
                        node, value.name, existing.source)

        elif scope is self.scope:
            if (isinstance(parent_stmt, ast.comprehension) and
                    not isinstance(self.getParent(existing.source),
                                   (ast.For, ast.comprehension))):
                self.report(messages.RedefinedInListComp,
                            node, value.name, existing.source)
            elif not existing.used and value.redefines(existing):
                self.report(messages.RedefinedWhileUnused,
                            node, value.name, existing.source)

        elif isinstance(existing, Importation) and value.redefines(existing):
            existing.redefined.append(node)

    if value.name in self.scope:
        # then assume the rebound name is used as a global or within a loop
        value.used = self.scope[value.name].used

    self.scope[value.name] = value
</t>
<t tx="ekr.20160519172255.55">def getNodeHandler(self, node_class):
    try:
        return self._nodeHandlers[node_class]
    except KeyError:
        nodeType = getNodeType(node_class)
    self._nodeHandlers[node_class] = handler = getattr(self, nodeType)
    return handler
</t>
<t tx="ekr.20160519172255.56">def handleNodeLoad(self, node):
    name = getNodeName(node)
    if not name:
        return
    # try local scope
    try:
        self.scope[name].used = (self.scope, node)
    except KeyError:
        pass
    else:
        return

    scopes = [scope for scope in self.scopeStack[:-1]
              if isinstance(scope, (FunctionScope, ModuleScope, GeneratorScope))]
    if isinstance(self.scope, GeneratorScope) and scopes[-1] != self.scopeStack[-2]:
        scopes.append(self.scopeStack[-2])

    # try enclosing function scopes and global scope
    importStarred = self.scope.importStarred
    for scope in reversed(scopes):
        importStarred = importStarred or scope.importStarred
        try:
            scope[name].used = (self.scope, node)
        except KeyError:
            pass
        else:
            return

    # look in the built-ins
    if importStarred or name in self.builtIns:
        return
    if name == '__path__' and os.path.basename(self.filename) == '__init__.py':
        # the special name __path__ is valid only in packages
        return

    # protected with a NameError handler?
    if 'NameError' not in self.exceptHandlers[-1]:
        self.report(messages.UndefinedName, node, name)
</t>
<t tx="ekr.20160519172255.57">def handleNodeStore(self, node):
    name = getNodeName(node)
    if not name:
        return
    # if the name hasn't already been defined in the current scope
    if isinstance(self.scope, FunctionScope) and name not in self.scope:
        # for each function or module scope above us
        for scope in self.scopeStack[:-1]:
            if not isinstance(scope, (FunctionScope, ModuleScope)):
                continue
            # if the name was defined in that scope, and the name has
            # been accessed already in the current scope, and hasn't
            # been declared global
            used = name in scope and scope[name].used
            if used and used[0] is self.scope and name not in self.scope.globals:
                # then it's probably a mistake
                self.report(messages.UndefinedLocal,
                            scope[name].used[1], name, scope[name].source)
                break

    parent_stmt = self.getParent(node)
    if isinstance(parent_stmt, (ast.For, ast.comprehension)) or (
            parent_stmt != node.parent and
            not self.isLiteralTupleUnpacking(parent_stmt)):
        binding = Binding(name, node)
    elif name == '__all__' and isinstance(self.scope, ModuleScope):
        binding = ExportBinding(name, node.parent, self.scope)
    else:
        binding = Assignment(name, node)
    self.addBinding(node, binding)
</t>
<t tx="ekr.20160519172255.58">def handleNodeDelete(self, node):

    def on_conditional_branch():
        """
        Return `True` if node is part of a conditional body.
        """
        current = getattr(node, 'parent', None)
        while current:
            if isinstance(current, (ast.If, ast.While, ast.IfExp)):
                return True
            current = getattr(current, 'parent', None)
        return False

    name = getNodeName(node)
    if not name:
        return

    if on_conditional_branch():
        # We can not predict if this conditional branch is going to
        # be executed.
        return

    if isinstance(self.scope, FunctionScope) and name in self.scope.globals:
        self.scope.globals.remove(name)
    else:
        try:
            del self.scope[name]
        except KeyError:
            self.report(messages.UndefinedName, node, name)
</t>
<t tx="ekr.20160519172255.59">def handleChildren(self, tree, omit=None):
    for node in iter_child_nodes(tree, omit=omit):
        self.handleNode(node, tree)
</t>
<t tx="ekr.20160519172255.6">def iterSourceCode(paths):
    """
    Iterate over all Python source files in C{paths}.

    @param paths: A list of paths.  Directories will be recursed into and
        any .py files found will be yielded.  Any non-directories will be
        yielded as-is.
    """
    for path in paths:
        if os.path.isdir(path):
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    if filename.endswith('.py'):
                        yield os.path.join(dirpath, filename)
        else:
            yield path
</t>
<t tx="ekr.20160519172255.60">def isLiteralTupleUnpacking(self, node):
    if isinstance(node, ast.Assign):
        for child in node.targets + [node.value]:
            if not hasattr(child, 'elts'):
                return False
        return True
</t>
<t tx="ekr.20160519172255.61">def isDocstring(self, node):
    """
    Determine if the given node is a docstring, as long as it is at the
    correct place in the node tree.
    """
    return isinstance(node, ast.Str) or (isinstance(node, ast.Expr) and
                                         isinstance(node.value, ast.Str))
</t>
<t tx="ekr.20160519172255.62">def getDocstring(self, node):
    if isinstance(node, ast.Expr):
        node = node.value
    if not isinstance(node, ast.Str):
        return (None, None)
    # Computed incorrectly if the docstring has backslash
    doctest_lineno = node.lineno - node.s.count('\n') - 1
    return (node.s, doctest_lineno)
</t>
<t tx="ekr.20160519172255.63">def handleNode(self, node, parent):
    # EKR: this the general node visiter.
    if node is None:
        return
    if self.offset and getattr(node, 'lineno', None) is not None:
        node.lineno += self.offset[0]
        node.col_offset += self.offset[1]
    if self.traceTree:
        print('  ' * self.nodeDepth + node.__class__.__name__)
    if self.futuresAllowed and not (isinstance(node, ast.ImportFrom) or
                                    self.isDocstring(node)):
        self.futuresAllowed = False
    self.nodeDepth += 1
    node.depth = self.nodeDepth
    node.parent = parent
    try:
        # EKR: this is the only call to getNodeHandler.
        handler = self.getNodeHandler(node.__class__)
        handler(node)
    finally:
        self.nodeDepth -= 1
    if self.traceTree:
        print('  ' * self.nodeDepth + 'end ' + node.__class__.__name__)

_getDoctestExamples = doctest.DocTestParser().get_examples
</t>
<t tx="ekr.20160519172255.64">def handleDoctests(self, node):
    try:
        (docstring, node_lineno) = self.getDocstring(node.body[0])
        examples = docstring and self._getDoctestExamples(docstring)
    except (ValueError, IndexError):
        # e.g. line 6 of the docstring for &lt;string&gt; has inconsistent
        # leading whitespace: ...
        return
    if not examples:
        return
    node_offset = self.offset or (0, 0)
    self.pushScope()
    underscore_in_builtins = '_' in self.builtIns
    if not underscore_in_builtins:
        self.builtIns.add('_')
    for example in examples:
        try:
            tree = compile(example.source, "&lt;doctest&gt;", "exec", ast.PyCF_ONLY_AST)
        except SyntaxError:
            e = sys.exc_info()[1]
            position = (node_lineno + example.lineno + e.lineno,
                        example.indent + 4 + (e.offset or 0))
            self.report(messages.DoctestSyntaxError, node, position)
        else:
            self.offset = (node_offset[0] + node_lineno + example.lineno,
                           node_offset[1] + example.indent + 4)
            self.handleChildren(tree)
            self.offset = node_offset
    if not underscore_in_builtins:
        self.builtIns.remove('_')
    self.popScope()
</t>
<t tx="ekr.20160519172255.65">def ignore(self, node):
    pass
</t>
<t tx="ekr.20160519172255.66">def GLOBAL(self, node):
    """
    Keep track of globals declarations.
    """
    # In doctests, the global scope is an anonymous function at index 1.
    global_scope_index = 1 if self.withDoctest else 0
    global_scope = self.scopeStack[global_scope_index]

    # Ignore 'global' statement in global scope.
    if self.scope is not global_scope:

        # One 'global' statement can bind multiple (comma-delimited) names.
        for node_name in node.names:
            node_value = Assignment(node_name, node)

            # Remove UndefinedName messages already reported for this name.
            self.messages = [
                m for m in self.messages if not
                isinstance(m, messages.UndefinedName) and not
                m.message_args[0] == node_name]

            # Bind name to global scope if it doesn't exist already.
            global_scope.setdefault(node_name, node_value)

            # Bind name to non-global scopes, but as already "used".
            node_value.used = (global_scope, node)
            for scope in self.scopeStack[global_scope_index + 1:]:
                scope[node_name] = node_value

NONLOCAL = GLOBAL
</t>
<t tx="ekr.20160519172255.67">def GENERATOREXP(self, node):
    self.pushScope(GeneratorScope)
    self.handleChildren(node)
    self.popScope()

LISTCOMP = handleChildren if PY2 else GENERATOREXP

DICTCOMP = SETCOMP = GENERATOREXP
</t>
<t tx="ekr.20160519172255.68">def NAME(self, node):
    """
    Handle occurrence of Name (which can be a load/store/delete access.)
    """
    # Locate the name in locals / function / globals scopes.
    if isinstance(node.ctx, (ast.Load, ast.AugLoad)):
        self.handleNodeLoad(node)
        if (node.id == 'locals' and isinstance(self.scope, FunctionScope)
                and isinstance(node.parent, ast.Call)):
            # we are doing locals() call in current scope
            self.scope.usesLocals = True
    elif isinstance(node.ctx, (ast.Store, ast.AugStore)):
        self.handleNodeStore(node)
    elif isinstance(node.ctx, ast.Del):
        self.handleNodeDelete(node)
    else:
        # must be a Param context -- this only happens for names in function
        # arguments, but these aren't dispatched through here
        raise RuntimeError("Got impossible expression context: %r" % (node.ctx,))
</t>
<t tx="ekr.20160519172255.69">def RETURN(self, node):
    
    if isinstance(self.scope, ClassScope):
        self.report(messages.ReturnOutsideFunction, node)
        return
    if (
        node.value and
        hasattr(self.scope, 'returnValue') and
        not self.scope.returnValue
    ):
        self.scope.returnValue = node.value
    self.handleNode(node.value, node)
</t>
<t tx="ekr.20160519172255.7">def checkRecursive(paths, reporter):
    """
    Recursively check all source files in C{paths}.

    @param paths: A list of paths to Python source files and directories
        containing Python source files.
    @param reporter: A L{Reporter} where all of the warnings and errors
        will be reported to.
    @return: The number of warnings found.
    """
    warnings = 0
    for sourcePath in iterSourceCode(paths):
        warnings += checkPath(sourcePath, reporter)
    return warnings
</t>
<t tx="ekr.20160519172255.70">def YIELD(self, node):
    self.scope.isGenerator = True
    self.handleNode(node.value, node)

AWAIT = YIELDFROM = YIELD
</t>
<t tx="ekr.20160519172255.71">def FUNCTIONDEF(self, node):
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    self.LAMBDA(node)
    self.addBinding(node, FunctionDefinition(node.name, node))
    if self.withDoctest:
        self.deferFunction(lambda: self.handleDoctests(node))

ASYNCFUNCTIONDEF = FUNCTIONDEF
</t>
<t tx="ekr.20160519172255.72">def LAMBDA(self, node):
    args = []
    annotations = []

    if PY2:
        def addArgs(arglist):
            for arg in arglist:
                if isinstance(arg, ast.Tuple):
                    addArgs(arg.elts)
                else:
                    args.append(arg.id)
        addArgs(node.args.args)
        defaults = node.args.defaults
    else:
        for arg in node.args.args + node.args.kwonlyargs:
            args.append(arg.arg)
            annotations.append(arg.annotation)
        defaults = node.args.defaults + node.args.kw_defaults

    # Only for Python3 FunctionDefs
    is_py3_func = hasattr(node, 'returns')

    for arg_name in ('vararg', 'kwarg'):
        wildcard = getattr(node.args, arg_name)
        if not wildcard:
            continue
        args.append(wildcard if PY33 else wildcard.arg)
        if is_py3_func:
            if PY33:  # Python 2.5 to 3.3
                argannotation = arg_name + 'annotation'
                annotations.append(getattr(node.args, argannotation))
            else:     # Python &gt;= 3.4
                annotations.append(wildcard.annotation)

    if is_py3_func:
        annotations.append(node.returns)

    if len(set(args)) &lt; len(args):
        for (idx, arg) in enumerate(args):
            if arg in args[:idx]:
                self.report(messages.DuplicateArgument, node, arg)

    for child in annotations + defaults:
        if child:
            self.handleNode(child, node)

    def runFunction():

        self.pushScope()
        for name in args:
            self.addBinding(node, Argument(name, node))
        if isinstance(node.body, list):
            # case for FunctionDefs
            for stmt in node.body:
                self.handleNode(stmt, node)
        else:
            # case for Lambdas
            self.handleNode(node.body, node)

        def checkUnusedAssignments():
            """
            Check to see if any assignments have not been used.
            """
            for name, binding in self.scope.unusedAssignments():
                self.report(messages.UnusedVariable, binding.source, name)
        self.deferAssignment(checkUnusedAssignments)

        if PY32:
            def checkReturnWithArgumentInsideGenerator():
                """
                Check to see if there is any return statement with
                arguments but the function is a generator.
                """
                if self.scope.isGenerator and self.scope.returnValue:
                    self.report(messages.ReturnWithArgsInsideGenerator,
                                self.scope.returnValue)
            self.deferAssignment(checkReturnWithArgumentInsideGenerator)
        self.popScope()

    self.deferFunction(runFunction)
</t>
<t tx="ekr.20160519172255.73">def CLASSDEF(self, node):
    """
    Check names used in a class definition, including its decorators, base
    classes, and the body of its definition.  Additionally, add its name to
    the current scope.
    """
    for deco in node.decorator_list:
        self.handleNode(deco, node)
    for baseNode in node.bases:
        self.handleNode(baseNode, node)
    if not PY2:
        for keywordNode in node.keywords:
            self.handleNode(keywordNode, node)
    self.pushScope(ClassScope)
    if self.withDoctest:
        self.deferFunction(lambda: self.handleDoctests(node))
    for stmt in node.body:
        self.handleNode(stmt, node)
    self.popScope()
    self.addBinding(node, ClassDefinition(node.name, node))
</t>
<t tx="ekr.20160519172255.74">def AUGASSIGN(self, node):
    self.handleNodeLoad(node.target)
    self.handleNode(node.value, node)
    self.handleNode(node.target, node)
</t>
<t tx="ekr.20160519172255.75">def IMPORT(self, node):
    for alias in node.names:
        name = alias.asname or alias.name
        importation = Importation(name, node)
        self.addBinding(node, importation)
</t>
<t tx="ekr.20160519172255.76">def IMPORTFROM(self, node):
    if node.module == '__future__':
        if not self.futuresAllowed:
            self.report(messages.LateFutureImport,
                        node, [n.name for n in node.names])
    else:
        self.futuresAllowed = False

    for alias in node.names:
        if alias.name == '*':
            self.scope.importStarred = True
            self.report(messages.ImportStarUsed, node, node.module)
            continue
        name = alias.asname or alias.name
        importation = Importation(name, node)
        if node.module == '__future__':
            importation.used = (self.scope, node)
        self.addBinding(node, importation)
</t>
<t tx="ekr.20160519172255.77">def TRY(self, node):
    handler_names = []
    # List the exception handlers
    for handler in node.handlers:
        if isinstance(handler.type, ast.Tuple):
            for exc_type in handler.type.elts:
                handler_names.append(getNodeName(exc_type))
        elif handler.type:
            handler_names.append(getNodeName(handler.type))
    # Memorize the except handlers and process the body
    self.exceptHandlers.append(handler_names)
    for child in node.body:
        self.handleNode(child, node)
    self.exceptHandlers.pop()
    # Process the other nodes: "except:", "else:", "finally:"
    self.handleChildren(node, omit='body')

TRYEXCEPT = TRY
</t>
<t tx="ekr.20160519172255.78">def EXCEPTHANDLER(self, node):
    # 3.x: in addition to handling children, we must handle the name of
    # the exception, which is not a Name node, but a simple string.
    if isinstance(node.name, str):
        self.handleNodeStore(node)
    self.handleChildren(node)
</t>
<t tx="ekr.20160519172255.79">"""
Provide the class Message and its subclasses.
"""

@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20160519172255.8">def _exitOnSignal(sigName, message):
    """Handles a signal with sys.exit.

    Some of these signals (SIGPIPE, for example) don't exist or are invalid on
    Windows. So, ignore errors that might arise.
    """
    import signal

    try:
        sigNumber = getattr(signal, sigName)
    except AttributeError:
        # the signal constants defined in the signal module are defined by
        # whether the C library supports them or not. So, SIGPIPE might not
        # even be defined.
        return

    def handler(sig, f):
        sys.exit(message)

    try:
        signal.signal(sigNumber, handler)
    except ValueError:
        # It's also possible the signal is defined, but then it's invalid. In
        # this case, signal.signal raises ValueError.
        pass
</t>
<t tx="ekr.20160519172255.80">class Message(object):
    message = ''
    message_args = ()

    @others
</t>
<t tx="ekr.20160519172255.81">def __init__(self, filename, loc):
    self.filename = filename
    self.lineno = loc.lineno
    self.col = getattr(loc, 'col_offset', 0)
</t>
<t tx="ekr.20160519172255.82">def __str__(self):
    return '%s:%s: %s' % (self.filename, self.lineno,
                          self.message % self.message_args)
</t>
<t tx="ekr.20160519172255.83">class UnusedImport(Message):
    message = '%r imported but unused'

    @others
</t>
<t tx="ekr.20160519172255.84">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.85">class RedefinedWhileUnused(Message):
    message = 'redefinition of unused %r from line %r'

    @others
</t>
<t tx="ekr.20160519172255.86">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.87">class RedefinedInListComp(Message):
    message = 'list comprehension redefines %r from line %r'

    @others
</t>
<t tx="ekr.20160519172255.88">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.89">class ImportShadowedByLoopVar(Message):
    message = 'import %r from line %r shadowed by loop variable'

    @others
</t>
<t tx="ekr.20160519172255.9">def main(prog=None):
    """Entry point for the script "pyflakes"."""
    import optparse

    # Handle "Keyboard Interrupt" and "Broken pipe" gracefully
    _exitOnSignal('SIGINT', '... stopped')
    _exitOnSignal('SIGPIPE', 1)

    parser = optparse.OptionParser(prog=prog, version=__version__)
    (__, args) = parser.parse_args()
    reporter = modReporter._makeDefaultReporter()
    if args:
        warnings = checkRecursive(args, reporter)
    else:
        warnings = check(sys.stdin.read(), '&lt;stdin&gt;', reporter)
    raise SystemExit(warnings &gt; 0)
</t>
<t tx="ekr.20160519172255.90">def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)
</t>
<t tx="ekr.20160519172255.91">class ImportStarUsed(Message):
    message = "'from %s import *' used; unable to detect undefined names"

    @others
</t>
<t tx="ekr.20160519172255.92">def __init__(self, filename, loc, modname):
    Message.__init__(self, filename, loc)
    self.message_args = (modname,)
</t>
<t tx="ekr.20160519172255.93">class UndefinedName(Message):
    message = 'undefined name %r'

    @others
</t>
<t tx="ekr.20160519172255.94">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.95">class DoctestSyntaxError(Message):
    message = 'syntax error in doctest'

    @others
</t>
<t tx="ekr.20160519172255.96">def __init__(self, filename, loc, position=None):
    Message.__init__(self, filename, loc)
    if position:
        (self.lineno, self.col) = position
    self.message_args = ()
</t>
<t tx="ekr.20160519172255.97">class UndefinedExport(Message):
    message = 'undefined name %r in __all__'

    @others
</t>
<t tx="ekr.20160519172255.98">def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)
</t>
<t tx="ekr.20160519172255.99">class UndefinedLocal(Message):
    message = ('local variable %r (defined in enclosing scope on line %r) '
               'referenced before assignment')

    @others
</t>
<t tx="ekr.20160519172710.1"></t>
<t tx="ekr.20160519172730.1"></t>
<t tx="ekr.20160519172836.1"># "stmt" type nodes
DELETE = PRINT = FOR = ASYNCFOR = WHILE = IF = WITH = WITHITEM = \
    ASYNCWITH = ASYNCWITHITEM = RAISE = TRYFINALLY = ASSERT = EXEC = \
    EXPR = ASSIGN = handleChildren

CONTINUE = BREAK = PASS = ignore

# "expr" type nodes
BOOLOP = BINOP = UNARYOP = IFEXP = DICT = SET = \
    COMPARE = CALL = REPR = ATTRIBUTE = SUBSCRIPT = LIST = TUPLE = \
    STARRED = NAMECONSTANT = handleChildren

NUM = STR = BYTES = ELLIPSIS = ignore

# "slice" type nodes
SLICE = EXTSLICE = INDEX = handleChildren

# expression contexts are node instances too, though being constants
LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore

# same for operators
AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \
    BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \
    EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = ignore

# additional node types
COMPREHENSION = KEYWORD = handleChildren</t>
<t tx="ekr.20160519172947.1"># flattened, word, ignore-case, head, body</t>
<t tx="ekr.20160519173152.1"># EKR: like visitors</t>
<t tx="ekr.20160519173318.1"></t>
<t tx="ekr.20160519173339.1"></t>
<t tx="ekr.20160519180137.1">http://epydoc.sourceforge.net/manual-epytext.html

Epytext defines four types of inline markup that specify how text should be displayed:
    
I{...}: Italicized text.
B{...}: Bold-faced text.
C{...}: Source code or a Python identifier.
M{...}: A mathematical expression.

Also seen:
    
L{...}: </t>
<t tx="ekr.20160519180953.1">if PY2:
    def getNodeType(node_class):
        # workaround str.upper() which is locale-dependent
        return str(unicode(node_class.__name__).upper())
else:
    def getNodeType(node_class):
        return node_class.__name__.upper()</t>
<t tx="ekr.20160519181035.1"># Python &gt;= 3.3 uses ast.Try instead of (ast.TryExcept + ast.TryFinally)
# EKR: used only by differentForks
if PY32:
    def getAlternatives(n):
        if isinstance(n, (ast.If, ast.TryFinally)):
            return [n.body]
        if isinstance(n, ast.TryExcept):
            return [n.body + n.orelse] + [[hdl] for hdl in n.handlers]
else:
    def getAlternatives(n):
        if isinstance(n, ast.If):
            return [n.body]
        if isinstance(n, ast.Try):
            return [n.body + n.orelse] + [[hdl] for hdl in n.handlers]</t>
<t tx="ekr.20160519181348.1"></t>
<t tx="ekr.20160519182919.1">


# handle iter before target, and generators before element
# fields = node_class._fields
fields = ['value', 'w', 'iter', 'z', 'x']

if 'iter' in fields:
    key_first = 'iter'.find
elif 'generators' in fields:
    key_first = 'generators'.find
else:
    key_first = 'value'.find

aList = tuple(sorted(fields, key=key_first, reverse=True))
print(aList)

print(['iter'.find(z) for z in fields])
</t>
<t tx="ekr.20160519185320.1"># flattened, word, ignore-case, head, body</t>
<t tx="ekr.20160520081237.1">g.cls()
import time
import leo.core.leoGlobals as g
import leo.core.leoTest as leoTest
&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;
@others
run_test(scope='all')
</t>
<t tx="ekr.20160520081718.1"># Globally defined names which are not attributes of the builtins module, or
# are only present on some platforms.
_MAGIC_GLOBALS = ['__file__', '__builtins__', 'WindowsError']
</t>
<t tx="ekr.20160520081827.1">def run_test(scope):
    g_option_fn = None
    tables_table = leoTest.LinterTable().get_table(scope, fn=g_option_fn)
    g.trace(scope, len(tables_table))
    t1 = time.clock()
    n = 0
    for table, dir_ in tables_table:
        g.trace(len(table), dir_)
        n += len(table)
        check_all(dir_, table)
    t2 = time.clock()
    print('%s file%s, time: %5.2f sec.' % (n, g.plural(n), t2-t1))
</t>
<t tx="ekr.20160520082209.1">def check_all(dir_, files):
    '''Run pyflakes on all files.'''
    # from pyflakes import api, reporter
    loadDir = g.os_path_finalize_join(g.__file__, '..', '..')
    paths = []
    for fn in files:
        if dir_:
            fn = g.os_path_join(loadDir, dir_, fn)
        else:
            fn = g.os_path_join(loadDir, fn)
        fn = g.os_path_abspath(fn)
        if not fn.endswith('.py'):
            fn = fn+'.py'
        paths.append(fn)
    for fn in paths:
        # Report the file name.
        sfn = g.shortFileName(fn)
        s = g.readFileIntoEncodedString(fn, silent=False)
        if not s or not s.strip():
            g.trace('can not read:', fn)
            return
        r = Reporter( # reporter.Reporter
            errorStream=sys.stderr,
            warningStream=sys.stderr,
            )
        errors = check(s, sfn, r) # api.check
        if errors:
            print('pyflakes: %s error%s in %s' % (
                errors, g.plural(errors), fn))
</t>
<t tx="ekr.20160520082308.1">def check(codeString, filename, reporter=None):
    """
    Check the Python source given by C{codeString} for flakes.

    @param codeString: The Python source to check.
    @type codeString: C{str}

    @param filename: The name of the file the source came from, used to report
        errors.
    @type filename: C{str}

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: The number of warnings emitted.
    @rtype: C{int}
    """
    _ast = ast # EKR

    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    # First, compile into an AST and handle syntax errors.
    try:
        tree = compile(codeString, filename, "exec", _ast.PyCF_ONLY_AST)
    except SyntaxError:
        value = sys.exc_info()[1]
        msg = value.args[0]

        (lineno, offset, text) = value.lineno, value.offset, value.text

        # If there's an encoding problem with the file, the text is None.
        if text is None:
            # Avoid using msg, since for the only known case, it contains a
            # bogus message that claims the encoding the file declared was
            # unknown.
            g.es_print_exception() # EKR
            reporter.unexpectedError(filename, 'problem decoding source')
        else:
            reporter.syntaxError(filename, msg, lineno, offset, text)
        return 1
    except Exception:
        g.es_print_exception() # EKR
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    # Okay, it's syntactically valid.  Now check it.
    # w = checker.Checker(tree, filename)
    w = Checker(tree, filename)
    w.messages.sort(key=lambda m: m.lineno)
    for warning in w.messages:
        reporter.flake(warning)
    return len(w.messages)
</t>
<t tx="ekr.20160520082346.1">class Reporter(object):
    """
    Formats the results of pyflakes checks to users.
    """
    @others
</t>
<t tx="ekr.20160520082346.2">def __init__(self, warningStream, errorStream):
    """
    Construct a L{Reporter}.

    @param warningStream: A file-like object where warnings will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stdout} is a good value.
    @param errorStream: A file-like object where error output will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stderr} is a good value.
    """
    self._stdout = warningStream
    self._stderr = errorStream
</t>
<t tx="ekr.20160520082346.3">def unexpectedError(self, filename, msg):
    """
    An unexpected error occurred trying to process C{filename}.

    @param filename: The path to a file that we could not process.
    @ptype filename: C{unicode}
    @param msg: A message explaining the problem.
    @ptype msg: C{unicode}
    """
    self._stderr.write("%s: %s\n" % (filename, msg))
</t>
<t tx="ekr.20160520082346.4">def syntaxError(self, filename, msg, lineno, offset, text):
    """
    There was a syntax errror in C{filename}.

    @param filename: The path to the file with the syntax error.
    @ptype filename: C{unicode}
    @param msg: An explanation of the syntax error.
    @ptype msg: C{unicode}
    @param lineno: The line number where the syntax error occurred.
    @ptype lineno: C{int}
    @param offset: The column on which the syntax error occurred, or None.
    @ptype offset: C{int}
    @param text: The source code containing the syntax error.
    @ptype text: C{unicode}
    """
    line = text.splitlines()[-1]
    if offset is not None:
        offset = offset - (len(text) - len(line))
        self._stderr.write('%s:%d:%d: %s\n' %
                           (filename, lineno, offset + 1, msg))
    else:
        self._stderr.write('%s:%d: %s\n' % (filename, lineno, msg))
    self._stderr.write(line)
    self._stderr.write('\n')
    if offset is not None:
        self._stderr.write(re.sub(r'\S', ' ', line[:offset]) +
                           "^\n")
</t>
<t tx="ekr.20160520082346.5">def flake(self, message):
    """
    pyflakes found something wrong with the code.

    @param: A L{pyflakes.messages.Message}.
    """
    self._stdout.write(str(message))
    self._stdout.write('\n')
</t>
<t tx="ekr.20160520102401.1"></t>
</tnodes>
</leo_file>
